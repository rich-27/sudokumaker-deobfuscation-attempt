var Ff = Object.defineProperty;
var ga = (t) => {
  throw TypeError(t);
};
var Bf = (t, e, n) =>
  e in t
    ? Ff(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
    : (t[e] = n);
var L = (t, e, n) => Bf(t, typeof e != "symbol" ? e + "" : e, n),
  zf = (t, e, n) => e.has(t) || ga("Cannot " + n);
var va = (t, e, n) =>
  e.has(t)
    ? ga("Cannot add the same private member more than once")
    : e instanceof WeakSet
    ? e.add(t)
    : e.set(t, n);
var ya = (t, e, n) => (zf(t, e, "access private method"), n);
import {
  r as rn,
  w as ae,
  d as S,
  o as d,
  c as C,
  a as G,
  n as Ae,
  b as w,
  e as f,
  f as h,
  m as fr,
  g as j,
  h as b,
  F as Z,
  i as se,
  j as Qt,
  k as hi,
  t as X,
  u as zn,
  l as nc,
  p as c,
  q as H,
  s as zo,
  v as Rf,
  H as Of,
  x as Fe,
  y as Nf,
  z as Tf,
  A as Vf,
  B as jf,
  C as Uf,
  D as Hf,
  E as Wf,
  G as Zf,
  I as Gf,
  J as qf,
  K as Kf,
  L as Xf,
  M as Yf,
  N as Jf,
  O as Qf,
  P as e1,
  Q as t1,
  R as n1,
  S as s1,
  T as o1,
  U as r1,
  V as l1,
  W as i1,
  X as a1,
  Y as u1,
  Z as c1,
  _ as d1,
  $ as p1,
  a0 as Ml,
  a1 as Ca,
  a2 as ys,
  a3 as Xt,
  a4 as wa,
  a5 as ba,
  a6 as Nr,
  a7 as f1,
  a8 as Tr,
  a9 as Ln,
  aa as y,
  ab as z,
  ac as st,
  ad as F,
  ae as to,
  af as sr,
  ag as cs,
  ah as vl,
  ai as ka,
  aj as h1,
  ak as m1,
  al as mi,
  am as We,
  an as sc,
  ao as bs,
  ap as wn,
  aq as qe,
  ar as Dn,
  as as Rn,
  at as St,
  au as Qe,
  av as g1,
  aw as gi,
  ax as v1,
  ay as y1,
  az as oc,
  aA as C1,
  aB as Cr,
  aC as Al,
  aD as Vr,
  aE as vi,
  aF as w1,
  aG as b1,
  aH as yi,
  aI as k1,
  aJ as os,
  aK as Ro,
  aL as Nt,
  aM as _a,
  aN as Ci,
  aO as _1,
} from "./vendor-C_7F_aJJ.js";
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const o of document.querySelectorAll('link[rel="modulepreload"]')) s(o);
  new MutationObserver((o) => {
    for (const r of o)
      if (r.type === "childList")
        for (const l of r.addedNodes)
          l.tagName === "LINK" && l.rel === "modulepreload" && s(l);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(o) {
    const r = {};
    return (
      o.integrity && (r.integrity = o.integrity),
      o.referrerPolicy && (r.referrerPolicy = o.referrerPolicy),
      o.crossOrigin === "use-credentials"
        ? (r.credentials = "include")
        : o.crossOrigin === "anonymous"
        ? (r.credentials = "omit")
        : (r.credentials = "same-origin"),
      r
    );
  }
  function s(o) {
    if (o.ep) return;
    o.ep = !0;
    const r = n(o);
    fetch(o.href, r);
  }
})();
var _ = ((t) => (
  (t[(t.Givens = 0)] = "Givens"),
  (t[(t.Regions = 1)] = "Regions"),
  (t[(t.DiagonalMinus = 10)] = "DiagonalMinus"),
  (t[(t.DiagonalPlus = 11)] = "DiagonalPlus"),
  (t[(t.Antiking = 12)] = "Antiking"),
  (t[(t.Antiknight = 13)] = "Antiknight"),
  (t[(t.DisjointGroups = 14)] = "DisjointGroups"),
  (t[(t.Nonconsecutive = 15)] = "Nonconsecutive"),
  (t[(t.GlobalEntropy = 16)] = "GlobalEntropy"),
  (t[(t.Even = 100)] = "Even"),
  (t[(t.Odd = 101)] = "Odd"),
  (t[(t.Maximum = 102)] = "Maximum"),
  (t[(t.Minimum = 103)] = "Minimum"),
  (t[(t.Difference = 200)] = "Difference"),
  (t[(t.Ratio = 201)] = "Ratio"),
  (t[(t.XV = 202)] = "XV"),
  (t[(t.Thermometer = 300)] = "Thermometer"),
  (t[(t.KillerCages = 301)] = "KillerCages"),
  (t[(t.Clone = 302)] = "Clone"),
  (t[(t.Quadruple = 303)] = "Quadruple"),
  (t[(t.LookAndSayCages = 304)] = "LookAndSayCages"),
  (t[(t.DifferentValues = 305)] = "DifferentValues"),
  (t[(t.Renban = 400)] = "Renban"),
  (t[(t.Whisper = 401)] = "Whisper"),
  (t[(t.Palindrome = 402)] = "Palindrome"),
  (t[(t.BetweenLines = 403)] = "BetweenLines"),
  (t[(t.RegionSumLine = 404)] = "RegionSumLine"),
  (t[(t.Sequence = 405)] = "Sequence"),
  (t[(t.EntropyLines = 406)] = "EntropyLines"),
  (t[(t.LockoutLines = 407)] = "LockoutLines"),
  (t[(t.Arrow = 408)] = "Arrow"),
  (t[(t.DoubleArrow = 409)] = "DoubleArrow"),
  (t[(t.LittleKillers = 500)] = "LittleKillers"),
  (t[(t.SandwichSums = 501)] = "SandwichSums"),
  (t[(t.XSums = 502)] = "XSums"),
  (t[(t.Skyscrapers = 503)] = "Skyscrapers"),
  (t[(t.NumberedRooms = 504)] = "NumberedRooms"),
  (t[(t.RowIndexer = 600)] = "RowIndexer"),
  (t[(t.ColumnIndexer = 601)] = "ColumnIndexer"),
  (t[(t.Custom = 1e3)] = "Custom"),
  (t[(t.CosmeticLine = 2e3)] = "CosmeticLine"),
  (t[(t.CosmeticCage = 2001)] = "CosmeticCage"),
  (t[(t.CosmeticSymbol = 2002)] = "CosmeticSymbol"),
  (t[(t.SudokuRules = 2003)] = "SudokuRules"),
  (t[(t.FogLights = 4e3)] = "FogLights"),
  (t[(t.FogTriggers = 4001)] = "FogTriggers"),
  t
))(_ || {});
function xs({ name: t, version: e, getDefault: n, migrate: s, syncTabs: o }) {
  let r = !1,
    l;
  s || (s = (u, p) => (p !== e ? n() : u));
  let i;
  try {
    const u = localStorage.getItem(t);
    u && (i = JSON.parse(u));
  } catch {}
  if (i != null && i._version) {
    const u = (i._version = Number(i._version));
    e === u
      ? (l = i)
      : u > e
      ? ((r = !0), (l = { _version: e, ...n() }))
      : e > u
      ? ((l = { ...s(i, u), _version: e }),
        localStorage.setItem(t, JSON.stringify(l)))
      : (l = i);
  } else l = { _version: e, ...n() };
  const a = rn(l);
  return (
    ae(
      () => a,
      () => {
        r || localStorage.setItem(t, JSON.stringify(l));
      },
      { deep: !0 }
    ),
    o &&
      window.addEventListener("storage", (u) => {
        if (u.storageArea === localStorage && u.key === t) {
          let p = {};
          try {
            if (((p = JSON.parse(localStorage.getItem(t))), p._version !== e)) {
              (r = !0),
                alert(
                  "There seems to be a mismatch between app versions across tabs. Please ensure all tabs are using the same version before continuing. Otherwise data may get lost."
                );
              return;
            }
            Object.assign(a, p);
          } catch {}
        }
      }),
    a
  );
}
function rc(t) {
  let e = 0;
  for (const n of t) e += n;
  return e;
}
function $1(t) {
  let e = 1;
  for (const n of t) e *= n;
  return e;
}
function xt(t, e) {
  return ((t % e) + e) % e;
}
function Rt(t, e, n) {
  return Math.min(Math.max(e, t), n);
}
function S1(t, e, n) {
  return t + (e - t) * n;
}
function Cs(t) {
  return (t * (t + 1)) / 2;
}
const ao = [
    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
    73, 79, 83,
  ],
  I1 = new Set(ao),
  no = new Map();
function lc(t) {
  if (t < 87) return I1.has(t);
  if (no.has(t)) return no.get(t);
  if (t % 2 === 0) return no.set(t, !1), !1;
  for (let e = 3; e * e <= t; e += 2) if (t % e === 0) return no.set(t, !1), !1;
  return no.set(t, !0), !0;
}
function x1(t) {
  if (t % 1 !== 0) throw new Error("Cannot factorize non-integers");
  const e = [];
  let n = 0;
  for (; n < ao.length; ) {
    const s = ao[n];
    for (; t % s === 0; ) e.push(s), (t /= s);
    if (Math.abs(t) === 1) return e;
    n++;
  }
  for (let s = ao[ao.length - 1] + 2; ; s += 2)
    if (lc(s)) {
      for (; t % s === 0; ) e.push(s), (t /= s);
      if (Math.abs(t) === 1) return e;
    }
}
function D1(t) {
  return (t / Math.PI) * 180;
}
function wi(t) {
  return (t / 180) * Math.PI;
}
const ic = {
  sum: rc,
  product: $1,
  mod: xt,
  clamp: Rt,
  lerp: S1,
  triangularNumber: Cs,
  isPrime: lc,
  getFactors: x1,
  toDegrees: D1,
  toRadians: wi,
};
function M1(t, e, { comparator: n = (s, o) => s === o } = {}) {
  return t.reduce((s, o) => s + (n(o, e) ? 1 : 0), 0);
}
function A1(t, e) {
  return t.reduce((n, s) => n + (e(s) ? 1 : 0), 0);
}
function Pn(t, e, n) {
  if (n != null && n.comparator) return ac(t, (o) => n.comparator(e, o));
  const s = t.indexOf(e);
  return s === -1 || t.splice(s, 1), t;
}
function ac(t, e) {
  const n = t.findIndex(e);
  return n === -1 || t.splice(n, 1), t;
}
function mn(t, e, n) {
  if (n != null && n.comparator) {
    const r = cc(e, { unique: !0 });
    return t.filter((l) => !r.find((i) => n.comparator(l, i)));
  }
  const s = new Set(e),
    o = [];
  for (const r of t) s.has(r) || o.push(r);
  return o;
}
function _t(t, e, n) {
  if (n != null && n.comparator) {
    const r = [...t],
      l = cc(e, { unique: !0 });
    t.length = 0;
    for (const i of r) l.find((a) => n.comparator(i, a)) || t.push(i);
    return t;
  }
  const s = [...t],
    o = new Set(e);
  t.length = 0;
  for (const r of s) o.has(r) || t.push(r);
  return t;
}
function P1(t, e) {
  const n = [...t];
  t.length = 0;
  for (const s of n) e(s) || t.push(s);
  return t;
}
function uc(t, e, n) {
  if (n != null && n.comparator) {
    for (const s of e) if (t.some((o) => n.comparator(s, o))) return !0;
    return !1;
  }
  for (const s of e) if (t.includes(s)) return !0;
  return !1;
}
function L1(t, e, n) {
  if (n != null && n.comparator) {
    for (const s of e) if (!t.some((o) => n.comparator(s, o))) return !1;
    return !0;
  }
  for (const s of e) if (!t.includes(s)) return !1;
  return !0;
}
function E1(t) {
  t = t.slice();
  for (let e = t.length - 1; e > 0; e--) {
    const n = Math.floor(Math.random() * (e + 1));
    [t[e], t[n]] = [t[n], t[e]];
  }
  return t;
}
function Kn(t, e) {
  const n = [];
  for (const s of t) n.push(e(s));
  return n;
}
function F1(t, e, n) {
  if (t.length === 0) return [];
  const s = [];
  for (let o = e; o < n; o++) s.push(t[xt(o, t.length)]);
  return s;
}
function bi(t, e) {
  const n = [];
  let s;
  for (let o = 0; o < t.length; o++)
    o % e === 0 && ((s = []), n.push(s)), s.push(t[o]);
  return n;
}
function B1(...t) {
  return t.length === 0 ? !0 : t.every((e) => e.length === t[0].length);
}
function ki(t, e) {
  if (e != null && e.comparator)
    return z1(t, e == null ? void 0 : e.comparator);
  const n = new Set();
  for (let s = 0; s < t.length; s++) {
    if (n.has(t[s])) return !0;
    n.add(t[s]);
  }
  return !1;
}
function z1(t, e) {
  for (let n = 0; n < t.length; n++)
    for (let s = n + 1; s < t.length; s++) if (e(t[n], t[s])) return !0;
  return !1;
}
function Ns(t, e) {
  return e != null && e.comparator
    ? R1(t, e.comparator)
    : Array.from(new Set(t));
}
function R1(t, e) {
  let n = -1;
  const s = t.length,
    o = [];
  for (; ++n < s; ) {
    const r = t[n];
    o.find((l) => e(l, r)) || o.push(r);
  }
  return o;
}
function Et(t) {
  return Array.isArray(t) ? t : [t];
}
function cc(t, { unique: e = !1 } = {}) {
  return Array.isArray(t)
    ? e
      ? Ns(t)
      : t
    : (e && !(t instanceof Set) && (t = new Set(t)), Array.from(t));
}
const Lt = {
    count: M1,
    countWhere: A1,
    removeFirst: Pn,
    removeFirstWhere: ac,
    withoutAll: mn,
    remove: _t,
    removeWhere: P1,
    includesSome: uc,
    includesEvery: L1,
    shuffled: E1,
    mapIterable: Kn,
    sliceWrapped: F1,
    chunk: bi,
    areSameLength: B1,
    hasDuplicates: ki,
    withoutDuplicates: Ns,
    ensureArray: Et,
  },
  O1 = 1;
class N1 {
  constructor(e) {
    L(this, "specification");
    L(this, "state");
    (this.specification = e),
      (this.state = xs({
        name: this.specification.storageKey,
        version: O1,
        getDefault() {
          return { entries: [] };
        },
        syncTabs: !0,
      })),
      (this.state.entries = Ns(this.state.entries, {
        comparator: (n, s) => n.url === s.url,
      }));
  }
  register(e, n) {
    const s = this.state.entries.find((o) => o.creationTimestamp === n);
    for (
      s
        ? ((s.latestUpdateTimestamp = Date.now()),
          (s.url = e),
          Pn(this.state.entries, s),
          this.state.entries.unshift(s))
        : this.state.entries.unshift({
            creationTimestamp: n,
            latestUpdateTimestamp: Date.now(),
            url: e,
          });
      this.state.entries.length > this.specification.limit;

    )
      this.state.entries.pop();
  }
  removeEntry(e) {
    const n = this.state.entries.findIndex((s) => s.creationTimestamp === e);
    n > -1 && this.state.entries.splice(n, 1);
  }
  getEntries() {
    return this.state.entries;
  }
  isEmpty() {
    return this.state.entries.length === 0;
  }
  merge(e) {
    let n = 0;
    if (!Array.isArray(e)) return { failed: 0, success: n };
    for (const s of e) {
      const o = s;
      if (!o.creationTimestamp || !o.latestUpdateTimestamp || !o.url) continue;
      const r = this.state.entries.find((l) => l.url === o.url);
      r
        ? ((r.creationTimestamp = Math.max(
            r.creationTimestamp,
            o.creationTimestamp
          )),
          (r.latestUpdateTimestamp = Math.max(
            r.creationTimestamp,
            o.latestUpdateTimestamp
          )))
        : this.state.entries.push(o),
        n++;
    }
    return (
      this.state.entries.sort(
        (s, o) => o.latestUpdateTimestamp - s.latestUpdateTimestamp
      ),
      { success: n, failed: e.length - n }
    );
  }
  clear() {
    this.state.entries.length = 0;
  }
}
const dc = "sudokuHistory",
  pc = 200,
  En = new N1({ storageKey: dc, limit: pc }),
  wr = "Untitled puzzle",
  T1 = "Untitled",
  Co = {
    sudokuPad: {
      showDigits: !1,
      showColorMarks: !1,
      useIncompleteGridAsSolution: !1,
      solution: { type: "grid" },
    },
  };
function gn(t, ...e) {
  return typeof t == "function" ? t(...e) : t;
}
class V1 {
  constructor() {
    L(this, "map", new Map());
  }
  register(e) {
    this.map.set(e.type, e);
  }
  getRenderers(e, n, s) {
    var o, r;
    return (r = (o = this.map.get(e.type)) == null ? void 0 : o.renderers) ==
      null
      ? void 0
      : r.call(o, e, n, s);
  }
  getEditor(e) {
    var n;
    return (n = this.map.get(e)) == null ? void 0 : n.editor;
  }
  getLabel(e, n) {
    return gn(this.map.get(e.type).label, e, n);
  }
  getMargins(e, n) {
    const s = this.map.get(e.type).margins;
    return s ? gn(s, e, n) : { left: 0, right: 0, top: 0, bottom: 0 };
  }
  getPreview(e) {
    return this.map.get(e).preview;
  }
  getIsSelectable(e) {
    return this.map.get(e).selectable ?? !0;
  }
  getIsOpenable(e) {
    return e === _.Givens || !!this.getEditor(e);
  }
  getIsUnique(e) {
    return this.map.get(e).unique ?? !1;
  }
  getIsUnbound(e) {
    return this.map.get(e).gridUnbound ?? !1;
  }
  getIsIgnoredBySolver(e) {
    return this.map.get(e).ignoredBySolver ?? !1;
  }
  getActions(e, n) {
    var s;
    return (s = this.map.get(e.type)) != null && s.actions
      ? gn(this.map.get(e.type).actions, e, n)
      : [];
  }
}
const je = new V1();
function _e(t) {
  je.register(t);
}
class rs {
  constructor(e, n, s) {
    L(this, "value");
    L(this, "given", !1);
    L(this, "cornerPencilMarks", 0);
    L(this, "colors", 0);
    L(this, "candidates", 0);
    L(this, "id");
    L(this, "x");
    L(this, "y");
    L(this, "valid", !0);
    (this.id = e), (this.x = n), (this.y = s);
  }
  clearValue() {
    this.value !== void 0 &&
      ((this.candidates & 1023) === 1 << this.value && (this.candidates = 0),
      (this.value = void 0));
  }
  addCandidate(e) {
    this.candidates |= 1 << e;
  }
  removeCandidate(e) {
    this.candidates &= ~(1 << e);
  }
  addCornerPencilMark(e) {
    this.cornerPencilMarks |= 1 << e;
  }
  removeCornerPencilMark(e) {
    this.cornerPencilMarks &= ~(1 << e);
  }
  addColor(e) {
    this.colors |= 1 << e;
  }
  removeColor(e) {
    (this.colors &= ~(1 << e)), this.colors === 1 && (this.colors = 0);
  }
  clear() {
    this.given || (this.value = void 0),
      (this.candidates = 0),
      (this.colors = 0),
      (this.cornerPencilMarks = 0);
  }
  isEmpty() {
    return (
      this.value === void 0 &&
      this.candidates === 0 &&
      this.colors === 0 &&
      this.cornerPencilMarks === 0
    );
  }
  clone() {
    const e = new rs(this.id, this.x, this.y);
    return Object.assign(e, this), e;
  }
}
const fo = 4294967295;
function fc(t) {
  const e = new Uint32Array(t.length * 2);
  for (let n = 0; n < t.length; n++)
    (e[n * 2] = t[n].value ?? fo), (e[n * 2 + 1] = t[n].candidates);
  return e;
}
function j1(t, e) {
  for (let n = 0; n < t.length; n++)
    (t[n].value = e[n * 2] === fo ? void 0 : e[n * 2]),
      (t[n].candidates = e[n * 2 + 1]);
}
function U1(t, e) {
  for (let n = 0; n < t.length; n += 2)
    e[n] !== fo &&
      e[n] !== t[n] &&
      (t[n] !== fo
        ? ((t[n + 1] = (1 << t[n]) | (1 << e[n])), (t[n] = fo))
        : (t[n + 1] |= 1 << e[n]));
}
class jr {
  constructor(e) {
    L(this, "spec");
    L(this, "width");
    L(this, "height");
    (this.spec = e), (this.width = e.size.width), (this.height = e.size.height);
  }
  getX(e) {
    return e % this.width;
  }
  getY(e) {
    return Math.floor(e / this.width);
  }
  getCoordsFromId(e) {
    return { x: this.getX(e), y: this.getY(e) };
  }
  getIdFromCoords(e) {
    return e.x + e.y * this.width;
  }
  getIdFromCoordsSafe(e) {
    if (!(e.x < 0 || e.y < 0 || e.x >= this.width || e.y >= this.height))
      return this.getIdFromCoords(e);
  }
  areValidCoords({ x: e, y: n }) {
    return e >= 0 && n >= 0 && e < this.width && n < this.height;
  }
  getAllCellIds() {
    return Array.from({ length: this.width * this.height }, (e, n) => n);
  }
  getCellCenterFromId(e) {
    return { x: this.getX(e) + 0.5, y: this.getY(e) + 0.5 };
  }
}
function Mn(t) {
  for (const e of t) return t.delete(e), e;
}
function Ur(t, e, n) {
  if (n != null && n.comparator)
    for (const s of e) for (const o of t) n.comparator(s, o) && t.delete(o);
  else for (const s of e) t.delete(s);
  return t;
}
function Pl(t, e, n) {
  const s = new Set(t);
  if (n != null && n.comparator)
    for (const o of e)
      for (const r of s) n != null && n.comparator(r, o) && s.delete(r);
  else for (const o of e) s.delete(o);
  return s;
}
function H1(t, e) {
  return "has" in t && "has" in e ? W1(t, e) : mc(Pl(t, e), Pl(e, t));
}
function W1(t, e) {
  const n = new Set();
  for (const s of t) e.has(s) || n.add(s);
  for (const s of e) t.has(s) || n.add(s);
  return n;
}
function Z1(t, e) {
  for (const n of t) e.has(n) || t.delete(n);
  return t;
}
function G1(t, e) {
  const n = new Set(t);
  for (const s of t) e.has(s) || n.delete(s);
  return n;
}
function hc(t, e) {
  for (const n of e) t.add(n);
  return t;
}
function mc(t, e) {
  const n = new Set(t);
  for (const s of e) n.add(s);
  return n;
}
function Hr(t, e, n) {
  return t.size !== e.size ? !1 : _i(t, e, n);
}
function _i(t, e, n) {
  if (n != null && n.comparator) {
    const s = n.comparator;
    for (const o of e) {
      let r = !1;
      for (const l of t)
        if (s(l, o)) {
          r = !0;
          break;
        }
      if (!r) return !1;
    }
    return !0;
  }
  for (const s of e) if (!t.has(s)) return !1;
  return !0;
}
function ho(t, e, n) {
  if (n != null && n.comparator) {
    const s = n.comparator;
    for (const o of e) for (const r of t) if (s(r, o)) return !0;
    return !1;
  }
  for (const s of e) if (t.has(s)) return !0;
  return !1;
}
function q1(t, e) {
  for (const n of t) if (e(n)) return !0;
  return !1;
}
const He = {
  takeOne: Mn,
  deleteAll: Ur,
  difference: Pl,
  symmetricDifference: H1,
  filter: Z1,
  intersection: G1,
  addAll: hc,
  union: mc,
  isEqual: Hr,
  hasAll: _i,
  hasSome: ho,
  hasSomeWhere: q1,
};
function wo(t) {
  return t[Symbol.iterator]().next().value;
}
function* K1(t, e) {
  for (let n = t; n < e; n++) yield n;
}
function* Ve(t, e) {
  for (let n = t; n <= e; n++) yield n;
}
function* gc(t, e) {
  const n = [...t],
    s = n.length;
  if (e > s) return;
  const o = Array.from({ length: e }, (r, l) => l);
  for (yield o.map((r) => n[r]); ; ) {
    let r = e - 1;
    for (; r >= 0 && o[r] === r + s - e; ) r--;
    if (r === -1) return;
    o[r]++;
    for (let l = r + 1; l < e; l++) o[l] = o[l - 1] + 1;
    yield o.map((l) => n[l]);
  }
}
function $i(t) {
  const e = new Map();
  for (const n of t) e.set(n, (e.get(n) || 0) + 1);
  return e;
}
function X1(t, e, n) {
  let s = -1 / 0,
    o = n;
  for (const r of t) {
    const l = e(r);
    l > s && ((o = r), (s = l));
  }
  return o;
}
const Si = {
  getOne: wo,
  getRange: K1,
  getRangeInclusive: Ve,
  getCombinations: gc,
  getCounts: $i,
  getBest: X1,
};
function ue(t) {
  if (Array.isArray(t)) return t.map((e) => ue(e));
  if (t instanceof Set) return new Set([...t].map((e) => ue(e)));
  if (t instanceof Map) return new Map([...t].map(([e, n]) => [e, ue(n)]));
  if (typeof t == "object") {
    const e = {};
    for (const n in t) e[n] = ue(t[n]);
    return e;
  }
  return t;
}
const or = new WeakMap(),
  yl = new Map();
function vc(t) {
  if (["string", "number", "boolean"].includes(typeof t)) return t.toString();
  let e = "";
  for (const [n, s] of Object.entries(t)) e += `${n}:(${vc(s)});`;
  return e;
}
function Ue(t) {
  if (t == null || ["string", "number", "boolean"].includes(typeof t)) return t;
  if (or.has(t)) return or.get(t);
  const e = vc(t);
  if (yl.has(e)) {
    const s = yl.get(e);
    return or.set(t, s), s;
  }
  const n = ue(t);
  return yl.set(e, n), or.set(t, n), n;
}
class Ut {
  constructor(e = [], n = (s, o) => s > o) {
    L(this, "pointsConnected", new Map());
    this.isGreaterThan = n;
    for (const s of e) this.addLine(s);
  }
  addLine(e) {
    for (let n = 0; n < e.length - 1; n++) this.addEdge(e[n], e[n + 1]);
    return this;
  }
  addPoint(e) {
    this.pointsConnected.has(e) || this.pointsConnected.set(e, new Set());
  }
  addPoints(e) {
    for (const n of e) this.addPoint(n);
  }
  addEdge(e, n) {
    return (
      (e = Ue(e)),
      (n = Ue(n)),
      this.pointsConnected.has(e) || this.pointsConnected.set(e, new Set()),
      this.pointsConnected.has(n) || this.pointsConnected.set(n, new Set()),
      this.pointsConnected.get(e).add(n),
      this.pointsConnected.get(n).add(e),
      this
    );
  }
  removeEdge(e, n, s = !0) {
    var o, r, l, i;
    return (
      (e = Ue(e)),
      (n = Ue(n)),
      !this.pointsConnected.has(e) || !this.pointsConnected.has(n)
        ? this
        : ((o = this.pointsConnected.get(e)) == null || o.delete(n),
          s &&
            ((r = this.pointsConnected.get(e)) == null ? void 0 : r.size) ===
              0 &&
            this.pointsConnected.delete(e),
          (l = this.pointsConnected.get(n)) == null || l.delete(e),
          s &&
            ((i = this.pointsConnected.get(n)) == null ? void 0 : i.size) ===
              0 &&
            this.pointsConnected.delete(n),
          this)
    );
  }
  removePoint(e) {
    if (((e = Ue(e)), !this.pointsConnected.has(e))) return this;
    for (const n of this.pointsConnected.get(e)) this.removeEdge(e, n);
    return this;
  }
  hasEdge(e, n) {
    var s;
    return (
      (e = Ue(e)),
      (n = Ue(n)),
      !!((s = this.pointsConnected.get(e)) != null && s.has(n))
    );
  }
  hasPoint(e) {
    return (e = Ue(e)), this.pointsConnected.has(e);
  }
  getPoints() {
    return [...this.pointsConnected.keys()];
  }
  *getEdges() {
    for (const [e, n] of this.pointsConnected)
      for (const s of n) this.isGreaterThan(s, e) && (yield [e, s]);
  }
  getPointsAdjacentTo(e) {
    return (e = Ue(e)), this.pointsConnected.get(e) || new Set();
  }
  getPointCount() {
    return this.pointsConnected.size;
  }
  isEmpty() {
    return this.pointsConnected.size === 0;
  }
  *getAllComponents() {
    const e = new Set(this.getPoints());
    for (; e.size > 0; ) {
      const n = this.getComponentContainingPoint(Mn(e));
      for (const s of n.getPoints()) e.delete(s);
      yield n;
    }
  }
  *getConnectedPointSets(e) {
    e ? (e = [...e].map((s) => Ue(s))) : (e = this.getPoints());
    const n = new Set(e);
    for (; n.size > 0; ) {
      const s = this.getPointsConnectedTo(Mn(n));
      for (const o of s) n.delete(o);
      yield [...s];
    }
  }
  getPointsConnectedTo(e) {
    e = Ue(e);
    const n = new Set(),
      s = new Set([e]);
    for (; s.size > 0; ) {
      const o = Mn(s);
      if (!(n.has(o) || !this.pointsConnected.has(o))) {
        n.add(o);
        for (const r of this.pointsConnected.get(o)) s.add(r);
      }
    }
    return n;
  }
  getComponentContainingPoint(e) {
    e = Ue(e);
    const n = this.getPointsConnectedTo(e),
      s = new Ut([], this.isGreaterThan);
    s.addPoints(n);
    for (const o of n)
      for (const r of this.pointsConnected.get(o))
        this.isGreaterThan(r, o) && s.addEdge(o, r);
    return s;
  }
  getComponentsContainingPoints(e) {
    e = [...e].map((r) => Ue(r));
    const n = new Set(e),
      s = [];
    for (; n.size > 0; ) {
      const r = Mn(n),
        l = [...this.getPointsConnectedTo(r)];
      Ur(n, l), s.push(l);
    }
    const o = new Ut([], this.isGreaterThan);
    o.addPoints(e);
    for (const r of s)
      for (const l of r)
        for (const i of this.pointsConnected.get(l))
          this.isGreaterThan(i, l) && o.addEdge(l, i);
    return o;
  }
  isSimpleLines() {
    for (const e of this.pointsConnected.values()) if (e.size > 2) return !1;
    return !0;
  }
  hasCycles() {
    const e = new Set(),
      n = new Set(),
      s = (o, r) => {
        if (!e.has(o)) {
          e.add(o), n.add(o);
          const l = this.pointsConnected.get(o);
          if (l) {
            for (const i of l)
              if (i !== r && ((!e.has(i) && s(i, o)) || n.has(i))) return !0;
          }
        }
        return n.delete(o), !1;
      };
    for (const o of this.getPoints()) if (!e.has(o) && s(o)) return !0;
    return !1;
  }
  toArrays() {
    const e = this.clone(),
      n = () => {
        for (const l of e.pointsConnected.keys())
          if (e.pointsConnected.get(l).size === 1) return l;
        return wo(e.pointsConnected.keys());
      };
    let s = 0;
    function o() {
      const l = new Set(),
        i = [];
      let a = n();
      for (;;) {
        if ((s++, s > 1e3)) throw new Error("This should never happen");
        if ((i.push(a), l.has(a))) return i;
        l.add(a);
        const u = e.pointsConnected.get(a),
          p = u ? wo(u) : void 0;
        if (p === void 0) return i;
        e.removeEdge(a, p), (a = p);
      }
    }
    const r = [];
    for (; e.getPointCount() > 0; ) r.push(o());
    return r;
  }
  clone() {
    return new Ut(this.getEdges(), this.isGreaterThan);
  }
}
class Y1 {
  constructor(e) {
    L(this, "spec");
    L(this, "geometryHelper");
    (this.spec = e.spec), (this.geometryHelper = e);
  }
  getOrthogonallyConnectedGroups(e) {
    const n = new Set(e),
      s = new Ut();
    for (const o of e) s.addPoint(o);
    for (const o of e)
      for (const r of this.geometryHelper.getOrthogonallyAdjacentCells(o))
        n.has(r) && s.addEdge(o, r);
    return s.getAllComponents();
  }
}
class J1 {
  constructor(e) {
    L(this, "spec");
    (this.cellIdHelper = e), (this.spec = e.spec);
  }
  getIdFromCornerCoords(e) {
    return e.x + e.y * (this.spec.size.width + 1);
  }
  getCoordsFromId(e) {
    return {
      x: e % (this.spec.size.width + 1),
      y: Math.floor(e / (this.spec.size.width + 1)),
    };
  }
}
function Vt(t) {
  let e = 0;
  for (const n of t) e |= 1 << n;
  return e;
}
function Ii(t) {
  let e = 0;
  for (; t > 0; ) {
    const n = t & -t;
    (t = t - n), e++;
  }
  return e;
}
class Oo {
  constructor(e = 0) {
    L(this, "mask");
    this.mask = +e;
  }
  get size() {
    return Ii(this.mask);
  }
  add(e) {
    this.mask |= 1 << e;
  }
  delete(e) {
    this.mask &= ~(1 << e);
  }
  clear() {
    this.mask = 0;
  }
  union(e) {
    return (this.mask |= e.valueOf()), this;
  }
  intersect(e) {
    return (this.mask &= e.valueOf()), this;
  }
  xor(e) {
    return (this.mask ^= e.valueOf()), this;
  }
  subtract(e) {
    return (this.mask &= ~e.valueOf()), this;
  }
  has(e) {
    return (this.mask & (1 << e)) !== 0;
  }
  equals(e) {
    return this.mask === +e;
  }
  isSubsetOf(e) {
    const n = e.valueOf();
    return (this.mask & n) === this.mask;
  }
  isSupersetOf(e) {
    const n = e.valueOf();
    return (this.mask & n) === n;
  }
  isDisjointFrom(e) {
    return (this.mask & e.valueOf()) === 0;
  }
  intersects(e) {
    return (this.mask & e.valueOf()) !== 0;
  }
  valueOf() {
    return this.mask;
  }
  *[Symbol.iterator]() {
    for (let e = 0; e < 31; e++) this.mask & (1 << e) && (yield e);
  }
  static from(e) {
    return new Oo(Vt(e));
  }
}
function* nn(t, e, n) {
  for (let s = e; s <= n; s++) t & (1 << s) && (yield s);
}
function Xn(t, e, n) {
  for (let s = e; s <= n; s++) if (t & (1 << s)) return s;
}
function br(t, e, n) {
  for (let s = n; s >= e; s--) if (t & (1 << s)) return s;
}
class Mt extends Oo {
  getSmallestDigit() {
    return Xn(this.mask, 0, 9);
  }
  getLargestDigit() {
    return br(this.mask, 0, 9);
  }
  [Symbol.iterator]() {
    return nn(this.mask, 0, 9);
  }
  static from(e) {
    return new Mt(Vt(e));
  }
}
class No {
  constructor(e) {
    L(this, "minDigit");
    L(this, "maxDigit");
    L(this, "allDigitsMask");
    (this.minDigit = e.minDigit),
      (this.maxDigit = e.maxDigit),
      (this.allDigitsMask =
        (1 << (this.maxDigit + 1)) - 1 - ((1 << this.minDigit) - 1));
  }
  createFullDigitSet() {
    return new Mt(this.allDigitsMask);
  }
  createEvensDigitSet() {
    return new Mt(this.allDigitsMask & 341);
  }
  createOddsDigitSet() {
    return new Mt(this.allDigitsMask & 682);
  }
  createModuloDigitSet(e, n) {
    const s = new Mt();
    for (let o = this.minDigit; o <= this.maxDigit; o++)
      o % e === n && s.add(o);
    return s;
  }
  createFilteredDigitSet(e) {
    const n = new Mt();
    for (let s = this.minDigit; s <= this.maxDigit; s++) e(s) && n.add(s);
    return n;
  }
}
class Q1 {
  constructor(e) {
    L(this, "spec");
    (this.cellIdHelper = e), (this.spec = e.spec);
  }
  getIdFromCoords(e) {
    return Math.floor(e.x) + (e.y - 0.5) * this.spec.size.width * 2;
  }
  getCoordsFromId(e) {
    const { width: n } = this.spec.size;
    return e % (n * 2) < n
      ? { x: e % n, y: Math.floor(e / (n * 2)) + 0.5 }
      : { x: 0.5 + (e % n), y: Math.floor(e / (n * 2)) + 1 };
  }
}
var An = ((t) => (
    (t[(t.Left = 0)] = "Left"),
    (t[(t.Right = 1)] = "Right"),
    (t[(t.Up = 2)] = "Up"),
    (t[(t.Down = 3)] = "Down"),
    t
  ))(An || {}),
  we = ((t) => (
    (t[(t.Top = 0)] = "Top"),
    (t[(t.Right = 1)] = "Right"),
    (t[(t.Bottom = 2)] = "Bottom"),
    (t[(t.Left = 3)] = "Left"),
    (t[(t.TopLeft = 4)] = "TopLeft"),
    (t[(t.TopRight = 5)] = "TopRight"),
    (t[(t.BottomRight = 6)] = "BottomRight"),
    (t[(t.BottomLeft = 7)] = "BottomLeft"),
    t
  ))(we || {}),
  _n = ((t) => (
    (t[(t.TopLeft = 0)] = "TopLeft"),
    (t[(t.TopRight = 1)] = "TopRight"),
    (t[(t.BottomRight = 2)] = "BottomRight"),
    (t[(t.BottomLeft = 3)] = "BottomLeft"),
    t
  ))(_n || {}),
  zs = ((t) => (
    (t.Row = "Row"),
    (t.Column = "Column"),
    (t.Region = "Region"),
    (t.ExtraRegion = "ExtraRegion"),
    (t.DiagonalMinus = "DiagonalMinus"),
    (t.DiagonalPlus = "DiagonalPlus"),
    t
  ))(zs || {}),
  Se = ((t) => (
    (t[(t.PositiveDiagonal = 1)] = "PositiveDiagonal"),
    (t[(t.NegativeDiagonal = -1)] = "NegativeDiagonal"),
    t
  ))(Se || {}),
  oe = ((t) => (
    (t.Background = "background"),
    (t.Default = "default"),
    (t.Foreground = "foreground"),
    (t.Grid = "grid"),
    (t.AboveDigits = "aboveDigits"),
    t
  ))(oe || {});
class mt {
  constructor(e = 0, n = 0) {
    (this.x = e), (this.y = n);
  }
  get magnitude() {
    return Math.hypot(this.x, this.y);
  }
  get magnitudeSqr() {
    return this.x * this.x + this.y * this.y;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScaled(e, n) {
    return (this.x += e.x * n), (this.y += e.y * n), this;
  }
  subtract(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  rotate(e) {
    const n = Math.cos(e),
      s = Math.sin(e),
      { x: o, y: r } = this;
    return (this.x = n * o - s * r), (this.y = s * o + n * r), this;
  }
  scale(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  normalize() {
    const e = this.magnitude;
    return (this.x /= e), (this.y /= e), this;
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  static from(e) {
    return new mt(e.x, e.y);
  }
}
function yc(t) {
  return Math.hypot(t.x, t.y);
}
function bo(t) {
  const e = 1 / yc(t);
  return { x: t.x * e, y: t.y * e };
}
function Ll(t, e) {
  return { x: t.x * e, y: t.y * e };
}
function ft(t, e) {
  return { x: t.x + e.x, y: t.y + e.y };
}
function Ze(t, e) {
  return { x: t.x - e.x, y: t.y - e.y };
}
function Qn(t, e, n) {
  return { x: t.x + e.x * n, y: t.y + e.y * n };
}
function Wr(t, e) {
  return Math.hypot(t.x - e.x, t.y - e.y);
}
function Cc(t, e) {
  return t.x * e.x + t.y * e.y;
}
function kr(t, e) {
  return Math.acos(
    Cc(new mt(t.x, t.y).normalize(), new mt(e.x, e.y).normalize())
  );
}
function xi(t, e) {
  return Math.abs(t.x - e.x) + Math.abs(t.y - e.y);
}
function en(t, e) {
  const n = Math.cos(e),
    s = Math.sin(e);
  return { x: t.x * n - t.y * s, y: t.x * s + t.y * n };
}
function wc(t, e) {
  return { x: Rt(t.x, e.x, e.x + e.width), y: Rt(t.y, e.y, e.y + e.height) };
}
function bc(t, e) {
  return t.y < e.y ? -1 : t.y > e.y ? 1 : Math.sign(t.x - e.x);
}
function hr(t, e) {
  return bc(t, e) > 0;
}
function e0(t) {
  const e = { x: 0, y: 0 };
  let n = 0;
  for (const s of t) (e.x += s.x), (e.y += s.y), n++;
  return (e.x /= n), (e.y /= n), e;
}
const Di = {
  getMagnitude: yc,
  normalized: bo,
  scaled: Ll,
  sum: ft,
  difference: Ze,
  scaledSum: Qn,
  getDistance: Wr,
  getDotProduct: Cc,
  getAngle: kr,
  getManhattanDistance: xi,
  getRotated: en,
  getClamped: wc,
  compareVectors: bc,
  isVectorGreaterThan: hr,
  getAverage: e0,
};
class kc {
  constructor(e, n, s, o) {
    L(this, "spec");
    L(this, "width");
    L(this, "height");
    (this.cellIdHelper = e),
      (this.edgeIdHelper = n),
      (this.cornerIdHelper = s),
      (this.outerCellIdHelper = o),
      (this.spec = e.spec),
      (this.width = this.spec.size.width),
      (this.height = this.spec.size.height);
  }
  *getAdjacentCells(e, n = !1) {
    yield* this.getOrthogonallyAdjacentCells(e),
      n && (yield* this.getDiagonallyAdjacentCells(e));
  }
  *getOrthogonallyAdjacentCells(e) {
    const { x: n, y: s } = this.cellIdHelper.getCoordsFromId(e);
    n > 0 && (yield this.cellIdHelper.getIdFromCoords({ x: n - 1, y: s })),
      s > 0 && (yield this.cellIdHelper.getIdFromCoords({ x: n, y: s - 1 })),
      n < this.width - 1 &&
        (yield this.cellIdHelper.getIdFromCoords({ x: n + 1, y: s })),
      s < this.height - 1 &&
        (yield this.cellIdHelper.getIdFromCoords({ x: n, y: s + 1 }));
  }
  *getDiagonallyAdjacentCells(e) {
    const { x: n, y: s } = this.cellIdHelper.getCoordsFromId(e);
    n > 0 &&
      s > 0 &&
      (yield this.cellIdHelper.getIdFromCoords({ x: n - 1, y: s - 1 })),
      n < this.width - 1 &&
        s > 0 &&
        (yield this.cellIdHelper.getIdFromCoords({ x: n + 1, y: s - 1 })),
      n > 0 &&
        s < this.height - 1 &&
        (yield this.cellIdHelper.getIdFromCoords({ x: n - 1, y: s + 1 })),
      n < this.width - 1 &&
        s < this.height - 1 &&
        (yield this.cellIdHelper.getIdFromCoords({ x: n + 1, y: s + 1 }));
  }
  *getCellsInRow(e) {
    for (let n = 0; n < this.width; n++)
      yield this.cellIdHelper.getIdFromCoords({ x: n, y: e });
  }
  *getCellsInColumn(e) {
    for (let n = 0; n < this.height; n++)
      yield this.cellIdHelper.getIdFromCoords({ x: e, y: n });
  }
  *getCellsInRowOfCell(e) {
    yield* this.getCellsInRow(this.cellIdHelper.getY(e));
  }
  *getCellsInColumnOfCell(e) {
    yield* this.getCellsInColumn(this.cellIdHelper.getX(e));
  }
  *getCellsKnightsMoveAwayFromCell(e) {
    const { x: n, y: s } = this.cellIdHelper.getCoordsFromId(e);
    n >= 1 &&
      s >= 2 &&
      (yield this.cellIdHelper.getIdFromCoords({ x: n - 1, y: s - 2 })),
      n < this.width - 1 &&
        s >= 2 &&
        (yield this.cellIdHelper.getIdFromCoords({ x: n + 1, y: s - 2 })),
      n >= 2 &&
        s >= 1 &&
        (yield this.cellIdHelper.getIdFromCoords({ x: n - 2, y: s - 1 })),
      n < this.width - 2 &&
        s >= 1 &&
        (yield this.cellIdHelper.getIdFromCoords({ x: n + 2, y: s - 1 })),
      n >= 2 &&
        s < this.height - 1 &&
        (yield this.cellIdHelper.getIdFromCoords({ x: n - 2, y: s + 1 })),
      n < this.width - 2 &&
        s < this.height - 1 &&
        (yield this.cellIdHelper.getIdFromCoords({ x: n + 2, y: s + 1 })),
      n >= 1 &&
        s < this.height - 2 &&
        (yield this.cellIdHelper.getIdFromCoords({ x: n - 1, y: s + 2 })),
      n < this.width - 1 &&
        s < this.height - 2 &&
        (yield this.cellIdHelper.getIdFromCoords({ x: n + 1, y: s + 2 }));
  }
  *getCoordsInDiagonal(e, n) {
    const s = e === Se.NegativeDiagonal ? 1 : -1;
    n === void 0 && (n = e === Se.NegativeDiagonal ? 0 : this.width - 1);
    for (let o = 0; o < this.height; o++) {
      const r = n + o * s;
      if (r < 0 || r >= this.width) break;
      yield { x: r, y: o };
    }
  }
  *getCellsInDiagonal(e, n) {
    for (const s of this.getCoordsInDiagonal(e, n))
      yield this.cellIdHelper.getIdFromCoords(s);
  }
  *getAllRows() {
    for (let e = 0; e < this.height; e++) yield [...this.getCellsInRow(e)];
  }
  *getAllColumns() {
    for (let e = 0; e < this.width; e++) yield [...this.getCellsInColumn(e)];
  }
  *getAllPairsWithOffset(e, n) {
    for (let s = 0; s < this.height; s++)
      for (let o = 0; o < this.width; o++) {
        const r = { x: o + e, y: s + n };
        r.x < 0 ||
          r.y < 0 ||
          r.x >= this.width ||
          r.y >= this.height ||
          (yield [
            this.cellIdHelper.getIdFromCoords({ x: o, y: s }),
            this.cellIdHelper.getIdFromCoords(r),
          ]);
      }
  }
  *getAllDominoes() {
    yield* this.getAllPairsWithOffset(1, 0),
      yield* this.getAllPairsWithOffset(0, 1);
  }
  *getAllDiagonallyAdjacentPairs() {
    yield* this.getAllPairsWithOffset(1, -1),
      yield* this.getAllPairsWithOffset(1, 1);
  }
  *getAllKingsMovePairs() {
    yield* this.getAllPairsWithOffset(1, 0),
      yield* this.getAllPairsWithOffset(0, 1),
      yield* this.getAllPairsWithOffset(1, -1),
      yield* this.getAllPairsWithOffset(1, 1);
  }
  *getAllKnightMovePairs() {
    yield* this.getAllPairsWithOffset(1, -2),
      yield* this.getAllPairsWithOffset(1, 2),
      yield* this.getAllPairsWithOffset(2, -1),
      yield* this.getAllPairsWithOffset(2, 1);
  }
  *getAllQuadruples() {
    for (let e = 0; e < this.height - 1; e++)
      for (let n = 0; n < this.width - 1; n++)
        yield [
          this.cellIdHelper.getIdFromCoords({ x: n, y: e }),
          this.cellIdHelper.getIdFromCoords({ x: n + 1, y: e }),
          this.cellIdHelper.getIdFromCoords({ x: n, y: e + 1 }),
          this.cellIdHelper.getIdFromCoords({ x: n + 1, y: e + 1 }),
        ];
  }
  *getCellsTouchingCorner(e) {
    const n = this.cornerIdHelper.getCoordsFromId(e),
      s = [];
    for (let o = -1; o <= 0; o++)
      for (let r = -1; r <= 0; r++) {
        const l = this.cellIdHelper.getIdFromCoordsSafe({
          x: n.x + r,
          y: n.y + o,
        });
        l !== void 0 && (yield l);
      }
    return s;
  }
  getCellsTouchingEdge(e) {
    const { x: n, y: s } = this.edgeIdHelper.getCoordsFromId(e);
    return [
      { x: Math.floor(n - 0.5), y: Math.floor(s - 0.5) },
      { x: Math.ceil(n - 0.5), y: Math.ceil(s - 0.5) },
    ].map((o) => this.cellIdHelper.getIdFromCoords(o));
  }
  *getCoordsPointedAtByOuterClue(e, n) {
    const s = this.outerCellIdHelper.getAllAttributes(e);
    let { x: o, y: r } = s;
    const { side: l } = s;
    if (n) {
      const i = t0[`${l}_${n}`];
      if (!i) return;
      for (
        o += i.x, r += i.y;
        o >= 0 && r >= 0 && o < this.width && r < this.height;

      )
        yield { x: o, y: r }, (o += i.x), (r += i.y);
    } else
      switch (l) {
        case we.Top: {
          for (let i = 0; i < this.height; i++) yield { x: o, y: i };
          return;
        }
        case we.Right:
          for (let i = this.width - 1; i >= 0; i--) yield { x: i, y: r };
          return;
        case we.Bottom:
          for (let i = this.height - 1; i >= 0; i--) yield { x: o, y: i };
          return;
        case we.Left:
          for (let i = 0; i < this.width; i++) yield { x: i, y: r };
          return;
        case we.TopLeft: {
          const i = Math.min(this.width, this.height);
          for (let a = 0; a < i; a++) yield { x: a, y: a };
          return;
        }
        case we.TopRight: {
          const i = Math.min(this.width, this.height);
          for (let a = 0; a < i; a++) yield { x: this.width - 1 - a, y: a };
          return;
        }
        case we.BottomRight: {
          const i = Math.min(this.width, this.height);
          for (let a = 0; a < i; a++) yield { x: a, y: this.height - 1 - a };
          return;
        }
        case we.BottomLeft: {
          const i = Math.min(this.width, this.height);
          for (let a = 0; a < i; a++)
            yield { x: this.width - 1 - a, y: this.height - 1 - a };
        }
      }
  }
  *getCellsPointedAtByOuterClue(e, n) {
    for (const s of this.getCoordsPointedAtByOuterClue(e, n))
      yield this.cellIdHelper.getIdFromCoords(s);
  }
  getManhattanDistanceBetweenCells(e, n) {
    const s = this.cellIdHelper.getCoordsFromId(e),
      o = this.cellIdHelper.getCoordsFromId(n);
    return xi(s, o);
  }
  getCellsAreKingsMoveApart(e, n) {
    const s = this.cellIdHelper.getCoordsFromId(e),
      o = this.cellIdHelper.getCoordsFromId(n),
      r = Math.abs(s.x - o.x),
      l = Math.abs(s.y - o.y);
    return r === 0 && l === 0 ? !1 : r <= 1 && l <= 1;
  }
}
const t0 = {
    [`${we.Top}_${Se.NegativeDiagonal}`]: { x: 1, y: 1 },
    [`${we.Top}_${Se.PositiveDiagonal}`]: { x: -1, y: 1 },
    [`${we.Bottom}_${Se.NegativeDiagonal}`]: { x: -1, y: -1 },
    [`${we.Bottom}_${Se.PositiveDiagonal}`]: { x: 1, y: -1 },
    [`${we.Left}_${Se.NegativeDiagonal}`]: { x: 1, y: 1 },
    [`${we.Left}_${Se.PositiveDiagonal}`]: { x: 1, y: -1 },
    [`${we.Right}_${Se.NegativeDiagonal}`]: { x: -1, y: -1 },
    [`${we.Right}_${Se.PositiveDiagonal}`]: { x: -1, y: 1 },
    [`${we.TopLeft}_${Se.NegativeDiagonal}`]: { x: 1, y: 1 },
    [`${we.TopLeft}_${Se.PositiveDiagonal}`]: void 0,
    [`${we.TopRight}_${Se.NegativeDiagonal}`]: void 0,
    [`${we.TopRight}_${Se.PositiveDiagonal}`]: { x: -1, y: 1 },
    [`${we.BottomLeft}_${Se.NegativeDiagonal}`]: void 0,
    [`${we.BottomLeft}_${Se.PositiveDiagonal}`]: { x: 1, y: -1 },
    [`${we.BottomRight}_${Se.NegativeDiagonal}`]: { x: -1, y: -1 },
    [`${we.BottomRight}_${Se.PositiveDiagonal}`]: void 0,
  },
  n0 = [
    "empty tuple",
    "single",
    "pair",
    "triple",
    "quadruple",
    "quintuple",
    "sextuple",
    "septuple",
    "octuple",
    "nonuple",
  ];
function $a(t) {
  return n0[t] || `${t}-tuple`;
}
function s0(t) {
  for (let e = t.length - 1; e > 0; e--)
    if (t[e] === " ") return `${t.substring(0, e)} ${t.substring(e + 1)}`;
  return t;
}
function At(t, e = "and") {
  const n = [];
  for (let s = 0; s < t.length; s++)
    n.push(String(t[s])),
      s < t.length - 2 ? n.push(", ") : s < t.length - 1 && n.push(` ${e} `);
  return n.join("");
}
function _c(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
function Sa(t) {
  const e = ["B", "KB", "MB", "GB", "TB", "PB"];
  let n = 0;
  for (; t >= 1e3 && n < e.length - 1; ) (t /= 1e3), n++;
  return `${t.toFixed(1)}${e[n]}`;
}
class o0 {
  constructor(e, n, s, o) {
    L(this, "spec");
    L(this, "names", []);
    (this.edgeIdHelper = e),
      (this.outerCellIdHelper = n),
      (this.geometryHelper = s),
      (this.digitsHelper = o),
      (this.spec = e.spec);
    for (let r = 0; r < this.spec.size.height; r++)
      for (let l = 0; l < this.spec.size.width; l++)
        this.names.push(`R${r + 1}C${l + 1}`);
  }
  getCellName(e) {
    return this.names[e];
  }
  getColumnName(e) {
    return `C${e + 1}`;
  }
  getRowName(e) {
    return `R${e + 1}`;
  }
  getDigitFilterDescription(e) {
    return (
      (e = this.digitsHelper.createFullDigitSet().intersect(e)),
      this.digitsHelper.createOddsDigitSet().equals(e)
        ? "an odd digit"
        : this.digitsHelper.createEvensDigitSet().equals(e)
        ? "an even digit"
        : Ii(+e) === 1
        ? `a ${Xn(+e, this.spec.minDigit, this.spec.maxDigit).toString()}`
        : `a ${this.getDigitSetDescription(e, "or")}`
    );
  }
  getDigitSetDescription(e, n = "and") {
    return (
      (e = this.digitsHelper.createFullDigitSet().intersect(e)), At([...e], n)
    );
  }
  getCellsDescription(e) {
    const n = [...e].sort((s, o) => s - o);
    return n.length === 0 ? "???" : At(n.map((s) => this.getCellName(s)));
  }
  getLineName(e, n) {
    return `the ${e} from ${this.getCellName(n[0])} to ${this.getCellName(
      n.at(-1)
    )}`;
  }
  getBranchingLineName(e, n) {
    return `the ${e} containing ${this.getCellName(Math.min(...n))}`;
  }
  getEdgeClueName(e, n) {
    return this.getEdgeClueNameFromDomino(
      e,
      this.geometryHelper.getCellsTouchingEdge(n)
    );
  }
  getEdgeClueNameFromDomino(e, n) {
    return `the ${e} between ${this.getCellsDescription(n)}`;
  }
  getCageName(e, n) {
    return `the ${e} at ${this.getCellName(Math.min(...n))}`;
  }
  getTupleName(e) {
    return $a(e.length);
  }
  getTupleNameBySize(e) {
    return $a(e);
  }
  getOuterClueName(e, n) {
    const s = this.outerCellIdHelper.getAllAttributes(n);
    switch (s.side) {
      case we.TopLeft:
        return `the top-left ${e}`;
      case we.TopRight:
        return `the top-right ${e}`;
      case we.Top:
        return `the top ${e} in ${this.getColumnName(s.x)}`;
      case we.BottomLeft:
        return `the bottom-left ${e}`;
      case we.BottomRight:
        return `the bottom-right ${e}`;
      case we.Bottom:
        return `the bottom ${e} in ${this.getColumnName(s.x)}`;
      case we.Right:
        return `the right ${e} in ${this.getRowName(s.y)}`;
      case we.Left:
        return `the left ${e} in ${this.getRowName(s.y)}`;
    }
  }
}
class r0 {
  constructor(e) {
    L(this, "width");
    L(this, "height");
    (this.width = e.size.width), (this.height = e.size.height);
  }
  getX(e) {
    return (e % (this.width + 2)) - 1;
  }
  getY(e) {
    return Math.floor(e / (this.width + 2)) - 1;
  }
  getIdFromCoords(e) {
    return e.x + 1 + (e.y + 1) * (this.width + 2);
  }
  getCoordsFromId(e) {
    return new mt(this.getX(e), this.getY(e));
  }
  getCellCenterFromId(e) {
    return new mt(this.getX(e) + 0.5, this.getY(e) + 0.5);
  }
  getSide(e) {
    return this.getSideFromCoords(this.getCoordsFromId(e));
  }
  getAllAttributes(e) {
    const n = this.getCoordsFromId(e);
    return { x: n.x, y: n.y, side: this.getSideFromCoords(n) };
  }
  getSideFromCoords(e) {
    return e.y < 0
      ? e.x < 0
        ? we.TopLeft
        : e.x >= this.width
        ? we.TopRight
        : we.Top
      : e.y >= this.height
      ? e.x < 0
        ? we.BottomLeft
        : e.x >= this.width
        ? we.BottomRight
        : we.Bottom
      : e.x >= this.width
      ? we.Right
      : we.Left;
  }
}
function Zr(t, e, n = !1) {
  const s = n ? new WeakMap() : new Map();
  return function (...o) {
    const r = e(...o);
    let l;
    return s.has(r) ? (l = s.get(r)) : ((l = t(...o)), s.set(r, l)), l;
  };
}
class l0 {
  constructor(e) {
    L(this, "minDigit");
    L(this, "maxDigit");
    (this.minDigit = e.minDigit),
      (this.maxDigit = e.maxDigit),
      (this.getCombinationsForSumWithoutRepeat = Zr(
        this.getCombinationsForSumWithoutRepeat.bind(this),
        (n, s) => `${n}_${s}`
      ));
  }
  getExtremeSumsWithRepeat(e, n) {
    let s = 0,
      o = 0;
    for (let r = 0; r < e.length; r++) {
      const l = e[r],
        i = (n == null ? void 0 : n[r]) ?? 1,
        a = Xn(l, this.minDigit, this.maxDigit),
        u = br(l, this.minDigit, this.maxDigit);
      (s += (a ?? 0) * i), (o += (u ?? 0) * i);
    }
    return { minSum: s, maxSum: o };
  }
  getExtremeSumsWithoutRepeat(e, n) {
    const s = this.getMinimumSumWithoutRepeat(e, n);
    if (s === null) return null;
    const o = this.getMaximumSumWithoutRepeat(e, n);
    return { minSum: s, maxSum: o };
  }
  getMinimumSumWithoutRepeat(e, n) {
    const s = (o, r) => {
      let l = 1 / 0,
        i = !0;
      for (let a = 0; a < o.length; a++) {
        const [u, p] = o[a];
        i = !1;
        const m = Xn(u & ~r, this.minDigit, this.maxDigit);
        if (m === void 0) return null;
        const g = o.slice();
        g.splice(a, 1);
        const v = s(g, r | (1 << m));
        v !== null && v + m * p < l && (l = v + m * p);
      }
      return i ? 0 : l === 1 / 0 ? null : l;
    };
    return s(
      e.map((o, r) => [o, (n == null ? void 0 : n[r]) ?? 1]),
      0
    );
  }
  getMaximumSumWithoutRepeat(e, n) {
    const s = (o, r) => {
      let l = -1 / 0,
        i = !0;
      for (let a = 0; a < o.length; a++) {
        const [u, p] = o[a];
        i = !1;
        const m = br(u & ~r, this.minDigit, this.maxDigit);
        if (m === void 0) return null;
        const g = o.slice();
        g.splice(a, 1);
        const v = s(g, r | (1 << m));
        v !== null && v + m * p > l && (l = v + m * p);
      }
      return i ? 0 : l === -1 / 0 ? null : l;
    };
    return s(
      e.map((o, r) => [o, (n == null ? void 0 : n[r]) ?? 1]),
      0
    );
  }
  getCombinationsForSumWithoutRepeat(e, n) {
    if (n === 0) return [];
    const s = [],
      o = gc(Ve(this.minDigit, this.maxDigit), n);
    for (const r of o) r.reduce((i, a) => i + a, 0) === e && s.push(r);
    return s;
  }
  getCombinationsForSumsWithoutRepeat(e, n) {
    if (n === 0) return [];
    const s = [];
    for (const o of e) s.push(...this.getCombinationsForSumWithoutRepeat(o, n));
    return s;
  }
}
var Or, $c;
class i0 {
  constructor(e) {
    va(this, Or);
    L(this, "maxDigit");
    (this.sumHelper = e), (this.maxDigit = e.maxDigit);
  }
  *getXSumPossibilities(e) {
    if (e === 1) {
      yield { x: 1, combinations: [2] };
      return;
    } else if (e === 2 || e === 4 || e > Cs(this.maxDigit)) return;
    for (let n = 2; n <= this.maxDigit; n++)
      if (e >= Cs(n) && e <= ya(this, Or, $c).call(this, n)) {
        const s = [];
        for (const o of this.sumHelper.getCombinationsForSumWithoutRepeat(
          e - n,
          n - 1
        ))
          o.includes(n) || s.push(Vt(o));
        s.length > 0 && (yield { x: n, combinations: s });
      }
  }
}
(Or = new WeakSet()),
  ($c = function (e) {
    return e + this.maxDigit * (e - 1) - Cs(e - 2);
  });
function Fn(t) {
  const e = new jr(t),
    n = new J1(e),
    s = new Q1(e),
    o = new r0(t),
    r = new l0(t),
    l = new kc(e, s, n, o),
    i = new i0(r),
    a = new No(t),
    u = new o0(s, o, l, a),
    p = new Y1(l);
  return {
    cellIds: e,
    cornerIds: n,
    edgeIds: s,
    outerCellIds: o,
    geometry: l,
    sums: r,
    xSums: i,
    digits: a,
    naming: u,
    connectivity: p,
  };
}
let a0 = 0;
function fe() {
  return a0++;
}
function Ce(t, e) {
  return mo(t, e);
}
function mo(t, e, n = [], s = []) {
  if (t === e) return !0;
  if (typeof t != "object" || typeof e != "object" || t === null || e === null)
    return !1;
  if (t instanceof Map && e instanceof Map) return u0(t, e);
  if (t instanceof Set && e instanceof Set)
    return He.isEqual(t, e, { comparator: mo });
  const o = Array.isArray(t),
    r = Array.isArray(e);
  if (o !== r || (o && r && t.length !== e.length)) return !1;
  if (o && r) {
    for (let a = 0; a < t.length; a++)
      if (!mo(t[a], e[a], void 0, void 0)) return !1;
    return !0;
  }
  for (const l in t)
    if (!(l in e) || !mo(t[l], e[l], void 0, void 0)) return !1;
  for (const l in e) if (!(l in t)) return !1;
  return !0;
}
function u0(t, e) {
  if (t.size !== e.size) return !1;
  for (const [n, s] of t) if (!mo(e.get(n), s)) return !1;
  return !0;
}
class ln {
  constructor(e) {
    L(this, "id", fe());
    L(this, "creationTimestamp", Date.now());
    L(this, "name", "");
    L(this, "author", "");
    L(this, "comment", "");
    L(this, "spec");
    L(this, "cells");
    L(this, "allConstraints", []);
    L(this, "messages", { completion: "" });
    L(this, "exportSettings", ue(Co));
    L(this, "helpers");
    (this.spec = e),
      (this.cells = Array.from(
        { length: e.size.width * e.size.height },
        (n, s) => new rs(s, s % e.size.width, Math.floor(s / e.size.width))
      )),
      (this.helpers = Fn(e));
  }
  updateSpec(e) {
    Object.assign(this.spec, e), (this.helpers = Fn(this.spec));
  }
  isSolved() {
    return this.cells.every((e) => e.value !== void 0);
  }
  isPotentiallySolved() {
    return this.cells.some((e) => e.value !== void 0 && !e.given);
  }
  toPuzzleData() {
    return {
      spec: this.spec,
      cells: this.cells,
      constraints: this.allConstraints,
      name: this.name,
      author: this.author,
      comment: this.comment,
      messages: this.messages,
      exportSettings: this.exportSettings,
    };
  }
  toPlayablePuzzleData() {
    return {
      ...this.toPuzzleData(),
      cells: this.cells.map((e) => ({
        given: e.given,
        value: e.given && e.value ? e.value : void 0,
        candidates: 0,
        cornerPencilMarks: 0,
        colors: 0,
      })),
      constraints: this.getEnabledConstraints(),
    };
  }
  toPuzzlePreviewData() {
    return this.toPlayablePuzzleData();
  }
  getEnabledConstraints() {
    return this.allConstraints.filter((e) => e.enabled);
  }
  getConstraintsForSolver() {
    return this.allConstraints.filter((e) => e.enabled && !e.solverIgnored);
  }
  supportsSolving() {
    return (
      this.getConstraintsForSolver().filter(
        (e) => !je.getIsIgnoredBySolver(e.config.type)
      ).length > 0
    );
  }
  updateFromData(e) {
    j1(this.cells, e);
  }
  equals(e) {
    if (
      !Ce(e.spec, this.spec) ||
      e.name !== this.name ||
      e.author !== this.author ||
      e.comment !== this.comment ||
      this.allConstraints.length !== e.allConstraints.length ||
      !Ce(e.cells, this.cells) ||
      !Ce(e.messages, this.messages)
    )
      return !1;
    for (let n = 0; n < this.allConstraints.length; n++) {
      const s = ue(this.allConstraints[n]);
      if (((s.id = e.allConstraints[n].id), !Ce(s, e.allConstraints[n])))
        return !1;
    }
    return !0;
  }
  static createDefault(e, n = "", s = "") {
    const o = new ln(e);
    return (o.name = n), (o.author = s), o;
  }
}
const El = "puzzle";
class To {
  load(e, n) {
    return {
      id: fe(),
      name: e.name,
      enabled: !e.disabled,
      solverIgnored: !!e.solverIgnored,
      config: this.transformJson(e, n),
    };
  }
  save(e) {
    const n = this.transformConfig(e.config);
    return {
      name: e.name || void 0,
      disabled: e.enabled ? void 0 : !0,
      solverIgnored: e.solverIgnored || void 0,
      ...n,
    };
  }
}
class uo extends Array {
  constructor(...e) {
    super(...e);
  }
  indexOf(e) {
    return this.findIndex((n) => Ce(e, n));
  }
  includes(e) {
    return !!this.find((n) => Ce(e, n));
  }
}
class Ia extends To {
  constructor() {
    super(...arguments);
    L(this, "types", [_.CosmeticSymbol]);
  }
  transformJson(n) {
    return {
      type: _.CosmeticSymbol,
      symbols: n.symbols.map(([s, o, r, l]) => ({
        layer: l || this.getDefaultLayer({ x: s, y: o }),
        position: { x: s, y: o },
        params: n.params[r || 0],
      })),
    };
  }
  transformConfig(n) {
    const s = new uo(),
      o = [];
    for (const r of n.symbols) {
      s.includes(r.params) || s.push(r.params);
      const l = s.indexOf(r.params),
        i = Number(r.position.x.toFixed(10)),
        a = Number(r.position.y.toFixed(10)),
        u = [i, a, l, r.layer];
      (u[3] === void 0 || u[3] === this.getDefaultLayer({ x: i, y: a })) &&
        (u.pop(), u[2] === 0 && u.pop()),
        o.push(u);
    }
    return { type: _.CosmeticSymbol, params: s, symbols: o };
  }
  getDefaultLayer({ x: n, y: s }) {
    const o = xt(n, 1),
      r = xt(s, 1);
    return o < 0.25 || o > 0.75 || r < 0.25 || r > 0.75
      ? oe.Foreground
      : oe.Default;
  }
}
const c0 = Object.freeze(
  Object.defineProperty(
    { __proto__: null, CosmeticSymbolsTransformer: Ia, default: Ia },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
function ds(t) {
  if (Array.isArray(t)) return t.length === 0 ? void 0 : t;
  if (!(typeof t == "object" && Object.values(t).every((e) => e === void 0)))
    return t || void 0;
}
class xa extends To {
  constructor() {
    super(...arguments);
    L(this, "types", [_.FogLights]);
  }
  transformJson(n) {
    return { type: _.FogLights, lightCells: n.cells || [] };
  }
  transformConfig(n) {
    return { type: _.FogLights, cells: ds(n.lightCells) };
  }
}
const d0 = Object.freeze(
  Object.defineProperty(
    { __proto__: null, FogLightsTransformer: xa, default: xa },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
class Da extends To {
  constructor() {
    super(...arguments);
    L(this, "types", [_.FogTriggers]);
  }
  transformJson(n) {
    var s;
    return {
      type: _.FogTriggers,
      patterns: n.patterns || [],
      triggers: n.triggers || [],
      effects: n.effects || [],
      overrides: n.overrides || [],
      editor: {
        defaultDisabling:
          ((s = n.editor) == null ? void 0 : s.defaultDisabling) ?? !1,
      },
    };
  }
  transformConfig(n) {
    return {
      type: _.FogTriggers,
      patterns: ds(n.patterns),
      triggers: ds(n.triggers),
      effects: ds(n.effects),
      overrides: ds(n.overrides),
      editor: ds({ defaultDisabling: ds(n.editor.defaultDisabling) }),
    };
  }
}
const p0 = Object.freeze(
  Object.defineProperty(
    { __proto__: null, FogTriggersTransformer: Da, default: Da },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
class Ma extends To {
  constructor() {
    super(...arguments);
    L(this, "types", [
      _.LittleKillers,
      _.SandwichSums,
      _.XSums,
      _.Skyscrapers,
      _.NumberedRooms,
    ]);
  }
  transformJson(n) {
    const s = ue(n);
    return (s.clues = s.clues.filter((o) => o.value !== void 0)), s;
  }
  transformConfig(n) {
    return n;
  }
}
const f0 = Object.freeze(
    Object.defineProperty(
      { __proto__: null, OuterCluesTransformer: Ma, default: Ma },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  h0 = Object.assign({
    "./CosmeticSymbols.transformer.ts": c0,
    "./FogLights.transformer.ts": d0,
    "./FogTriggers.transformer.ts": p0,
    "./OuterClues.transformer.ts": f0,
  }),
  m0 = Object.values(h0).map((t) => t.default);
var pe = ((t) => (
    (t.Rectangle = "rectangle"),
    (t.Ellipse = "ellipse"),
    (t.Text = "text"),
    (t.Arrow = "arrow"),
    t
  ))(pe || {}),
  Be = ((t) => (
    (t[(t.Self = 0)] = "Self"),
    (t[(t.OrthogonalNeighbors = 1)] = "OrthogonalNeighbors"),
    (t[(t.DiagonalNeighbors = 2)] = "DiagonalNeighbors"),
    (t[(t.KnightsMoves = 3)] = "KnightsMoves"),
    (t[(t.Row = 4)] = "Row"),
    (t[(t.Column = 5)] = "Column"),
    t
  ))(Be || {});
const g0 = [_.Difference, _.Ratio, _.XV],
  v0 = [_.Minimum, _.Maximum];
_.CosmeticSymbol, _.CosmeticLine, _.CosmeticCage;
function ms(t) {
  return Math.round(t * 255)
    .toString(16)
    .padStart(2, "0");
}
function Us(t) {
  const e = ms(t.red),
    n = ms(t.green),
    s = ms(t.blue);
  return `#${e}${n}${s}`;
}
function Hs(t) {
  const e = ms(t.red),
    n = ms(t.green),
    s = ms(t.blue),
    o = ms(t.alpha);
  return `#${e}${n}${s}${o}`;
}
function Fl(t) {
  let e = t.match(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})/i);
  if (!e) {
    if (((e = t.match(/^#([0-9a-f])([0-9a-f])([0-9a-f])/i)), !e)) return;
    e = ["", e[1] + e[1], e[2] + e[2], e[3] + e[3]];
  }
  return {
    red: Number.parseInt(e[1], 16) / 255,
    green: Number.parseInt(e[2], 16) / 255,
    blue: Number.parseInt(e[3], 16) / 255,
  };
}
function Gt(t) {
  const e = t.match(
    /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i
  );
  if (e)
    return {
      red: Number.parseInt(e[1], 16) / 255,
      green: Number.parseInt(e[2], 16) / 255,
      blue: Number.parseInt(e[3], 16) / 255,
      alpha: Number.parseInt(e[4] || "ff", 16) / 255,
    };
}
function y0({ red: t, green: e, blue: n }) {
  const s = Math.max(t, e, n),
    o = Math.min(t, e, n),
    r = s - o;
  let l;
  r === 0
    ? (l = 0)
    : s === t
    ? (l = xt((e - n) / r, 6) / 6)
    : s === e
    ? (l = ((n - t) / r + 2) / 6)
    : (l = ((t - e) / r + 4) / 6);
  const i = (s + o) / 2,
    a = r === 0 ? 0 : r / (1 - Math.abs(2 * i - 1));
  return { hue: l, lightness: i, saturation: a };
}
function Cl(t) {
  return { ...y0(t), alpha: t.alpha };
}
function Gr({ hue: t, saturation: e, lightness: n }) {
  const s = (1 - Math.abs(2 * n - 1)) * e,
    o = s * (1 - Math.abs(((t * 6) % 2) - 1));
  let r;
  t < 1 / 6
    ? (r = [s, o, 0])
    : t < 2 / 6
    ? (r = [o, s, 0])
    : t < 3 / 6
    ? (r = [0, s, o])
    : t < 4 / 6
    ? (r = [0, o, s])
    : t < 5 / 6
    ? (r = [o, 0, s])
    : (r = [s, 0, o]);
  const l = n - s / 2;
  return { red: r[0] + l, green: r[1] + l, blue: r[2] + l };
}
function C0(t) {
  return { ...Gr(t), alpha: t.alpha };
}
function mr(t, e) {
  const n = Gt(t),
    s = Gt(e);
  return Ce(n, s);
}
function Aa({ red: t, green: e, blue: n }) {
  return 0.2126 * t + 0.7152 * e + 0.0722 * n;
}
function w0(t, e) {
  const n = Aa(t),
    s = Aa(e);
  return n === 0 && s === 0 ? 1 : Math.min(n, s) / Math.max(n, s);
}
function Mi(t, e) {
  if (e.length === 0) return t[0];
  const n = { red: 0, green: 0, blue: 0 },
    s = t.map((o) => {
      const r = Fl(o) || n;
      return { color: o, ratio: Math.max(...e.map((l) => w0(r, Fl(l) || n))) };
    });
  return s.sort((o, r) => o.ratio - r.ratio), s[0].color;
}
function Wn(t) {
  const e = Gt(t);
  return e ? e.alpha <= 5 / 255 : !1;
}
function Ws(t) {
  const e = Gt(t);
  return e && e.alpha < 0.2 ? Hs({ ...e, alpha: 0.2 }) : t;
}
const Sc = "#aaaaaa",
  Ai = "#bbbbbb",
  _r = "#cccccc",
  so = "#00000033",
  b0 = "#34bbe6ff",
  Ic = "#f067f0",
  xc = "#67f067",
  k0 = "#ffa600",
  _0 = "#2ecbff",
  Dc = "#ffccaa",
  $0 = "#33bbaa",
  S0 = "#ff6666";
function Pi(t, e) {
  return e
    .filter((n) => t.includes(n.config.type))
    .map((n) => n.config.style.color);
}
function I0(t) {
  return Mi([Ic, "#aa00ff", "#d900f1"], Pi([_.Renban], t));
}
function Mc(t) {
  return Mi([Sc, _r, Ai], Pi([_.Palindrome, _.Sequence, _.Thermometer], t));
}
function Pa(t) {
  return Mi([_r, Ai, Sc], Pi([_.Palindrome, _.Sequence, _.Thermometer], t));
}
const x0 = {
  4: { width: 2, height: 2 },
  6: { width: 3, height: 2 },
  8: { width: 4, height: 2 },
  9: { width: 3, height: 3 },
};
function Ac({ width: t, height: e }) {
  return t === e && [4, 6, 8, 9].includes(t);
}
function D0(t) {
  const e = [];
  for (let n = 0; n < t.length; n++)
    t[n] !== -1 && (e[t[n]] || (e[t[n]] = []), e[t[n]].push(n));
  for (let n = 0; n < e.length; n++) e[n] || (e[n] = []);
  return e;
}
function Pc(t) {
  const { width: e, height: n } = t.size;
  if (t.digitCount === e && t.digitCount === n) {
    const o = Lc({ width: e, height: n });
    if (o) return o;
  }
  const s = M0(t);
  return (
    s ||
    (e === n && e <= 9
      ? Array.from({ length: e * n }, (o, r) => Math.floor(r / e))
      : Array.from({ length: e * n }, () => -1))
  );
}
function Lc(t) {
  if (Ac(t)) return Bl(t, x0[t.width]);
}
function M0(t) {
  if (
    !(
      (t.size.width * t.size.height) % t.digitCount !== 0 ||
      (t.size.width * t.size.height) / t.digitCount > 9
    )
  )
    for (let e = Math.ceil(Math.sqrt(t.digitCount)); e <= t.digitCount; e++) {
      if (t.digitCount % e !== 0) continue;
      const n = t.digitCount / e;
      if (t.size.width % e === 0 && t.size.height % n === 0)
        return Bl(t.size, { width: e, height: n });
      if (t.size.width % n === 0 && t.size.height % e === 0)
        return Bl(t.size, { width: n, height: e });
    }
}
function Bl(t, e) {
  const { width: n, height: s } = t,
    { width: o, height: r } = e;
  return Array.from({ length: n * s }, (l, i) => {
    const a = i % n,
      u = Math.floor(i / n),
      p = Math.floor(a / o),
      m = Math.floor(u / r);
    return p + m * (n / o);
  });
}
function Ec({ type: t, spec: e, otherConstraints: n = [] }) {
  const s = (o) => {
    for (const r of n)
      if (r.config.type === _.Custom && r.config.definition.name === o) {
        let l = o.replace(/\d+$/, (i) => String(Number(i) + 1));
        return l.match(/\d+$/) || (l += " 2"), s(l);
      }
    return o;
  };
  switch (t) {
    case _.Antiking:
    case _.Antiknight:
    case _.DisjointGroups:
    case _.Givens:
    case _.Nonconsecutive:
      return { type: t };
    case _.Arrow:
      return {
        type: t,
        bulbsWithArrows: [],
        style: {
          bulb: {
            size: 0.8,
            fill: "#ffffff",
            stroke: { thickness: 0.02, color: "#aaaaaa" },
          },
          arrow: { thickness: 0.05, color: "#aaaaaa", headSize: 0.35 },
        },
      };
    case _.DoubleArrow:
      return {
        type: t,
        lines: [],
        style: {
          lines: { thickness: 0.05, color: "#aaaaaa" },
          endPoints: {
            size: 0.8,
            fill: "#ffffff",
            stroke: { thickness: 0.02, color: "#aaaaaa" },
          },
        },
      };
    case _.BetweenLines:
      return {
        type: t,
        lines: [],
        style: {
          lines: { thickness: 0.1, color: "#aaaaaa" },
          endPoints: {
            size: 0.8,
            fill: "#ffffff80",
            stroke: { thickness: 0.02, color: "#aaaaaa" },
          },
        },
      };
    case _.ColumnIndexer:
      return { type: t, cells: [], style: { color: "#f9000055" } };
    case _.RowIndexer:
      return { type: t, cells: [], style: { color: "#0080f955" } };
    case _.Clone:
      return { type: t, groups: [], style: { color: so } };
    case _.Custom:
      return {
        type: t,
        definition: {
          name: s("New constraint"),
          input: [],
          backend: { type: "code", code: "" },
          components: [],
        },
        input: {},
        style: {},
      };
    case _.DiagonalPlus:
    case _.DiagonalMinus:
      return { type: t, style: { color: b0, thickness: 0.02 } };
    case _.Difference:
      return { type: t, clues: [], negative: [], overrideNegativeRatios: !0 };
    case _.EntropyLines:
      return {
        type: t,
        lines: [],
        groups: [],
        style: { color: Dc, thickness: 0.15 },
      };
    case _.Even:
      return { type: t, cells: [], style: { color: so, size: 0.8 } };
    case _.DifferentValues:
      return { type: t, cells: [], style: { color: so, offset: 0.1 } };
    case _.GlobalEntropy:
      return { type: t, groups: [] };
    case _.KillerCages:
      return {
        type: t,
        cages: [],
        style: { text: { color: "#000000" }, cage: { color: "#000000" } },
      };
    case _.LittleKillers:
      return {
        type: t,
        clues: [],
        style: { text: { color: "#000000" }, arrow: { color: "#000000" } },
      };
    case _.LockoutLines:
      return {
        type: t,
        lines: [],
        style: {
          lines: { color: "#aabeefff", thickness: 0.1 },
          endPoints: {
            size: 0.8,
            stroke: { color: "#0000ff80", thickness: 0.05 },
            fill: "#e7e6ff80",
          },
        },
      };
    case _.LookAndSayCages:
      return {
        type: t,
        cages: [],
        style: { cage: { color: "#000000" }, text: { color: "#000000" } },
      };
    case _.Maximum:
    case _.Minimum:
      return { type: t, cells: [], style: { color: so } };
    case _.NumberedRooms:
      return { type: t, clues: [], style: { color: "#000000" } };
    case _.Odd:
      return { type: t, cells: [], style: { color: so, size: 0.8 } };
    case _.Palindrome:
      return { type: t, lines: [], style: { color: Ai, thickness: 0.15 } };
    case _.Quadruple:
      return { type: t, clues: [], style: { singleLine: !1 } };
    case _.Ratio:
      return {
        type: t,
        clues: [],
        negative: [],
        overrideNegativeDifferences: !0,
      };
    case _.Renban:
      return { type: t, lines: [], style: { color: Ic, thickness: 0.15 } };
    case _.RegionSumLine:
      return {
        type: t,
        lines: [],
        singleRegionTotals: !1,
        style: { color: _0, thickness: 0.15 },
      };
    case _.Regions: {
      const o = Pc(e);
      return { type: t, regions: o || [] };
    }
    case _.SandwichSums:
      return { type: t, clues: [], style: { color: "#000000ff" } };
    case _.Sequence:
      return { type: t, lines: [], style: { color: _r, thickness: 0.15 } };
    case _.Skyscrapers:
      return { type: t, clues: [], style: { color: "#000000ff" } };
    case _.Thermometer:
      return {
        type: t,
        slow: !1,
        thermometers: [],
        style: { color: _r, thickness: 0.3, bulbRadius: 0.4 },
      };
    case _.Whisper:
      return {
        type: t,
        lines: [],
        minDifference: 5,
        style: { color: xc, thickness: 0.15 },
      };
    case _.XSums:
      return { type: t, clues: [], style: { color: "#000000" } };
    case _.XV:
      return { type: t, clues: [], negative: [] };
    case _.CosmeticLine:
      return { type: t, lines: [], style: { thickness: 0.15, color: S0 } };
    case _.CosmeticCage:
      return {
        type: t,
        cages: [],
        style: { text: { color: "#000000" }, cage: { color: "#000000" } },
      };
    case _.CosmeticSymbol:
      return { type: t, symbols: [] };
    case _.SudokuRules:
      return { type: t };
    case _.FogLights:
      return { type: t, lightCells: [] };
    case _.FogTriggers: {
      const o = n.some((r) => r.config.type === _.FogTriggers && r.enabled);
      return {
        type: t,
        patterns: o ? [] : [Be.Self],
        triggers: [],
        effects: [],
        overrides: [],
        editor: { defaultDisabling: !1 },
      };
    }
  }
}
function ks({ id: t = fe(), type: e, spec: n, otherConstraints: s = [] }) {
  return {
    id: t,
    name: void 0,
    enabled: !0,
    solverIgnored: !1,
    config: Ec({ type: e, spec: n, otherConstraints: s }),
  };
}
class A0 extends To {
  constructor() {
    super(...arguments);
    L(this, "types");
  }
  transformJson(n, s) {
    const o = ks({ spec: s.spec, type: n.type });
    for (const r in n)
      r === "name" ||
        r === "disabled" ||
        (r in o.config && (o.config[r] = n[r]));
    return o.config;
  }
  transformConfig(n) {
    return n;
  }
}
class Fc {
  constructor() {
    L(this, "transformers", new Map());
    L(this, "defaultTransformer", new A0());
    for (const e of m0) this.register(new e());
  }
  read(e, n) {
    return this.transformers.has(e.type)
      ? this.transformers.get(e.type).load(e, n)
      : this.defaultTransformer.load(e, n);
  }
  write(e) {
    return this.transformers.has(e.config.type)
      ? this.transformers.get(e.config.type).save(e)
      : this.defaultTransformer.save(e);
  }
  register(e) {
    for (const n of e.types) this.transformers.set(n, e);
  }
}
var Ie = ((t) => ((t.Sudoku = "sudoku"), (t.Custom = "custom"), t))(Ie || {});
const gr = String.fromCharCode,
  Bc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\",
  zc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
class Li {
  compressToBase64(e) {
    const n = this.compress(e, 6, (s) => Bc.charAt(s));
    switch (n.length % 4) {
      default:
      case 0:
        return n;
      case 1:
        return `${n}===`;
      case 2:
        return `${n}==`;
      case 3:
        return `${n}=`;
    }
  }
  compressToUint8Array(e) {
    const n = this.compress(e, 16, (o) => gr(o)),
      s = new Uint8Array(n.length * 2);
    for (let o = 0, r = n.length; o < r; o++) {
      const l = n.charCodeAt(o);
      (s[o * 2] = l >> 8), (s[o * 2 + 1] = l & 255);
    }
    return s;
  }
  compressToEncodedURIComponent(e) {
    return this.compress(e, 6, (n) => zc.charAt(n));
  }
  compress(e, n, s) {
    const o = {},
      r = {};
    let l = "",
      i = 2,
      a = 3,
      u = 2;
    const p = [];
    let m = 0,
      g = 0;
    const v = (M) => {
        (m = (m << 1) | M), g++, g === n && ((g = 0), p.push(m), (m = 0));
      },
      $ = (M, P) => {
        for (let x = 0; x < P; x++) v(M & 1), (M >>= 1);
      },
      k = () => {
        if (l in r) {
          if (l.charCodeAt(0) < 256) {
            for (let M = 0; M < u; M++) v(0);
            $(l.charCodeAt(0), 8);
          } else {
            let M = 1;
            for (let P = 0; P < u; P++) v(M), (M = 0);
            $(l.charCodeAt(0), 16);
          }
          i--, i === 0 && ((i = 1 << u), u++), delete r[l];
        } else $(o[l], u);
        i--, i === 0 && ((i = 1 << u), u++);
      };
    for (let M = 0; M < e.length; M++) {
      const P = e.charAt(M);
      P in o || ((o[P] = a++), (r[P] = !0));
      const x = l + P;
      if (x in o) {
        l = x;
        continue;
      }
      k(), (o[x] = a++), (l = P);
    }
    for (l !== "" && k(), $(2, u); ; )
      if (((m = m << 1), g === n - 1)) {
        p.push(m);
        break;
      } else g++;
    return p.map(s).join("");
  }
}
class P0 {
  constructor() {
    L(this, "baseReverseDic", {});
  }
  decompressFromBase64(e) {
    return this.decompress(e.length, 32, (n) =>
      this.getBaseValue(Bc, e.charAt(n))
    );
  }
  decompressFromUint8Array(e) {
    const n = Array.from(
        { length: e.length / 2 },
        (r, l) => e[l * 2] * 256 + e[l * 2 + 1]
      ),
      s = [];
    n.forEach((r) => s.push(gr(r)));
    const o = s.join("");
    return this.decompress(o.length, 32768, (r) => o.charCodeAt(r));
  }
  decompressFromEncodedURIComponent(e) {
    return (
      (e = e.replace(/ /g, "+")),
      this.decompress(e.length, 32, (n) => this.getBaseValue(zc, e.charAt(n)))
    );
  }
  decompress(e, n, s) {
    const o = [];
    let r = 4,
      l = 4,
      i = 3,
      a = "";
    const u = [];
    let p,
      m = "";
    const g = {
      value: s(0),
      position: n,
      index: 1,
      readBits($) {
        let k = 0;
        for (let M = 0; M < $; M++)
          (k |= g.value & g.position ? 1 << M : 0),
            (g.position >>= 1),
            g.position === 0 && ((g.position = n), (g.value = s(g.index++)));
        return k;
      },
    };
    for (let $ = 0; $ < 3; $++) o[$] = $;
    const v = g.readBits(2);
    switch (v) {
      case 0:
      case 1:
        m = gr(g.readBits(8 + 8 * v));
        break;
      case 2:
        return "";
    }
    for (o[3] = m, p = m, u.push(m); ; ) {
      if (g.index > e) return "";
      let $ = g.readBits(i);
      switch ($) {
        case 0:
        case 1:
          (o[l++] = gr(g.readBits(8 + 8 * $))), ($ = l - 1), r--;
          break;
        case 2:
          return u.join("");
      }
      if ((r === 0 && ((r = 1 << i), i++), o[$])) a = o[$];
      else if ($ === l) a = p + p.charAt(0);
      else return null;
      u.push(a),
        (o[l++] = p + a.charAt(0)),
        r--,
        (p = a),
        r === 0 && ((r = 1 << i), i++);
    }
  }
  getBaseValue(e, n) {
    if (!this.baseReverseDic[e]) {
      this.baseReverseDic[e] = {};
      for (let s = 0; s < e.length; s++)
        this.baseReverseDic[e][e.charAt(s)] = s;
    }
    return this.baseReverseDic[e][n];
  }
}
function wl(t, e = (n, s) => s !== void 0) {
  const n = {};
  for (const [s, o] of Object.entries(t)) e(s, o) && (n[s] = o);
  if (Object.keys(n).length !== 0) return n;
}
const Ei = "1.5.0",
  Rc = "1";
class zl {
  constructor(e) {
    L(this, "data");
    e instanceof ln
      ? (this.data = {
          spec: e.spec,
          cells: e.cells,
          constraints: e.allConstraints,
          name: e.name,
          author: e.author,
          comment: e.comment,
          messages: e.messages,
          exportSettings: e.exportSettings,
        })
      : (this.data = e);
  }
  saveToJson() {
    const e = this.data,
      n = new Fc(),
      s = {
        formatVersion: Ei,
        puzzle: {
          name: e.name,
          author: e.author,
          comment: e.comment || void 0,
          messages: this.getCompressedMessages(),
          ...this.getCompressedSpec(),
          cells: e.cells.map((o) => {
            const r = {};
            return (
              o.value !== void 0
                ? (o.given && (r.given = o.given), (r.value = o.value))
                : (o.candidates && (r.candidates = o.candidates),
                  o.cornerPencilMarks &&
                    (r.cornerPencilMarks = o.cornerPencilMarks)),
              o.colors && (r.colors = o.colors),
              r
            );
          }),
          constraints: e.constraints.map((o) => n.write(o)),
          export: e.exportSettings
            ? wl({
                sudokuPad: wl({
                  showDigits: e.exportSettings.sudokuPad.showDigits || void 0,
                  showColorMarks:
                    e.exportSettings.sudokuPad.showColorMarks || void 0,
                  useIncompleteGridAsSolution:
                    e.exportSettings.sudokuPad.useIncompleteGridAsSolution ||
                    void 0,
                  solution: Ce(
                    e.exportSettings.sudokuPad.solution,
                    Co.sudokuPad.solution
                  )
                    ? void 0
                    : e.exportSettings.sudokuPad.solution,
                }),
              })
            : void 0,
        },
      };
    return JSON.stringify(s);
  }
  saveToUrl() {
    const n = new Li().compressToEncodedURIComponent(this.saveToJson()),
      s = new URL("/", location.toString());
    return s.searchParams.set(El, n), s.toString();
  }
  saveToFile() {
    return new Blob([this.saveToJson()], { type: "application/json" });
  }
  getCompressedSpec() {
    const e = this.data.spec;
    switch (e.type) {
      case Ie.Sudoku:
        return e.size.width === 9
          ? {}
          : {
              type: Ie.Sudoku,
              size: e.size.width === 9 ? void 0 : e.size.width,
            };
      case Ie.Custom:
        return {
          type: Ie.Custom,
          width: e.size.width === 9 ? void 0 : e.size.width,
          height: e.size.height === 9 ? void 0 : e.size.height,
          minDigit: e.minDigit === 1 ? void 0 : e.minDigit,
          maxDigit: e.maxDigit === 9 ? void 0 : e.maxDigit,
        };
    }
  }
  getCompressedMessages() {
    const e = this.data.messages;
    return e && wl(e, (n, s) => s);
  }
}
function Oc(t, e) {
  if (t.digitCount !== t.size.width || t.digitCount !== t.size.height)
    return !1;
  const n = Lc(t.size);
  return n ? n.every((s, o) => s === e[o]) : !1;
}
function L0(t, e) {
  let n;
  return (...s) => {
    window.clearTimeout(n), (n = window.setTimeout(() => t(...s), e));
  };
}
class E0 {
  constructor() {
    L(this, "sudokuIsModified", !1);
    L(this, "unwatchSudoku");
    L(this, "onBeforeUnload", (e) => {
      this.sudokuIsModified &&
        (e.preventDefault(),
        (e.returnValue = "Are you sure you want to quit?"));
    });
    window.addEventListener("beforeunload", this.onBeforeUnload, {
      capture: !0,
    }),
      (this.updateUrl = L0(this.updateUrl.bind(this), 200));
  }
  dispose() {
    window.removeEventListener("beforeunload", this.onBeforeUnload, {
      capture: !0,
    });
  }
  setSudoku(e) {
    var s;
    (this.sudokuIsModified = !1),
      (s = this.unwatchSudoku) == null || s.call(this),
      this.onChange(e);
    const n = rn({ sudoku: e, busy: rt });
    this.unwatchSudoku = ae(
      n,
      () => {
        (this.sudokuIsModified = !0), rt.value || this.onChange(e);
      },
      { deep: !0 }
    );
  }
  onChange(e) {
    const n = new zl(e).saveToUrl();
    this.updateUrl(n),
      this.updateTitle(e),
      this.shouldRegisterSudoku(e) && En.register(n, e.creationTimestamp);
  }
  updateUrl(e) {
    window.history.replaceState("", "", e);
  }
  updateTitle(e) {
    document.title = `${e.name || wr} – Sudoku Maker`;
  }
  shouldRegisterSudoku(e) {
    if (!e.cells.every((n) => n.isEmpty())) return !0;
    for (const n of e.allConstraints)
      if (n.config.type === _.Regions) {
        if (!Oc(e.spec, n.config.regions)) return !0;
      } else if (n.config.type !== _.Givens) return !0;
    return !1;
  }
}
function F0(t) {
  const e = { ctrl: !1, meta: !1, shift: !1, alt: !1, key: "", useCode: !1 };
  for (const n of t)
    switch (n) {
      case "Control":
        e.ctrl = !0;
        break;
      case "Meta":
        e.meta = !0;
        break;
      case "Shift":
        e.shift = !0;
        break;
      case "Alt":
        e.alt = !0;
        break;
      default: {
        const s = n.match(/^:(\w+)$/);
        s ? ((e.key = s[1]), (e.useCode = !0)) : (e.key = n);
      }
    }
  return e;
}
function B0(t) {
  const e = [];
  return (
    t.ctrl && e.push("Control"),
    t.meta && e.push("Meta"),
    t.shift && e.push("Shift"),
    t.alt && e.push("Alt"),
    t.useCode ? e.push(`:${t.key}`) : e.push(t.key),
    e
  );
}
const ko = [
  "undo",
  "redo",
  "selectAll",
  "delete",
  "setEnterDigits",
  "setEnterCornerPencilMarks",
  "setEnterCandidates",
  "setEnterColorMarks",
  "newConstraint",
  "openNextConstraint",
  "openPreviousConstraint",
  "removeConstraint",
  "exitConstraintEditor",
  "clearGrid",
  "doSingleLogicalStep",
  "doAllLogicalSteps",
  "findSolutions",
  "checkValidity",
  "stopSolver",
  "toggleFog",
];
class z0 {
  constructor() {
    L(
      this,
      "hotkeys",
      rn({
        undo: [],
        redo: [],
        selectAll: [],
        delete: [],
        setEnterCandidates: [],
        setEnterColorMarks: [],
        setEnterCornerPencilMarks: [],
        setEnterDigits: [],
        newConstraint: [],
        openNextConstraint: [],
        openPreviousConstraint: [],
        removeConstraint: [],
        exitConstraintEditor: [],
        clearGrid: [],
        doSingleLogicalStep: [],
        doAllLogicalSteps: [],
        findSolutions: [],
        checkValidity: [],
        stopSolver: [],
        toggleFog: [],
      })
    );
    L(this, "allowedDeleteModifiers", { ctrl: !1, shift: !1 });
  }
  update(e) {
    for (const n of ko) this.hotkeys[n] = this.parseHotkeys(e[n]);
  }
  getHotkeys(e) {
    return this.hotkeys[e] || [];
  }
  getActions(e) {
    if (e.repeat) return [];
    const n = [];
    for (const s of ko) {
      if (s === "delete") {
        this.matchesDeleteEvent(e) && n.push(s);
        continue;
      }
      for (const o of this.hotkeys[s])
        o.ctrl === e.ctrlKey &&
          o.meta === e.metaKey &&
          o.alt === e.altKey &&
          o.shift === e.shiftKey &&
          (o.useCode ? o.key === e.code : o.key === e.key) &&
          n.push(s);
    }
    return n;
  }
  parseHotkeys(e) {
    return e ? e.map((n) => F0(n)) : [];
  }
  allowModifiersForDelete({ shift: e = !1, ctrl: n = !1 }) {
    (this.allowedDeleteModifiers.ctrl = n),
      (this.allowedDeleteModifiers.shift = e);
  }
  disallowModifiersForDelete() {
    (this.allowedDeleteModifiers.ctrl = !1),
      (this.allowedDeleteModifiers.shift = !1);
  }
  matchesDeleteEvent(e) {
    const n = e.ctrlKey && this.allowedDeleteModifiers.ctrl,
      s = e.shiftKey && this.allowedDeleteModifiers.shift;
    for (const o of this.hotkeys.delete)
      if (
        (n || o.ctrl === e.ctrlKey) &&
        (s || o.shift === e.shiftKey) &&
        o.meta === e.metaKey &&
        o.alt === e.altKey &&
        (o.useCode ? o.key === e.code : o.key === e.key)
      )
        return !0;
    return !1;
  }
}
const R0 = {
    [_.Arrow]: {
      add: "Add arrow",
      update: "Update arrow(s)",
      delete: "Delete arrow(s)",
    },
    [_.BetweenLines]: {
      add: "Add between line",
      update: "Update between line(s)",
      delete: "Delete between line(s)",
    },
    [_.Custom]: {
      add: (t) => `Update ${t.definition.name}`,
      update: (t) => `Update ${t.definition.name}`,
      delete: (t) => `Update ${t.definition.name}`,
    },
    [_.Clone]: {
      add: "Add clone",
      update: "Update clone(s)",
      delete: "Delete clone(s)",
    },
    [_.ColumnIndexer]: {
      add: "Add column indexer(s)",
      update: "Update column indexer(s)",
      delete: "Delete column indexer(s)",
    },
    [_.Difference]: {
      add: "Add difference Kropki dot",
      update: "Update difference Kropki dot(s)",
      delete: "Delete difference Kropki dot(s)",
      "update:overrideNegativeRatios":
        "Update negative ratio override for difference Kropki dots",
    },
    [_.Even]: {
      add: "Add ‘even’ square(s)",
      delete: "Delete ‘even’ square(s)",
    },
    [_.EntropyLines]: {
      add: "Add entropy line",
      update: "Update entropy line(s)",
      delete: "Delete entropy line(s)",
    },
    [_.KillerCages]: {
      add: "Add killer cage",
      update: "Update killer cage(s)",
      delete: "Delete killer cage(s)",
    },
    [_.LittleKillers]: {
      add: "Add little killer",
      update: "Update little killer(s)",
      delete: "Delete little killer(s)",
    },
    [_.LookAndSayCages]: {
      add: "Add look-and-say cage",
      update: "Update look-and-say cage(s)",
      delete: "Delete look-and-say cage(s)",
    },
    [_.Minimum]: {
      add: "Add minimum cell(s)",
      update: "Update minimum cell(s)",
      delete: "Delete minimum cell(s)",
    },
    [_.Maximum]: {
      add: "Add maximum cell(s)",
      update: "Update maximum cell(s)",
      delete: "Delete maximum cell(s)",
    },
    [_.NumberedRooms]: {
      add: "Add numbered room",
      update: "Update numbered room(s)",
      delete: "Delete numbered room(s)",
    },
    [_.Odd]: { add: "Add ‘odd’ circle(s)", delete: "Delete ‘odd’ circle(s)" },
    [_.Palindrome]: {
      add: "Add palindrome",
      update: "Update palindrome(s)",
      delete: "Delete palindrome(s)",
    },
    [_.Quadruple]: {
      add: "Add quadruple",
      update: "Update quadruple(s)",
      delete: "Delete quadruple(s)",
    },
    [_.Ratio]: {
      add: "Add ratio Kropki dot",
      update: "Update ratio Kropki dot(s)",
      delete: "Delete ratio Kropki dot(s)",
      updateNegativeValues: "Update negative ratios",
      toggleNegative: "Toggle negative ratio constraint",
    },
    [_.Regions]: { update: "Update region(s)" },
    [_.Renban]: {
      add: "Add Renban line",
      update: "Update Renban line(s)",
      delete: "Delete Renban line(s)",
    },
    [_.RegionSumLine]: {
      add: "Add region sum line",
      update: "Update region sum line(s)",
      delete: "Delete region sum line(s)",
    },
    [_.RowIndexer]: {
      add: "Add row indexer(s)",
      update: "Update row indexer(s)",
      delete: "Delete row indexer(s)",
    },
    [_.SandwichSums]: {
      add: "Add sandwich sum",
      update: "Update sandwich sum(s)",
      delete: "Delete sandwich sum(s)",
    },
    [_.Sequence]: {
      add: "Add sequence line",
      update: "Update sequence line(s)",
      delete: "Delete sequence line(s)",
    },
    [_.Skyscrapers]: {
      add: "Add skyscraper",
      update: "Update skyscraper(s)",
      delete: "Delete skyscraper(s)",
    },
    [_.Thermometer]: {
      add: "Add thermometer",
      update: "Update thermometer(s)",
      delete: "Delete thermometer(s)",
    },
    [_.Whisper]: {
      add: "Add whisper",
      update: "Update whisper(s)",
      delete: "Delete whisper(s)",
      "update:minDifference": "Update whisper value",
    },
    [_.XV]: {
      add: "Add X/V dot",
      update: "Update X/V dot(s)",
      delete: "Delete X/V dot(s)",
      toggleNegative: "Toggle negative XV constraint",
    },
    [_.XSums]: {
      add: "Add X-sum",
      update: "Update X-sum(s)",
      delete: "Delete X-sum(s)",
    },
  },
  O0 = {
    add: "Update constraint",
    update: "Update constraint",
    delete: "Update constraint",
    "update:color": "Update color",
    "update:thickness": "Update line thickness",
    "update:bulbRadius": "Update bulb radius",
  };
function N0(t, e) {
  var s;
  const n = ((s = R0[t.type]) == null ? void 0 : s[e]) || O0[e] || e;
  return typeof n == "function" ? n(t) : n;
}
const La = 1e3;
var qr = ((t) => (
  (t[(t.Normal = 0)] = "Normal"),
  (t[(t.Amend = 1)] = "Amend"),
  (t[(t.Overwrite = 2)] = "Overwrite"),
  t
))(qr || {});
class T0 {
  constructor() {
    L(this, "current");
    L(this, "start");
    L(this, "depth", 0);
    L(this, "entriesForRewrites", new Map());
    this.start = this.current = { name: "start", timestamp: Date.now() };
  }
  reset() {
    (this.depth = 0),
      (this.start = this.current = { name: "start", timestamp: Date.now() });
  }
  canUndo() {
    return this.current !== this.start;
  }
  canRedo() {
    return !!this.current.redo;
  }
  getUndoText() {
    return this.current.name;
  }
  getRedoText() {
    var e;
    return (e = this.current.redo) == null ? void 0 : e.to.name;
  }
  executeAndRecord(e, n, s, o) {
    return this.record(e, e, n, s, o);
  }
  record(e, n, s, o, r) {
    if (e() === !1) return !1;
    if ((r == null ? void 0 : r.id) !== void 0) {
      const a =
        this.current.id === r.id
          ? this.current
          : this.entriesForRewrites.get(r.id);
      if (a && a.undo && a.timestamp > Date.now() - (r.lookbackAmount || 2e3))
        switch (r.type) {
          case 1: {
            this.current.timestamp = Date.now();
            const u = a.undo.to.redo.action;
            a.undo.to.redo.action = () => {
              u(), n();
            };
            const p = a.undo.action;
            return (
              (a.undo.action = () => {
                s(), p();
              }),
              !0
            );
          }
          case 2:
            return (
              (a.timestamp = Date.now()),
              (a.undo.to.redo.action = n),
              (a.onReentry = r.onReentry),
              !0
            );
        }
    }
    const i = {
      id: r == null ? void 0 : r.id,
      name: o,
      undo: { action: s, to: this.current },
      onReentry: r == null ? void 0 : r.onReentry,
      timestamp: Date.now(),
      preUndoHook: r == null ? void 0 : r.preUndoHook,
    };
    if (
      (r != null &&
        r.id &&
        r != null &&
        r.allowRewrite &&
        this.entriesForRewrites.set(r == null ? void 0 : r.id, i),
      delete this.current.id,
      (this.current.redo = { action: n, to: i }),
      (this.current = i),
      this.depth++,
      this.depth > La)
    ) {
      this.depth = La;
      const a = this.start.redo.to;
      (a.name = "start"), (a.undo = void 0), (this.start = a);
    }
    return !0;
  }
  async undo() {
    if (!this.current.undo) return;
    const e = this.current.name;
    if (this.current.preUndoHook && !(await this.current.preUndoHook())) return;
    const { action: n, to: s } = this.current.undo;
    n(),
      (this.current = s),
      this.depth--,
      console.info("Undo:", e),
      this.current.onReentry && this.current.onReentry();
  }
  redo() {
    if (!this.current.redo) return;
    const { action: e, to: n } = this.current.redo;
    e(),
      (this.current = n),
      this.depth++,
      console.info("Redo:", this.current.name);
  }
}
function V0(t, e) {
  for (let n = 0; n < t.length; n++) {
    const s = t[n],
      o = e[n];
    if (
      o.given !== s.given ||
      o.value !== s.value ||
      o.candidates !== s.candidates ||
      o.cornerPencilMarks !== s.cornerPencilMarks ||
      o.colors !== s.colors
    )
      return !0;
  }
  return !1;
}
function Ea(t) {
  return g0.includes(t.type);
}
function Fa(t) {
  return v0.includes(t.type);
}
var Nc = ((t) => (
  (t[(t.Cells = 0)] = "Cells"),
  (t[(t.Constraints = 1)] = "Constraints"),
  (t[(t.Constraint = 2)] = "Constraint"),
  (t[(t.Visuals = 3)] = "Visuals"),
  t
))(Nc || {});
function j0(t) {
  const e = new Set(),
    n = (p) => {
      e.add(p);
    },
    s = (p) => {
      e.delete(p);
    },
    o = (p) => {
      const m = [],
        g = [],
        v = [];
      for (const $ of e) {
        const { action: k, redo: M, undo: P } = $(p);
        k && m.push(k), M ? g.push(M) : k && g.push(k), P && v.push(P);
      }
      return {
        action() {
          m.forEach(($) => $());
        },
        redo() {
          g.forEach(($) => $());
        },
        undo() {
          v.forEach(($) => $());
        },
      };
    },
    r = (p, m, g) => {
      let v, $;
      const k = o(0);
      return jt.record(
        () => {
          var M;
          return (
            (v = t.value.cells.map((P) => P.clone())),
            p(t.value),
            V0(v, t.value.cells)
              ? (($ = t.value.cells.map((P) => P.clone())),
                (M = k.action) == null || M.call(k),
                !0)
              : !1
          );
        },
        () => {
          var M;
          for (let P = 0; P < t.value.cells.length; P++)
            t.value.cells[P] = $[P].clone();
          (M = k.redo) == null || M.call(k);
        },
        () => {
          var M;
          for (let P = 0; P < t.value.cells.length; P++)
            t.value.cells[P] = v[P].clone();
          (M = k.undo) == null || M.call(k);
        },
        m,
        g
      );
    },
    l = (p, m = fe()) => {
      const g = t.value.allConstraints.slice(),
        v = t.value.allConstraints.some((A) => A.config.type === _.Givens);
      p(t.value);
      const $ = t.value.allConstraints.slice(),
        k = t.value.allConstraints.some((A) => A.config.type === _.Givens),
        M = v && !k,
        P = t.value.cells.filter((A) => A.given).map((A) => A.id),
        x = o(1);
      jt.record(
        () => {
          var A;
          (t.value.allConstraints = $.slice()),
            M &&
              t.value.cells.forEach((O) => {
                O.given = !1;
              }),
            (A = x.action) == null || A.call(x);
        },
        () => {
          var A;
          (t.value.allConstraints = $.slice()),
            M &&
              t.value.cells.forEach((O) => {
                O.given = !1;
              }),
            (A = x.redo) == null || A.call(x);
        },
        () => {
          var A;
          if (((t.value.allConstraints = g.slice()), M))
            for (const O of P) t.value.cells[O].given = !0;
          (A = x.undo) == null || A.call(x);
        },
        "Update constraints",
        { id: m }
      );
    },
    i = (p, m, g, v, $) => {
      const k = ue(p);
      m(p);
      const M = ue(p);
      if (Ce(k, M)) return;
      const P = new Map([[p.id, k]]),
        x = new Map([[p.id, M]]);
      if (Ea(p.config)) {
        const V = mn(M.config.clues, k.config.clues, {
          comparator: (I, U) => I.edge === U.edge,
        });
        for (const I of t.value.getEnabledConstraints())
          I.id !== p.id &&
            Ea(I.config) &&
            (P.set(I.id, ue(I)),
            _t(I.config.clues, V, { comparator: (U, D) => U.edge === D.edge }),
            x.set(I.id, ue(I)));
      } else if (Fa(p.config)) {
        const V = mn(M.config.cells, k.config.cells);
        for (const I of t.value.getEnabledConstraints())
          I.id !== p.id &&
            Fa(I.config) &&
            (P.set(I.id, ue(I)), _t(I.config.cells, V), x.set(I.id, ue(I)));
      }
      const O = o(v ? 3 : 2);
      jt.record(
        () => {
          var V;
          return (V = O.action) == null ? void 0 : V.call(O);
        },
        () => {
          var V;
          for (const [I, U] of x)
            Object.assign(
              t.value.allConstraints.find((D) => D.id === I),
              ue(U)
            );
          (V = O.redo) == null || V.call(O);
        },
        () => {
          var V;
          for (const [I, U] of P)
            Object.assign(
              t.value.allConstraints.find((D) => D.id === I),
              ue(U)
            );
          (V = O.undo) == null || V.call(O);
        },
        g,
        { type: qr.Overwrite, ...$ }
      );
    };
  return {
    updateSudokuCells: r,
    updateConstraints: l,
    updateConstraint: (p, m, g, v) => {
      const $ = N0(p.config, g);
      return i(p, m, $, !1, v);
    },
    updateConstraintAppearance: (p, m, g, v) => i(p, m, g, !0, v),
    addUndoRedoChildFactory: n,
    removeUndoRedoChildFactory: s,
  };
}
var Ls = ((t) => (
  (t[(t.SetValue = 0)] = "SetValue"),
  (t[(t.FilterCandidatesAtCell = 1)] = "FilterCandidatesAtCell"),
  (t[(t.FilterCandidatesAtCells = 2)] = "FilterCandidatesAtCells"),
  (t[(t.RemoveCandidatesFromCell = 3)] = "RemoveCandidatesFromCell"),
  (t[(t.RemoveCandidatesFromCells = 4)] = "RemoveCandidatesFromCells"),
  (t[(t.Stop = 5)] = "Stop"),
  (t[(t.ReplaceComponent = 6)] = "ReplaceComponent"),
  t
))(Ls || {});
function U0(t, e) {
  return { type: 0, value: t, cell: e };
}
function Rl(t, e) {
  return { type: 1, value: 1 << t, cell: e };
}
function it(t, e) {
  return { type: 1, value: t, cell: e };
}
function qt(t, e) {
  return { type: 2, value: t, cells: [...e] };
}
function Ts(t, e) {
  return { type: 3, value: 1 << t, cell: e };
}
function Fi(t, e) {
  return { type: 4, value: 1 << t, cells: [...e] };
}
function Kr(t, e) {
  return { type: 3, value: t, cell: e };
}
function _o(t, e) {
  return { type: 4, value: t, cells: [...e] };
}
function gt(t, e = []) {
  return { type: 5, cells: e, message: t };
}
function On(t, e) {
  return { type: 6, component: t, with: Et(e) };
}
function vn(t) {
  return On(t, []);
}
function bl(t) {
  switch (t) {
    case zs.Column:
      return "columns";
    case zs.Row:
      return "rows";
    case zs.Region:
      return "regions";
    case zs.ExtraRegion:
      return "extra regions";
    default:
      return "<unknown>";
  }
}
function oo(t) {
  return t.includes("line") ? `on ${t}` : `in ${t}`;
}
function H0(t) {
  const { minDigit: e, maxDigit: n } = t.spec;
  function s(r) {
    return `[${[...nn(r, e, n)].join(",")}]`;
  }
  function o(r) {
    return r.length === 1 ? s(r[0]) : `either ${At(r.map(s), "or")}`;
  }
  return {
    NakedSingle: (r) => `Naked single at ${t.getCellName(r[0].cell)}`,
    HiddenSingle: (r, l) => `Hidden single ${oo(l)}`,
    NakedSet: (r, l, i) =>
      `Naked ${t.getTupleName(i)} ${oo(l)}: ${t.getCellsDescription(i)}`,
    HiddenSet: (r, l, i) =>
      `Hidden ${t.getTupleName(i)} ${oo(l)}: ${t.getCellsDescription(i)}`,
    PointingSet: (r, l, i) =>
      `Pointing ${t.getTupleName(i)} ${oo(l)}: ${t.getCellsDescription(i)}`,
    Fishes: (r, l, i) => {
      const a = Xn(r[0].value, e, n);
      return `${
        ["X-Wing", "Swordfish", "Jellyfish"][i.length - 2]
      } on ${a}s in ${bl(l)} ${At(i)}`;
    },
    ByContradiction: (r, l, i, a) => `Placing ${l} in ${t.getCellName(i)} ${a}`,
    FinnedXWing: (r, l, i) =>
      `Finned X-wing on ${Xn(r[0].value, e, n)}s in ${bl(l)} ${At(i)}`,
    YWing: (r, l, i) =>
      `Y-Wing hinged at ${t.getCellName(l)} on ${t.getCellsDescription(i)}`,
    UnorthodoxNakedSet: (r, l) =>
      `Unorthodox naked ${t.getTupleName(l)} ${t.getCellsDescription(l)}`,
    PointingRequiredDigits: (r, l) => {
      const i = r.reduce((u, p) => u | p.value, 0),
        a = t.getDigitSetDescription(i);
      return `${_c(l)} must contain a ${a}`;
    },
    UpdateCombinations: (r, l, i, a, u) => {
      const p = o(u),
        m = t.getDigitSetDescription(a);
      return `All cells ${oo(
        i
      )} with ${m} as a candidate are contained within ${l}, so it must contain ${m} and therefore is ${p}`;
    },
    Consecutive: (r, l) => {
      const i = t.getDigitSetDescription(r[0].value);
      return `${l} cannot make a consecutive set with ${i}.`;
    },
    UnorthodoxFishes: (r, l, i, a) =>
      `The ${Xn(r[0].value, e, n)}s in ${l} must be placed in ${bl(i)} ${At(
        a
      )}`,
  };
}
const W0 = "🧠",
  Z0 = {
    NakedSingle: "✨",
    HiddenSingle: "👻",
    NakedSet: "✨",
    HiddenSet: "👻",
    PointingSet: "👉",
    PointingRequiredDigits: "⚡",
    Fishes: "🐟",
    ByContradiction: "💥",
    FinnedXWing: "🐬",
    YWing: "📐",
    UnorthodoxNakedSet: "🦄",
  };
class G0 {
  constructor(e) {
    L(this, "texts");
    L(this, "helper");
    (this.helper = e), (this.texts = H0(this.helper));
  }
  translate(e) {
    return [this.getLogicStepText(e), ...this.getLogicStepDetails(e)].join(
      "; "
    );
  }
  getLogicStepIcon(e) {
    return Z0[e.description.type] || W0;
  }
  getLogicStepText(e) {
    if (e.description.type in this.texts) {
      const n = this.texts[e.description.type];
      return n(e.changes, ...e.description.parameters);
    } else return `Nameless logic step (${e.description.type})`;
  }
  getLogicStepDetails(e) {
    const n = [];
    for (let s = 0; s < e.changes.length; s++) {
      const o = e.changes[s],
        r = e.affected[s];
      if (r.length === 0) continue;
      const l = this.stringifyChange(o, r);
      n.push(l);
    }
    return n;
  }
  stringifyChange(e, n) {
    const s = this.helper.getCellsDescription(n);
    switch (e.type) {
      case Ls.FilterCandidatesAtCell:
      case Ls.FilterCandidatesAtCells:
        return `removed all candidates other than ${this.helper.getDigitSetDescription(
          e.value
        )} from ${s}`;
      case Ls.RemoveCandidatesFromCell:
      case Ls.RemoveCandidatesFromCells:
        return ` removed ${this.helper.getDigitSetDescription(
          e.value
        )} from ${s}`;
      case Ls.SetValue:
        return `set ${s} to ${e.value}`;
      default:
        return "";
    }
  }
}
const q0 = new Intl.NumberFormat(),
  K0 = new Intl.NumberFormat(void 0, {
    maximumFractionDigits: 1,
    minimumFractionDigits: 1,
  }),
  X0 = S({
    props: {
      viewBox: { type: String, required: !0 },
      inline: { type: Boolean, default: !1 },
    },
  }),
  B = (t, e) => {
    const n = t.__vccOpts || t;
    for (const [s, o] of e) n[s] = o;
    return n;
  },
  Y0 = ["viewBox"];
function J0(t, e, n, s, o, r) {
  return (
    d(),
    C(
      "svg",
      {
        class: Ae(["Icon", { inline: t.inline }]),
        viewBox: t.viewBox,
        xmlns: "http://www.w3.org/2000/svg",
        "fill-rule": "evenodd",
      },
      [G(t.$slots, "default", {}, void 0, !0)],
      10,
      Y0
    )
  );
}
const he = B(X0, [
    ["render", J0],
    ["__scopeId", "data-v-534830e1"],
  ]),
  Tc = S({
    __name: "InfoIcon",
    setup(t) {
      return (e, n) => (
        d(),
        w(
          he,
          { class: "InfoIcon", viewBox: "0 0 14 14" },
          {
            default: f(
              () =>
                n[0] ||
                (n[0] = [
                  h(
                    "path",
                    { d: "M7-.01A7 7 0 1 1 7 14 7 7 0 0 1 7-.01Z" },
                    null,
                    -1
                  ),
                  h(
                    "path",
                    {
                      d: "m9.04 11.23a2.53 2.53 0 0 1-.82.2c-.29 0-.49-.05-.6-.15-.12-.1-.18-.27-.18-.53a5.76 5.76 0 0 1 .17-1l.56-1.94a5.71 5.71 0 0 0 .14-1.04c0-.42-.15-.75-.43-1-.3-.26-.7-.4-1.24-.4-.3 0-.6.06-.94.17-.33.1-.68.23-1.04.37l-.15.6.39-.12c.15-.04.3-.07.44-.07.3 0 .49.05.6.15.1.1.15.27.15.52 0 .14-.02.3-.05.46l-.13.54-.55 1.96a5.7 5.7 0 0 0-.14 1.03c0 .4.15.73.44 1 .3.26.72.39 1.26.39.34 0 .65-.05.91-.14.27-.09.62-.22 1.06-.4l.15-.6Zm.26-7.97c0-.34-.13-.63-.39-.87a1.31 1.31 0 0 0-.93-.36c-.36 0-.67.12-.93.36s-.4.53-.4.87c0 .34.14.63.4.87s.57.36.93.36c.36 0 .67-.12.93-.36s.39-.53.39-.87Z",
                      fill: "var(--mainBgColor)",
                    },
                    null,
                    -1
                  ),
                ])
            ),
            _: 1,
          }
        )
      );
    },
  }),
  Q0 = S({
    __name: "BlueInfoIcon",
    setup(t) {
      return (e, n) => (d(), w(Tc, { class: "BlueInfoIcon" }));
    },
  }),
  _s = B(Q0, [["__scopeId", "data-v-a44a65b0"]]),
  Vc = S({
    __name: "ErrorIcon",
    setup(t) {
      return (e, n) => (
        d(),
        w(
          he,
          { class: "ErrorIcon", viewBox: "0 0 14 14" },
          {
            default: f(
              () =>
                n[0] ||
                (n[0] = [
                  h(
                    "path",
                    { d: "M7 0a7 7 0 1 1 0 14A7 7 0 0 1 7 0Z" },
                    null,
                    -1
                  ),
                  h(
                    "path",
                    {
                      d: "M7 9.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm1.72-6.02a1.74 1.74 0 1 0-3.44 0l.58 4.06c.08.55.55.96 1.1.96h.07c.56 0 1.03-.4 1.1-.96l.59-4.06Z",
                      fill: "var(--mainBgColor)",
                    },
                    null,
                    -1
                  ),
                ])
            ),
            _: 1,
          }
        )
      );
    },
  }),
  eh = S({
    __name: "RedErrorIcon",
    setup(t) {
      return (e, n) => (d(), w(Vc, { class: "RedErrorIcon" }));
    },
  }),
  Vo = B(eh, [["__scopeId", "data-v-4429d9c5"]]);
class th {
  constructor(e) {
    L(this, "translator");
    L(this, "lines", []);
    this.translator = new G0(e.helpers.naming);
  }
  clear() {
    this.lines = [];
  }
  set(e) {
    this.lines = e.slice();
  }
  log(e, n = !1) {
    n ? (this.lines[this.lines.length - 1] = fr(e)) : this.lines.push(fr(e));
  }
  logCueResults(e) {
    for (const n of e) this.logCueResult(n);
  }
  logCueResult(e) {
    if (!e) {
      this.logText("No logical steps found.");
      return;
    }
    this.log({
      text: s0(this.translator.translate(e)),
      type: "cue",
      cueResult: e,
      icon: this.translator.getLogicStepIcon(e),
    });
  }
  logText(e) {
    this.log({ text: e, type: "text" });
  }
  logInfo(e) {
    this.log({ type: "text", icon: _s, text: e });
  }
  logError(e) {
    this.log({
      type: "text",
      icon: Vo,
      text: typeof e == "string" ? e : e.message,
    });
  }
  logSolved(e) {
    this.log({ text: "✨ Solved", duration: e, type: "solved" });
  }
  logCount(e, n) {
    const s = `Found ${q0.format(e)} solution${e !== 1 ? "s" : ""}.`,
      o = this.lines.length > 0 && this.lines.at(-1).type === "count";
    this.log({ text: s, type: "count", duration: n }, o);
  }
  logReset() {
    if (!(this.lines.length === 0 || this.lines.at(-1).outOfDate))
      for (let e = 0; e < this.lines.length; e++)
        this.lines[e] = fr({ ...this.lines[e], outOfDate: !0 });
  }
}
function jo() {
  return $o({ type: Ie.Sudoku, size: 9 });
}
function $o(t) {
  switch (t.type) {
    case Ie.Sudoku:
      return {
        type: Ie.Sudoku,
        size: { width: t.size, height: t.size },
        minDigit: 1,
        maxDigit: t.size,
        get digitCount() {
          return this.size.width;
        },
      };
    case Ie.Custom:
      return {
        type: Ie.Custom,
        size: t.size,
        minDigit: t.minDigit,
        maxDigit: t.maxDigit,
        get digitCount() {
          return this.maxDigit - this.minDigit + 1;
        },
      };
  }
}
var ie = ((t) => (
  (t.CellDigit = "digit"),
  (t.CellCornerPencilMark = "cornerPencilMark"),
  (t.CellCandidate = "candidate"),
  (t.CellColor = "color"),
  (t.Constraint = "constraint"),
  t
))(ie || {});
function jc(t) {
  return {
    project: t,
    logs: new th(t),
    editMode: { type: "digit" },
    lastCellEditMode: "digit",
    colorMarkingsPage: 0,
    editorStates: new Map(),
    debuggingComponents: !1,
  };
}
function nh() {
  const t = jc(new ln(jo())),
    e = j(t),
    n = b(() => e.value.project),
    s = b(() => e.value.logs),
    o = b(() => e.value.editMode),
    r = b({
      get() {
        return e.value.colorMarkingsPage;
      },
      set(k) {
        e.value.colorMarkingsPage = k;
      },
    }),
    l = b(() => {
      var M;
      if (((M = e.value.editMode) == null ? void 0 : M.type) !== "constraint")
        return;
      const k = e.value.editMode.constraint;
      return n.value.allConstraints.find((P) => P.id === k);
    }),
    i = b(() => {
      var k;
      return (k = s.value.lines.at(-1)) == null ? void 0 : k.cueResult;
    }),
    a = b(() => Fn(e.value.project.spec)),
    u = b({
      get() {
        return e.value.debuggingComponents;
      },
      set(k) {
        e.value.debuggingComponents = k;
      },
    }),
    p = (k) => {
      (e.value.editMode = { type: k }), (e.value.lastCellEditMode = k);
    },
    m = (k) => {
      e.value.editMode = { type: "constraint", constraint: k.id };
    },
    g = () => p(e.value.lastCellEditMode),
    v = b(() => n.value.supportsSolving()),
    $ = j0(n);
  return () => ({
    state: e,
    project: n,
    helpers: a,
    debuggingComponents: u,
    solverLogs: s,
    editMode: o,
    colorMarkingsPage: r,
    lastCue: i,
    solverEnabled: v,
    setCellEditMode: p,
    selectedConstraint: l,
    selectConstraint: m,
    deselectConstraint: g,
    ...$,
  });
}
const ke = nh();
function Xr(t, e, n) {
  const { state: s } = ke();
  if (((e = `${t}_${e}`), !s.value.editorStates.has(e))) {
    const o = n();
    s.value.editorStates.set(e, o);
  }
  return s.value.editorStates.get(e);
}
function sh(t, e) {
  e = `${t}_${e}`;
  const { state: n } = ke();
  return n.value.editorStates.get(e);
}
const oh = { class: "ColorsPreview", viewBox: "0 0 20 20" },
  rh = ["fill", "x", "y", "width", "height"],
  Uc = S({
    __name: "ColorsPreview",
    props: { colors: {} },
    setup(t) {
      const e = t,
        n = b(() =>
          e.colors
            .slice(0, 9)
            .map((s, o) => ({
              x: 2 + 6 * (o % 3),
              y: 2 + 6 * Math.floor(o / 3),
              width: 4,
              height: 4,
              fill: s,
            }))
        );
      return (s, o) => (
        d(),
        C("svg", oh, [
          (d(!0),
          C(
            Z,
            null,
            se(
              n.value,
              (r, l) => (
                d(),
                C(
                  "rect",
                  {
                    key: l,
                    fill: r.fill,
                    x: r.x,
                    y: r.y,
                    width: r.width,
                    height: r.height,
                    stroke: "#fff",
                    "paint-order": "stroke",
                  },
                  null,
                  8,
                  rh
                )
              )
            ),
            128
          )),
        ])
      );
    },
  });
function Hc(t) {
  return typeof t == "string" ? Qt("span", [t]) : Qt(t);
}
class $s {
  constructor(e) {
    L(this, "label");
    L(this, "hotkeys");
    L(this, "input");
    L(this, "tooltip");
    L(this, "allowModifierKeys");
    (this.label = hi(Hc(e.label))),
      (this.hotkeys = Et(e.hotkeys)),
      (this.input = e.input.toString()),
      (this.tooltip = e.tooltip),
      (this.allowModifierKeys = e.allowModifierKeys);
  }
  matchesKeyEvent(e) {
    return !this.allowModifierKeys && e.ctrlKey
      ? !1
      : [`:${e.code}`, e.key].some((s) => this.hotkeys.includes(s));
  }
}
const lh = { class: "CandidateInputLabel" },
  ih = S({
    __name: "CandidateInputLabel",
    props: { digit: {} },
    setup(t) {
      return (e, n) => (d(), C("div", lh, X(e.digit), 1));
    },
  }),
  ah = B(ih, [["__scopeId", "data-v-2faab4fa"]]),
  uh = { class: "ColorInputLabel" },
  ch = S({
    __name: "ColorInputLabel",
    props: { digit: {}, color: {} },
    setup(t) {
      return (
        zn((e) => ({ ebc15606: e.color })),
        (e, n) => (d(), C("div", uh, X(e.digit), 1))
      );
    },
  }),
  Ba = B(ch, [["__scopeId", "data-v-dbda0d89"]]),
  dh = { class: "CornerInputLabel" },
  ph = S({
    __name: "CornerInputLabel",
    props: { digit: {} },
    setup(t) {
      zn((s) => ({ "5921e2c5": n.value }));
      const e = t,
        n = b(() => {
          switch (e.digit) {
            case 1:
              return "translate(-45%, -45%)";
            case 2:
              return "translate(0, -45%)";
            case 3:
              return "translate(45%, -45%)";
            case 4:
              return "translate(-45%, 0)";
            case 5:
              return "translate(0, 0)";
            case 6:
              return "translate(45%, 0)";
            case 7:
              return "translate(-45%, 45%)";
            case 8:
              return "translate(0, 45%)";
            case 9:
              return "translate(45%, 45%)";
            default:
              return "translate(0, 0)";
          }
        });
      return (s, o) => (d(), C("div", dh, X(s.digit), 1));
    },
  }),
  fh = B(ph, [["__scopeId", "data-v-11d0cc71"]]);
function go(t) {
  return String(t).padStart(2, "0");
}
function Wc(t) {
  t = new Date(t);
  const e = t.getFullYear(),
    n = t.getMonth() + 1,
    s = t.getDate();
  return `${e}-${go(n)}-${go(s)}`;
}
function hh(t) {
  const e = t.getHours(),
    n = t.getMinutes(),
    s = t.getSeconds();
  return `${go(e)}:${go(n)}:${go(s)}`;
}
function Zc(t, e, n) {
  return (s, o) => {
    if (o === void 0 || o < 1 || o > n) return e();
    let r = s;
    for (let l = o - 1; l < t.length; l++) r = t[l](r);
    return r;
  };
}
const za = 7,
  qn = {
    defaultAuthorName: "",
    nonGivenColor: "#5274ea",
    selectionColor: "#5274eac0",
    highlightColor: "#eedd0099",
    markColors: [
      "#ec6688",
      "#f6ab76",
      "#fde967",
      "#d3f284",
      "#7dcb88",
      "#81e1f7",
      "#8197e4",
      "#b569cc",
      "#f376ed",
      "#d1d1d1",
      "#a0a0a0",
      "#606060",
      "#e900a7",
      "#ff9207",
      "#a1e301",
      "#00ced3",
      "#3793fc",
      "#9840ff",
    ],
    multilineCandidates: !1,
    fileNameFormat: "<name>",
    theme: "auto",
    invertColorsInDarkMode: !1,
    preferredLayout: "wide",
    debug: !1,
    mouseWheelScale: { x: 1, y: 1, z: 1 },
    hotkeys: {
      undo: [["Control", "z"]],
      redo: [
        ["Control", "y"],
        ["Control", "Shift", "Z"],
      ],
      selectAll: [["Control", "a"]],
      delete: [[":Delete"], [":Backspace"]],
      setEnterDigits: [[":KeyZ"]],
      setEnterCornerPencilMarks: [[":KeyX"]],
      setEnterCandidates: [[":KeyC"]],
      setEnterColorMarks: [[":KeyV"]],
      newConstraint: [],
      openNextConstraint: [],
      openPreviousConstraint: [],
      removeConstraint: [],
      exitConstraintEditor: [[":Escape"]],
      clearGrid: [],
      doSingleLogicalStep: [],
      doAllLogicalSteps: [],
      findSolutions: [],
      checkValidity: [],
      stopSolver: [[":Escape"]],
      toggleFog: [["Control", "Shift", "F"]],
    },
    suppressedWarnings: [],
  };
function $r() {
  return ue(qn);
}
const ee = xs({
  name: "preferences",
  version: za,
  getDefault: $r,
  migrate: Zc([mh, gh, vh, yh, Ch, wh], $r, za),
});
function Gc(t) {
  return `${ee.fileNameFormat
    .replace(/<author>/g, t.author)
    .replace(/<name>/g, t.name)
    .replace(/<date>/g, Wc(t.date))
    .replace(/<time>/g, hh(t.date))}.${t.extension}`;
}
nc(() => {
  document.documentElement.classList.toggle(
    "light-theme",
    ee.theme === "light"
  ),
    document.documentElement.classList.toggle(
      "dark-theme",
      ee.theme === "dark"
    );
});
function mh(t) {
  return { ...t, mouseWheelScale: { x: 1, y: 1, z: 1 } };
}
function gh(t) {
  const e = t.markColors.slice(1).concat(qn.markColors.slice(9));
  return { ...t, markColors: e, hotkeys: ue(qn.hotkeys) };
}
function vh(t) {
  function e(n, s) {
    const o = ue(qn.hotkeys[s]);
    for (const [r, l] of Object.entries(n))
      r !== s && Lt.remove(o, l, { comparator: Ce });
    return o;
  }
  return {
    ...t,
    hotkeys: { ...t.hotkeys, toggleFog: e(t.hotkeys, "toggleFog") },
  };
}
function yh(t) {
  return delete t.defaultSudokuName, t;
}
function Ch(t) {
  return Object.assign($r(), t);
}
function wh(t) {
  return Object.assign($r(), t);
}
let Ke = (function (t) {
  return (
    (t[(t.Replace = 0)] = "Replace"),
    (t[(t.Concatenate = 1)] = "Concatenate"),
    (t[(t.CosmeticText = 2)] = "CosmeticText"),
    t
  );
})({});
const qc = yn(0);
function Ol(t) {
  return [`:Numpad${t}`, `:Digit${t}`];
}
function yn(t, e, n) {
  return new $s({
    label: e ?? String(t),
    hotkeys: Ol(t),
    input: t,
    allowModifierKeys: n,
  });
}
function bh(t) {
  const e = (s) => yn(s),
    n = Array.from(Ve(t.minDigit || 1, t.maxDigit), e);
  return {
    zeroButton: t.minDigit === 0 ? e(0) : void 0,
    deleteButton: !0,
    panel: n,
    type: Ke.Replace,
  };
}
function kh(t) {
  const e = (s) => yn(s, c(fh, { digit: s }, null), !0),
    n = Array.from(Ve(t.minDigit || 1, t.maxDigit), e);
  return {
    zeroButton: t.minDigit === 0 ? e(0) : void 0,
    deleteButton: !0,
    panel: n,
    type: Ke.Replace,
  };
}
function _h(t) {
  const e = (s) => yn(s, c(ah, { digit: s }, null), !0),
    n = Array.from(Ve(t.minDigit || 1, t.maxDigit), e);
  return {
    zeroButton: t.minDigit === 0 ? e(0) : void 0,
    deleteButton: !0,
    panel: n,
    type: Ke.Replace,
  };
}
function $h() {
  return {
    zeroButton: new $s({
      label: c(Ba, { digit: 0, color: "#ffffff" }, null),
      hotkeys: Ol(0),
      input: 0,
      allowModifierKeys: !0,
    }),
    deleteButton: !0,
    pagination: {
      label: (t) =>
        c(Uc, { colors: ee.markColors.slice(t * 9, t * 9 + 9) }, null),
    },
    panel: ee.markColors.map((t, e) => {
      const n = (e % 9) + 1;
      return new $s({
        label: c(Ba, { digit: n, color: t }, null),
        hotkeys: Ol(n),
        input: e + 1,
        allowModifierKeys: !0,
      });
    }),
    type: Ke.Replace,
  };
}
function Sh() {
  return {
    panel: [
      new $s({ label: "X", hotkeys: ["x", "X"], input: "X" }),
      new $s({ label: "V", hotkeys: ["v", "V"], input: "V" }),
    ],
  };
}
function Kc(t, e) {
  const n = (o) => yn(o),
    s = Array.from(Ve(e.minDigit || 1, e.maxDigit), (o) =>
      t.includes(o) ? n(o) : void 0
    );
  return { zeroButton: t.includes(0) ? n(0) : void 0, panel: s };
}
function Xc() {
  const t = (n) => yn(n),
    e = Array.from(Ve(1, 9), (n) => t(n));
  return { zeroButton: qc, panel: e };
}
function Yc(t) {
  const e = (s) => yn(s),
    n = Array.from(Ve(t.minDigit || 1, t.maxDigit), e);
  return {
    zeroButton: t.minDigit === 0 ? e(0) : void 0,
    panel: n,
    type: Ke.Replace,
  };
}
function Ih(t) {
  const e = (s) => yn(s),
    n = Array.from(Ve(t.minDigit || 1, t.maxDigit), e);
  return {
    zeroButton: t.minDigit === 0 ? e(0) : void 0,
    panel: n,
    type: Ke.Concatenate,
  };
}
function Zs() {
  return { ...Xc(), type: Ke.Concatenate };
}
const xh = { components: { Icon: he } };
function Dh(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "VerticalDots", viewBox: "0 0 16 6", stroke: "none" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h("circle", { r: "2", cx: "3", cy: "3" }, null, -1),
              h("circle", { r: "2", cx: "8", cy: "3" }, null, -1),
              h("circle", { r: "2", cx: "13", cy: "3" }, null, -1),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Mh = B(xh, [["render", Dh]]);
class Uo {
  constructor() {
    L(this, "all", new Map());
  }
  on(e, n) {
    const s = this.all.get(e);
    s ? s.add(n) : this.all.set(e, new Set([n]));
  }
  off(e, n) {
    const s = this.all.get(e);
    s && (n ? s.delete(n) : s.clear());
  }
  emit(e, n) {
    const s = this.all.get(e);
    if (s) for (const o of [...s]) o(n);
  }
}
function Pt(t, e, n) {
  t.on(e, n),
    zo(() => {
      t.off(e, n);
    });
}
function Jc() {
  var t;
  switch ((t = document.activeElement) == null ? void 0 : t.tagName) {
    case "TEXTAREA":
      return !1;
    case "INPUT": {
      const e = document.activeElement;
      if (e.type === "text" || e.type === "number") return !1;
    }
  }
  return !document.querySelector("#popups").contains(document.activeElement);
}
class Ah {
  constructor(e, n) {
    L(this, "hotkeyManager");
    L(this, "keyboardEvents");
    L(this, "eventBus", new Uo());
    L(this, "listenersStack", []);
    L(
      this,
      "state",
      Rf({
        mode: void 0,
        modeId: void 0,
        stringValue: "",
        ctrlDown: !1,
        metaDown: !1,
        shiftDown: !1,
        altDown: !1,
        selectingMode: !1,
        page: 0,
      })
    );
    (this.hotkeyManager = n),
      (this.handleKeyDown = this.handleKeyDown.bind(this)),
      (this.handleKeyUp = this.handleKeyUp.bind(this)),
      (this.keyboardEvents = e),
      this.keyboardEvents.addEventListener("keydown", this.handleKeyDown),
      this.keyboardEvents.addEventListener("keyup", this.handleKeyUp);
  }
  dispose() {
    this.keyboardEvents.removeEventListener("keydown", this.handleKeyDown),
      this.keyboardEvents.removeEventListener("keyup", this.handleKeyUp);
  }
  setCurrentValue(e) {
    this.state.stringValue = String(e);
  }
  getCurrentValue() {
    return this.state.stringValue;
  }
  setInputMode(e, n) {
    var o;
    (!n || n !== this.state.modeId) &&
      ((this.state.page = 0), (this.state.stringValue = ""));
    const s =
      (o = e == null ? void 0 : e.pagination) == null ? void 0 : o.currentPage;
    s !== void 0 && (this.state.page = s),
      (this.state.mode = e),
      (this.state.modeId = n);
  }
  getInputMode() {
    return this.state.mode;
  }
  getButtons() {
    const e = this.getInputMode();
    if (!(e != null && e.panel)) return Array.from({ length: 10 }, () => {});
    const n = e.panel.slice(this.state.page * 9, (this.state.page + 1) * 9);
    for (; n.length < 9 || n.length % 3 !== 0; ) n.push(void 0);
    return e.zeroButton ? n.push(e.zeroButton) : n.push(void 0), n;
  }
  getPagination() {
    var r;
    const e = this.getInputMode();
    if (!(e != null && e.panel)) return { enabled: !1 };
    const n = Math.ceil(e.panel.length / 9),
      s = (this.state.page + 1) % n,
      o =
        ((r = e.pagination) == null ? void 0 : r.label(s)) ||
        (() => Qt(Mh, { style: "margin: 0.5rem" }));
    return hi({
      enabled: e.panel.length > 9,
      label: o || void 0,
      page: this.state.page,
      count: n,
    });
  }
  openNextPage() {
    const e = this.getInputMode();
    if (!(e != null && e.panel)) return 0;
    let n = this.state.page + 1;
    return n * 9 >= e.panel.length && (n = 0), (this.state.page = n), n;
  }
  setPage(e) {
    const n = this.getInputMode();
    n != null &&
      n.panel &&
      (e * 9 >= n.panel.length && (e = 0), (this.state.page = e));
  }
  getSupportsAnyCharacter() {
    var e;
    return (
      ((e = this.getInputMode()) == null ? void 0 : e.type) === Ke.CosmeticText
    );
  }
  validate(e) {
    const n = this.getInputMode();
    return n ? (n.validation ? n.validation(e) : !0) : !1;
  }
  isAltEnabled() {
    return this.state.altDown;
  }
  triggerInput(e, n = !1) {
    var r, l;
    if (
      (l = (r = this.state.mode) == null ? void 0 : r.callback) != null &&
      l.call(r, e)
    )
      return !0;
    const s = this.getInputMode();
    if (!s || !this.supportsValue(e)) return;
    let o = "";
    s.type === Ke.Replace || n ? (o = e) : (o = this.state.stringValue + e),
      this.validate(o) &&
        ((this.state.stringValue = o),
        this.emit("input", { string: this.state.stringValue }));
  }
  setSelecting(e) {
    this.state.selectingMode = e;
  }
  isSelecting() {
    return (
      this.state.selectingMode || this.state.ctrlDown || this.state.shiftDown
    );
  }
  triggerDelete() {
    this.emit("delete");
  }
  triggerBackspace() {
    this.handleBackspaceForInput();
  }
  triggerSelectAll() {
    this.emit("selectAll");
  }
  triggerUndo() {
    this.emit("undo");
  }
  triggerRedo() {
    this.emit("redo");
  }
  addEventListener(e, n) {
    this.eventBus.on(e, n), this.listenersStack.push({ type: e, callback: n });
  }
  removeEventListener(e, n) {
    this.eventBus.off(e, n);
    const s = this.listenersStack.findIndex((o) =>
      Ce(o, { type: e, callback: n })
    );
    s > -1 && this.listenersStack.splice(s, 1);
  }
  emit(e, n) {
    this.eventBus.emit(e, n);
  }
  handleDisplayedKeyPress(e) {
    const n = this.getButtons();
    for (const s of n)
      if (s && s.matchesKeyEvent(e))
        return e.preventDefault(), this.triggerInput(String(s.input)), !0;
    return !1;
  }
  handleKeyDown(e) {
    var s;
    if (!Jc()) return;
    switch (e.key) {
      case "Control":
        (this.state.ctrlDown = !0), this.emit("modifierDown", e);
        break;
      case "Meta":
        (this.state.metaDown = !0), this.emit("modifierDown", e);
        break;
      case "Shift":
        (this.state.shiftDown = !0), this.emit("modifierDown", e);
        break;
      case "Alt":
        (this.state.altDown = !0), this.emit("modifierDown", e);
        break;
      case "Backspace": {
        const o = (s = this.getInputMode()) == null ? void 0 : s.type;
        if (
          (o === Ke.Concatenate || o === Ke.CosmeticText) &&
          this.state.stringValue.length > 0
        ) {
          e.preventDefault(), this.handleBackspaceForInput();
          return;
        }
        break;
      }
      default:
        if (
          this.getSupportsAnyCharacter() &&
          !this.state.ctrlDown &&
          !this.state.altDown &&
          !this.state.metaDown &&
          !e.key.match(/^[A-Z][a-z]|^F\d/)
        ) {
          this.triggerInput(e.key);
          return;
        }
    }
    if (this.handleDisplayedKeyPress(e)) return;
    const n = this.hotkeyManager.getActions(e);
    if (n.length > 0) {
      e.preventDefault(), this.handleAction(this.pickMostAppropriateAction(n));
      return;
    }
    switch (e.key) {
      case "ArrowLeft":
        this.emit("arrow", { direction: An.Left });
        break;
      case "ArrowRight":
        this.emit("arrow", { direction: An.Right });
        break;
      case "ArrowUp":
        this.emit("arrow", { direction: An.Up });
        break;
      case "ArrowDown":
        this.emit("arrow", { direction: An.Down });
        break;
    }
  }
  pickMostAppropriateAction(e) {
    return e.length === 1
      ? e[0]
      : e.sort((n, s) => {
          const o = this.listenersStack.findLastIndex((l) => l.type === n);
          return this.listenersStack.findLastIndex((l) => l.type === s) - o;
        })[0];
  }
  handleAction(e) {
    switch (e) {
      case "setEnterDigits":
        this.emit("setEditor", { type: ie.CellDigit });
        return;
      case "setEnterCornerPencilMarks":
        this.emit("setEditor", { type: ie.CellCornerPencilMark });
        return;
      case "setEnterCandidates":
        this.emit("setEditor", { type: ie.CellCandidate });
        return;
      case "setEnterColorMarks":
        this.emit("setEditor", { type: ie.CellColor });
        return;
      default:
        this.emit(e);
    }
  }
  handleKeyUp(e) {
    switch (e.key) {
      case "Control":
        this.state.ctrlDown = !1;
        break;
      case "Meta":
        this.state.metaDown = !1;
        break;
      case "Shift":
        this.state.shiftDown = !1;
        break;
      case "Alt":
        this.state.altDown = !1;
        break;
    }
    this.emit("modifierUp", e);
  }
  supportsValue(e) {
    const n = this.getInputMode();
    return n
      ? n.type === Ke.CosmeticText
        ? !0
        : this.getButtons().some((s) => (s == null ? void 0 : s.input) === e)
      : !1;
  }
  handleBackspaceForInput() {
    const e = [...this.state.stringValue];
    (this.state.stringValue = e.slice(0, e.length - 1).join("")),
      this.emit("input", { string: this.state.stringValue });
  }
}
function Ph(t) {
  return new Worker("/assets/solver-DgvorfM7.js", {
    name: t == null ? void 0 : t.name,
  });
}
class co {
  constructor() {
    L(this, "promise");
    L(this, "_resolve");
    L(this, "_reject");
    L(this, "fulfilled", !1);
    this.promise = new Promise((e, n) => {
      (this._resolve = e), (this._reject = n);
    });
  }
  isFulfilled() {
    return this.fulfilled;
  }
  resolve(e) {
    this.fulfilled || ((this.fulfilled = !0), this._resolve(e));
  }
  reject(e) {
    this.fulfilled || ((this.fulfilled = !0), this._reject(e));
  }
}
class Qc {
  constructor(e, n) {
    L(this, "worker");
    L(this, "state", 0);
    L(this, "deferredInit");
    L(this, "deferredNext");
    L(this, "onDispose");
    (this.input = e),
      (this.strategyParams = n),
      (this.worker = new Ph()),
      (this.worker.onmessage = this.onMessage.bind(this)),
      (this.worker.onerror = (s) => {
        alert(`Could not run the solver: ${s.message}`);
      });
  }
  dispose(e) {
    var r, l, i, a;
    const n =
      (this.deferredInit && !this.deferredInit.isFulfilled()) ||
      (this.deferredNext && !this.deferredNext.isFulfilled());
    let s, o;
    typeof e == "string"
      ? ((s = e), (o = new Error(s)))
      : typeof e == "object"
      ? ((s = e.message), (o = e))
      : ((s = ""), (o = new Error(""))),
      console.info(
        `Disposed of solver worker (reason: ${s}; was running: ${n})`
      ),
      (this.state = 4),
      (r = this.deferredInit) == null || r.reject(o),
      (l = this.deferredNext) == null || l.reject(o),
      (i = this.worker) == null || i.terminate(),
      (a = this.onDispose) == null || a.call(this);
  }
  async execute(e) {
    if (this.state === 0) {
      this.state = 1;
      const s = await this.initialize();
      if (!s.valid) return s;
    } else {
      if (this.state === 3 || this.state === 1)
        throw new Error("Cannot solve while solver is running");
      if (this.state === 4)
        throw new Error("Cannot solve when solver is disposed");
    }
    (this.state = 3), (this.deferredNext = new co()), this.postMessage(e);
    const n = await this.deferredNext.promise;
    return (this.state = 2), n;
  }
  async executeWithCallback(e, n) {
    if (this.state === 0) {
      if (((this.state = 1), !(await this.initialize()).valid)) {
        n(void 0);
        return;
      }
    } else {
      if (this.state === 3 || this.state === 1)
        throw new Error("Cannot solve while solver is running");
      if (this.state === 4)
        throw new Error("Cannot solve when solver is disposed");
    }
    for (
      this.state = 3, this.deferredNext = new co(), this.postMessage(e);
      n(await this.deferredNext.promise);

    )
      this.deferredNext = new co();
    this.state = 2;
  }
  async initialize() {
    this.deferredInit = new co();
    const n = {
      type: "start",
      grid: fc(this.input.cells),
      spec: ue(this.input.spec),
      constraints: ue(this.input.constraints),
      strategy: ue(this.strategyParams),
    };
    return this.postMessage(n), await this.deferredInit.promise;
  }
  postMessage(e) {
    this.worker.postMessage(e);
  }
  onMessage(e) {
    var n, s, o, r, l;
    switch (e.data.type) {
      case "init": {
        if (this.state !== 1) return;
        const i = e.data;
        i.sudoku
          ? ((n = this.deferredInit) == null ||
              n.resolve({ changed: !0, sudokuData: i.sudoku, valid: !0 }),
            (this.state = 2))
          : (s = this.deferredInit) == null ||
            s.resolve({
              changed: !1,
              valid: !1,
              error: i.error
                ? `This puzzle is broken: ${i.error}`
                : "This puzzle is broken.",
            });
        break;
      }
      case "update": {
        if (this.state !== 3) return;
        const i = e.data;
        i.valid
          ? (r = this.deferredNext) == null || r.resolve(i)
          : (o = this.deferredNext) == null ||
            o.resolve({ ...i, error: this.getErrorMessage(i) });
        break;
      }
      case "error": {
        if (this.state !== 3) return;
        (l = this.deferredNext) == null ||
          l.reject(new Error("An unknown error occurred"));
        break;
      }
    }
  }
  getErrorMessage(e) {
    let n = "Puzzle is impossible";
    return e.error && (n += `: ${e.error}`), n;
  }
}
class Lh extends Qc {
  async findNext() {
    return await this.execute({ type: "findNext" });
  }
  async findAll(e) {
    await this.executeWithCallback({ type: "findAll" }, e);
  }
}
class kl extends Qc {
  async step() {
    return await this.execute({ type: "step" });
  }
}
class Eh {
  constructor() {
    L(this, "solver");
  }
  getLogicalSolver(e, n) {
    return (
      this.solver &&
        !(this.solver instanceof kl) &&
        (this.solver.dispose(), (this.solver = void 0)),
      this.solver || (this.solver = new kl(e, n)),
      this.solver
    );
  }
  getSolutionFinder(e, n) {
    return (
      this.solver && this.solver.dispose(),
      (this.solver = new Lh(e, n)),
      this.solver
    );
  }
  resetLogicalSolver() {
    !this.solver ||
      !(this.solver instanceof kl) ||
      (this.solver.dispose(), (this.solver = void 0));
  }
  stop(e) {
    var n;
    (n = this.solver) == null || n.dispose(e), (this.solver = void 0);
  }
}
const Ss = Bh(),
  ed = nd(),
  td = Fh();
function nd() {
  return (
    navigator.userAgent.includes("Safari") &&
    !navigator.userAgent.includes("Chrome")
  );
}
function Fh() {
  return nd() && window.matchMedia("(display-mode: standalone)").matches;
}
function Bh() {
  return navigator.platform
    ? navigator.platform.toLowerCase().includes("mac")
    : navigator.userAgent.includes("Mac OS X");
}
function sd(t) {
  var s, o;
  if (t instanceof ps)
    return {
      key: t.key,
      code: t.code,
      ctrlKey: t.ctrlKey,
      shiftKey: t.shiftKey,
      metaKey: t.metaKey,
      altKey: t.altKey,
    };
  let e = t.key,
    n = t.code;
  if (Rh(t.key)) {
    const r = ((s = t.code.match(/Left|Right/)) == null ? void 0 : s[0]) || "";
    (e = "Meta"), (n = `Meta${r}`);
  } else if (zh(t.key)) {
    const r = ((o = t.code.match(/Left|Right/)) == null ? void 0 : o[0]) || "";
    (e = "Control"), (n = `Control${r}`);
  }
  return {
    key: e,
    code: n,
    ctrlKey: Ss ? t.metaKey : t.ctrlKey,
    shiftKey: t.shiftKey,
    metaKey: Ss ? t.ctrlKey : t.metaKey,
    altKey: t.altKey,
  };
}
function zh(t) {
  return Ss ? t === "Meta" : t === "Control";
}
function Rh(t) {
  return Ss ? t === "Control" : t === "Meta";
}
class ps extends KeyboardEvent {
  constructor(n, s) {
    const o = sd(n);
    super(n.type, { ...o, repeat: n.repeat, ...s });
    L(this, "originalEvent");
    this.originalEvent = n;
  }
  preventDefault() {
    this.originalEvent.preventDefault();
  }
  stopPropagation() {
    this.originalEvent.stopPropagation();
  }
  stopImmediatePropagation() {
    this.originalEvent.stopImmediatePropagation();
  }
}
class Oh {
  constructor() {
    L(this, "bus", new Uo());
    L(this, "modifierKeyStates", { Control: !1, Meta: !1, Shift: !1, Alt: !1 });
    L(this, "dismissShiftUpEvent", !1);
    document.addEventListener(
      "keydown",
      (e) => {
        if (!Jc()) return;
        const n = Ra(e);
        if (n !== void 0 && e.code.match(/^Numpad/)) {
          if ((e.preventDefault(), e.repeat)) return;
          e.getModifierState("NumLock") &&
            !e.key.match(/\d$/) &&
            (this.dismissShiftUpEvent = !0),
            this.bus.emit("keydown", new ps(e, { key: n }));
        } else
          switch (e.key) {
            case "Control":
            case "Meta":
            case "Shift":
            case "Alt": {
              const s = new ps(e);
              this.modifierKeyStates[s.key] ||
                ((this.modifierKeyStates[s.key] = !0),
                this.bus.emit("keydown", s));
              break;
            }
            default:
              this.bus.emit("keydown", new ps(e));
              break;
          }
      },
      !1
    ),
      document.addEventListener("keyup", this.onKeyUp.bind(this), !1),
      window.addEventListener("blur", () => {
        for (const e in this.modifierKeyStates)
          this.modifierKeyStates[e] &&
            this.onKeyUp(new ps(new KeyboardEvent("keyup"), { key: e }));
      });
  }
  addEventListener(e, n) {
    this.bus.on(e, n);
  }
  removeEventListener(e, n) {
    this.bus.off(e, n);
  }
  onKeyUp(e) {
    const n = Ra(e);
    if (n !== void 0) {
      this.bus.emit("keyup", new ps(e, { key: n }));
      return;
    }
    const s = new ps(e),
      o = () => {
        if (s.key === "Shift" && this.dismissShiftUpEvent) {
          this.dismissShiftUpEvent = !1;
          return;
        }
        s.key &&
          this.modifierKeyStates[s.key] &&
          ((this.modifierKeyStates[s.key] = !1), this.bus.emit("keyup", s));
      };
    s.key === "Shift"
      ? ((this.dismissShiftUpEvent = !1), setTimeout(o, 1))
      : o();
  }
}
function Ra(t) {
  const e = t.code.match(/^(?:Digit|Numpad)(\d)$/);
  if (e) return e[1];
}
const jt = rn(new T0()),
  kt = new z0(),
  Nh = new Oh(),
  ye = new Ah(Nh, kt),
  Nn = new Eh(),
  od = new E0(),
  nt = new Uo();
ye.addEventListener("undo", () => jt.undo());
ye.addEventListener("redo", () => jt.redo());
ae(
  () => ee.hotkeys,
  (t) => {
    kt.update(t);
  },
  { immediate: !0, deep: !0 }
);
const Sr = j();
j(!1);
const rt = j(!1);
function Th() {
  od.dispose(), (document.body.style.visibility = "hidden"), location.reload();
}
function bn(t, ...e) {
  for (const n of e)
    for (const s of Object.keys(n)) {
      const o = t[s];
      !Array.isArray(o) &&
      typeof o == "object" &&
      !(o instanceof Map) &&
      !(o instanceof Set) &&
      o !== null
        ? bn(o, n[s])
        : (t[s] = n[s]);
    }
  return t;
}
const { project: Nl } = ke();
function Vh() {
  return hi(Nl.value);
}
function jh(t, e = "Update puzzle") {
  const n = Nl.value,
    s = ue(Nl.value),
    o = () => {
      t(n);
    },
    r = () => {
      (n.author = s.author),
        (n.name = s.name),
        (n.comment = s.comment),
        n.cells.forEach((l, i) => {
          bn(l, s.cells[i]);
        }),
        (n.allConstraints = ue(s.allConstraints));
    };
  jt.executeAndRecord(o, r, e);
}
function Uh(t) {
  ye.handleAction(t);
}
const Hh = {
  getPuzzle: Vh,
  updatePuzzle: jh,
  PuzzleElementType: _,
  triggerAction: Uh,
  allActions: ko,
  busy: b(() => rt.value),
  MathUtils: ic,
  Vector2Funcs: Di,
  ArrayUtils: Lt,
  SetUtils: He,
  IterationUtils: Si,
  SmallNumberSet: Oo,
  DigitSet: Mt,
  DiagonalType: Se,
  OuterPosition: we,
};
var K = ((t) => (
  (t[(t.String = 0)] = "String"),
  (t[(t.StringArray = 1)] = "StringArray"),
  (t[(t.Cell = 2)] = "Cell"),
  (t[(t.CellArray = 3)] = "CellArray"),
  (t[(t.CellOrCellArray = 4)] = "CellOrCellArray"),
  (t[(t.Number = 5)] = "Number"),
  (t[(t.NumberArray = 6)] = "NumberArray"),
  (t[(t.NumberOrNumberArray = 7)] = "NumberOrNumberArray"),
  (t[(t.DigitSet = 8)] = "DigitSet"),
  (t[(t.DigitSetArray = 9)] = "DigitSetArray"),
  (t[(t.Boolean = 10)] = "Boolean"),
  (t[(t.BooleanArray = 11)] = "BooleanArray"),
  (t[(t.Object = 12)] = "Object"),
  (t[(t.ObjectArray = 13)] = "ObjectArray"),
  t
))(K || {});
const Tl = new Map(),
  rd = new Map(),
  Wh = [["cells", K.CellArray]];
function $e(t, e, n = Wh) {
  return function (s) {
    t = Et(t).map((o) => (o.endsWith("Component") ? o : `${o}Component`));
    for (const o of t) rd.set(o, s);
    if (!Tl.has(s)) {
      const [o, ...r] = t;
      Tl.set(s, { name: o, aliases: r, description: e, params: n });
    }
  };
}
function Oa() {
  return rd;
}
function Zh() {
  return Tl.values();
}
class Gh extends kc {
  constructor(e, n, s, o, r) {
    super(n, s, o, r), (this.sudoku = e);
  }
  getSubsetsPerRegion(e) {
    const n = new Map();
    for (const s of new Set(e)) {
      const o = this.sudoku.getRegionIdAt(s);
      n.has(o) || n.set(o, []), n.get(o).push(s);
    }
    return n;
  }
}
class ld {
  getLineEnds(e) {
    return [e[0], e.at(-1)];
  }
  getCellsBetweenLineEnds(e) {
    return e.slice(1, e.length - 1);
  }
  *getAllPairsAlongLines(e) {
    for (const n of e)
      for (let s = 0; s < n.length - 1; s++) yield [n[s], n[s + 1]];
  }
}
class qh {
  constructor(e, n, s, o, r) {
    L(this, "spec");
    (this.cellIdHelper = e),
      (this.edgeIdHelper = n),
      (this.outerCellIdHelper = s),
      (this.cornerIdHelper = o),
      (this.geometryHelper = r),
      (this.spec = e.spec);
  }
  *getEdgesForNegativeConstraint(e) {
    const n = new Set();
    for (const r of e) n.add(r.edge);
    const { width: s, height: o } = this.spec.size;
    for (let r = 0; r < o; r++)
      for (let l = 0; l < s; l++) {
        if (l < s - 1) {
          const i = this.edgeIdHelper.getIdFromCoords({ x: l + 1, y: r + 0.5 });
          n.has(i) || (yield i);
        }
        if (r < o - 1) {
          const i = this.edgeIdHelper.getIdFromCoords({ x: l + 0.5, y: r + 1 });
          n.has(i) || (yield i);
        }
      }
  }
  getCellGroupsFromLines(e) {
    const n = [],
      s = new Ut(e),
      o = new Set(s.getPoints());
    for (; o.size > 0; ) {
      const r = Mn(o),
        i = s.getComponentContainingPoint(r).getPoints();
      n.push(i);
      for (const a of i) o.delete(a);
    }
    return n;
  }
}
function Kh(t, e) {
  const n = Fn(t);
  return {
    ...n,
    geometry: new Gh(e, n.cellIds, n.edgeIds, n.cornerIds, n.outerCellIds),
    lines: new ld(),
    misc: new qh(n.cellIds, n.edgeIds, n.outerCellIds, n.cornerIds, n.geometry),
  };
}
function Xh(t) {
  return { ...Fn(t), lines: new ld() };
}
class id {
  constructor(e, n, s) {
    L(this, "spec");
    L(this, "state");
    L(this, "helpers");
    (this.spec = e), (this.state = n), (this.helpers = s);
  }
  get puzzleType() {
    return this.spec.type;
  }
  get size() {
    return this.spec.size.width;
  }
  get width() {
    return this.spec.size.width;
  }
  get height() {
    return this.spec.size.height;
  }
  get maxDigit() {
    return this.spec.maxDigit;
  }
  get minDigit() {
    return this.spec.minDigit;
  }
  get digitCount() {
    return this.spec.digitCount;
  }
  hasRegions() {
    return this.state.hasRegions();
  }
  getRegions() {
    return this.state.getRegions();
  }
  getRegion(e) {
    return this.state.getRegionIdAt(e);
  }
  getRegionCells(e) {
    return this.state.getRegions()[e];
  }
  getRegionAt(e, n) {
    return this.state.getRegionIdAt(this.unsafeGetCellAt(e, n));
  }
  getY(e) {
    return this.helpers.cellIds.getY(e);
  }
  getX(e) {
    return this.helpers.cellIds.getX(e);
  }
  getRow(e) {
    return this.helpers.cellIds.getY(e);
  }
  getColumn(e) {
    return this.helpers.cellIds.getX(e);
  }
  getCellAt(e, n) {
    return this.helpers.cellIds.getIdFromCoordsSafe({ x: e, y: n });
  }
  unsafeGetCellAt(e, n) {
    return this.helpers.cellIds.getIdFromCoords({ x: e, y: n });
  }
  *getCellsOrthogonallyAdjacentToCell(e) {
    yield* this.helpers.geometry.getOrthogonallyAdjacentCells(e);
  }
  *getCellsOrthogonallyAdjacentToCoords(e, n) {
    yield* this.getCellsOrthogonallyAdjacentToCell(
      this.helpers.cellIds.getIdFromCoords({ x: e, y: n })
    );
  }
  *getCellsDiagonallyAdjacentToCell(e) {
    yield* this.helpers.geometry.getDiagonallyAdjacentCells(e);
  }
  *getCellsDiagonallyAdjacentToCoords(e, n) {
    yield* this.getCellsDiagonallyAdjacentToCell(
      this.helpers.cellIds.getIdFromCoords({ x: e, y: n })
    );
  }
  getFriendlyDigitsForCell(e) {
    const n = this.state.getRegionIdAt(e),
      s = n >= 0 ? 1 << (n + 1) : 0;
    return new Mt(
      (1 << (this.helpers.cellIds.getX(e) + 1)) |
        (1 << (this.helpers.cellIds.getY(e) + 1)) |
        s
    );
  }
  getCellsSeeEachOther(e) {
    return this.state.getCellsSeeEachOther(e);
  }
  getCellsSeenByCell(e, n) {
    return this.state.getCellsSeenByCell(e, n);
  }
  getCellsCanHaveRepeats(e) {
    return this.state.getCellsCanHaveRepeats(e);
  }
}
class Yh extends id {
  constructor(e, n, s) {
    super(e, n, s);
  }
  setRegions(e) {
    this.state.setRegions(e);
  }
  addConstraintComponent(e) {
    this.state.addConstraintComponent(e);
  }
  removeConstraintComponent(e) {
    this.state.removeConstraintComponent(e);
  }
  getConstraintComponentsAt(e) {
    return this.state.getConstraintComponentsAt(e);
  }
}
class Jh extends id {
  constructor(e, n, s, o) {
    super(n, s, o), (this.instance = e);
  }
  getValue(e) {
    return this.state.cells[e].value;
  }
  hasValue(e) {
    return this.state.cells[e].value !== void 0;
  }
  getCandidates(e) {
    return new Mt(this.state.cells[e].candidates);
  }
  getCandidatesBitMask(e) {
    return this.state.cells[e].candidates;
  }
  getCellsAreFilled(e) {
    for (const n of e) if (!this.hasValue(n)) return !1;
    return !0;
  }
  getFriendlyCandidates(e) {
    const n = this.getFriendlyDigitsForCell(e);
    return n.intersect(this.getCandidates(e)), n;
  }
  removeCandidateFromCell(e, n) {
    return Ts(e, n);
  }
  removeCandidatesFromCell(e, n) {
    return Kr(e, n);
  }
  filterCandidatesInCell(e, n) {
    return it(e, n);
  }
  removeCandidateFromCells(e, n) {
    return Fi(e, n);
  }
  removeCandidatesFromCells(e, n) {
    return _o(e, n);
  }
  filterCandidatesInCells(e, n) {
    return qt(e, n);
  }
  removeComponent(e) {
    return vn(e);
  }
  replaceComponent(e, n) {
    return On(e, n);
  }
  stop(e, n) {
    return gt(e || `unable to satisfy ${this.instance.name}`, n);
  }
}
function Qh() {
  return {
    MathUtils: ic,
    Vector2Funcs: Di,
    ArrayUtils: Lt,
    SetUtils: He,
    IterationUtils: Si,
    SudokuDigitSet: Mt,
    SmallNumberSet: Oo,
    DigitSet: Mt,
    DiagonalType: Se,
    OuterPosition: we,
  };
}
const Me = { valid: !0 };
class Pe {
  constructor(e, n) {
    L(this, "name");
    L(this, "cellIds");
    L(this, "tags", []);
    (this.name = e || "Nameless constraint"), (this.cellIds = n);
  }
  get validateDuringSolve() {
    return !1;
  }
  get allowsEmptyCells() {
    return !1;
  }
  *initialize(e) {
    if (
      this.getSeenCells !== Pe.prototype.getSeenCells ||
      this.onValueSet !== Pe.prototype.onValueSet
    )
      for (const n of this.cellIds) {
        const s = e.cells[n].value;
        s !== void 0 &&
          (yield* this.onValueSet(e, n, s),
          yield Fi(s, this.getSeenCells(e, n)));
      }
    yield* this.update(e);
  }
  *onValueSet(e, n, s) {}
  *update(e) {}
  validate(e) {
    return Me;
  }
  getSeenCells(e, n) {
    return [];
  }
  getIsDone(e) {
    return this.validateDuringSolve && !this.validate(e).valid
      ? !1
      : this.cellIds.every((n) => e.cells[n].value !== void 0);
  }
}
let me,
  Gs = 0,
  Ee;
const Yr = Ii,
  fn = Vt;
function* Yn(t) {
  yield* nn(t, me.minDigit, me.maxDigit);
}
function $t(t) {
  return Xn(t, me.minDigit, me.maxDigit);
}
function Ot(t) {
  return br(t, me.minDigit, me.maxDigit);
}
var em = Object.defineProperty,
  tm = Object.getOwnPropertyDescriptor,
  nm = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? tm(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && em(e, n, o), o;
  };
let Na = class extends Pe {
  constructor(t, e, n) {
    super(t, [...e, ...n]), (this.endPoints = e), (this.midPoints = n);
  }
  *update({ cells: t }) {
    yield* this.updateEnds(t), yield* this.updateInBetween(t);
  }
  *updateInBetween(t) {
    const e = t[this.endPoints[0]],
      n = t[this.endPoints[1]],
      s = [$t(e.candidates), Ot(n.candidates)],
      o = [$t(n.candidates), Ot(e.candidates)];
    let r, l;
    if (s[0] < s[1] && o[0] < o[1])
      (r = Math.max(s[1], o[1])), (l = Math.min(s[0], o[0]));
    else if (s[0] < s[1]) (r = s[1]), (l = s[0]);
    else if (o[0] < o[1]) (r = o[1]), (l = o[0]);
    else {
      yield gt(
        `the end-points of ${this.name} have the same value`,
        this.endPoints
      );
      return;
    }
    let i = 0;
    for (let a = l + 1; a <= r - 1; a++) i |= 1 << a;
    yield qt(i, this.midPoints);
  }
  *updateEnds(t) {
    let e = me.maxDigit - 1,
      n = me.minDigit + 1;
    for (const u of this.midPoints) {
      const p = t[u].value;
      p !== void 0 && ((e = Math.min(e, p)), (n = Math.max(n, p)));
    }
    if (e > n) return;
    let s = 0,
      o = 0;
    for (let u = me.minDigit; u <= me.maxDigit; u++)
      u < e ? (s |= 1 << u) : u > n && (o |= 1 << u);
    const r = t[this.endPoints[0]].candidates,
      l = t[this.endPoints[1]].candidates,
      i = (r & s) !== 0 && (l & o) !== 0,
      a = (r & o) !== 0 && (l & s) !== 0;
    !i && !a
      ? yield gt(
          `no valid values exist for the end-points of ${this.name}`,
          this.endPoints.slice()
        )
      : i && !a
      ? (yield it(s, this.endPoints[0]), yield it(o, this.endPoints[1]))
      : !i && a
      ? (yield it(o, this.endPoints[0]), yield it(s, this.endPoints[1]))
      : yield qt(s | o, this.endPoints);
  }
  getIsDone({ cells: t }) {
    return (
      t[this.endPoints[0]].value !== void 0 &&
      t[this.endPoints[1]].value !== void 0
    );
  }
};
Na = nm(
  [
    $e(
      "Between",
      "The digits on all {midPoints} must be between the digits on the {endPoints}.",
      [
        ["endPoints", { type: K.CellArray, amount: 2 }],
        ["midPoints", K.CellArray],
      ]
    ),
  ],
  Na
);
var sm = Object.defineProperty,
  om = Object.getOwnPropertyDescriptor,
  rm = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? om(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && sm(e, n, o), o;
  };
let Vl = class extends Pe {
  constructor(t, e) {
    super(t, e);
  }
  *update({ cells: t }) {
    const e = Array.from({ length: me.maxDigit + 1 }, () => !1);
    let n = this.cellIds.length;
    for (const o of this.cellIds) {
      const r = t[o].candidates;
      if (Yr(r) === 1) {
        const l = $t(r);
        e[l] && n--, (e[l] = !0);
      }
    }
    let s = Gs;
    for (const o of this.cellIds) {
      const r = Math.max(me.minDigit, $t(t[o].candidates) - n + 1),
        l = Math.min(me.maxDigit, Ot(t[o].candidates) + n - 1);
      s &= fn(Ve(r, l));
    }
    yield qt(s, this.cellIds);
  }
};
Vl = rm(
  [
    $e(
      "ConsecutiveDigits",
      "All digits within {cells} must make a set of consecutive digits, but may repeat as well.",
      [["cells", K.CellArray]]
    ),
  ],
  Vl
);
class Tn extends Pe {
  constructor(e, n, s) {
    super(e, n), (this.getComponents = s);
  }
  *initialize(e) {
    yield On(this, this.getComponents(e));
  }
}
var Wt = ((t) => (
  (t[(t.None = 0)] = "None"),
  (t[(t.Number = 1)] = "Number"),
  (t[(t.Numbers = 2)] = "Numbers"),
  (t[(t.String = 3)] = "String"),
  t
))(Wt || {});
function lm(t) {
  switch (t) {
    case 0:
      return (e, n, s) => n + 10 * s;
    case 1:
      return (e, n, s) => (n + 10 * s) * 1e3 + e;
    case 2:
      return (e, n, s) => `${e.join(",")}_${n + 10 * s}`;
    case 3:
      return (e, n, s) => `${e}_${n + 10 * s}`;
  }
}
class an {
  constructor(e, n = Wt.None) {
    L(this, "memoizedGenerate");
    (this.callback = e),
      (this.paramType = n),
      (this.memoizedGenerate = Zr((s, o, r) => {
        const l = [];
        for (let i = o; i <= r; i++) l[i] = e(s, i);
        return l;
      }, lm(n)));
  }
  getFriends(e) {
    return this.memoizedGenerate(e, me.minDigit, me.maxDigit);
  }
}
var im = Object.defineProperty,
  am = Object.getOwnPropertyDescriptor,
  um = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? am(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && im(e, n, o), o;
  };
const cm = Zr(
    (t) => {
      const { minDigit: e, maxDigit: n } = me,
        s = Array.from({ length: n + 1 }, () => 0);
      for (let o = e; o <= n; o++) for (const r of Yn(t[o])) s[r] |= 1 << o;
      return s;
    },
    (t) => t,
    !0
  ),
  dm = Zr(
    (t) => {
      const e = Array.from({ length: me.maxDigit + 1 }, () => 0),
        n = Array.from({ length: me.maxDigit + 1 }, () => 0);
      for (let s = me.minDigit; s <= me.maxDigit; s++)
        for (let o = me.minDigit; o <= me.maxDigit; o++)
          t(s, o) && ((e[s] |= 1 << o), (n[o] |= 1 << s));
      return [e, n];
    },
    (t) => t,
    !0
  );
let Kt = class extends Pe {
  constructor(e, n, s, o) {
    super(e, [s, o]);
    L(this, "friendsFor2");
    L(this, "friendsFor1");
    L(this, "cellId1");
    L(this, "cellId2");
    Array.isArray(n)
      ? ((this.friendsFor1 = n), (this.friendsFor2 = cm(this.friendsFor1)))
      : ([this.friendsFor1, this.friendsFor2] = dm(n)),
      (this.cellId1 = s),
      (this.cellId2 = o);
  }
  *update({ cells: e }) {
    const n = e[this.cellId1].candidates,
      s = e[this.cellId2].candidates;
    if (n) {
      let o = 0;
      for (const r of Yn(n)) o |= this.friendsFor1[r];
      yield it(o, this.cellId2);
    }
    if (s) {
      let o = 0;
      for (const r of Yn(s)) o |= this.friendsFor2[r];
      yield it(o, this.cellId1);
    }
  }
  getIsDone({ cells: e }) {
    const n = e[this.cellId2].candidates;
    for (const s of Yn(e[this.cellId1].candidates))
      if ((this.friendsFor1[s] & n) !== n) return !1;
    return !0;
  }
};
Kt = um(
  [
    $e(
      ["Pair", "AsymmetricalPair"],
      "The digits {digit1} and {digit2} in {cell1} and {cell2} are valid when {filterOrMapping(digit1, digit2)} evaluates to {true}, or when {filterOrMapping[digit1].has(digit2)}.",
      [
        [
          "filterOrMapping",
          "((d1: number, d2: number) => boolean) | DigitSet[]",
        ],
        ["cell1", K.Cell],
        ["cell2", K.Cell],
      ]
    ),
  ],
  Kt
);
var pm = Object.defineProperty,
  fm = Object.getOwnPropertyDescriptor,
  hm = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? fm(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && pm(e, n, o), o;
  };
const mm = new an((t, e) => {
  let n = 0;
  for (const s of t)
    e + s <= me.maxDigit && (n |= 1 << (e + s)),
      e - s >= me.minDigit && (n |= 1 << (e - s));
  return n;
}, Wt.Number);
let jl = class extends Kt {
  constructor(e, n, s, o) {
    n = Et(n);
    super(e, mm.getFriends(n), s, o);
    L(this, "differences");
    L(this, "cellId1");
    L(this, "cellId2");
    (this.differences = n), (this.cellId1 = s), (this.cellId2 = o);
  }
  validate({ cells: e }) {
    const n = e[this.cellId1].value,
      s = e[this.cellId2].value;
    return n === void 0 ||
      s === void 0 ||
      this.differences.includes(Math.abs(n - s))
      ? Me
      : {
          valid: !1,
          message: `unable to make ${Ee.naming.getCellsDescription(
            this.cellIds
          )} have a difference of exactly ${At(this.differences, "or")}`,
        };
  }
};
jl = hm(
  [
    $e(
      "Difference",
      "The difference between the values at {cell1} and {cell2} must be exactly {difference}.",
      [
        ["difference", K.NumberOrNumberArray],
        ["cell1", K.Cell],
        ["cell2", K.Cell],
      ]
    ),
  ],
  jl
);
var gm = Object.defineProperty,
  vm = Object.getOwnPropertyDescriptor,
  ym = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? vm(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && gm(e, n, o), o;
  };
let Ir = class extends Pe {
  constructor(e, n, s = zs.ExtraRegion) {
    super(e, n);
    L(this, "houseType");
    L(this, "seenIds", new Map());
    this.houseType = s;
    for (const o of n)
      this.seenIds.set(
        o,
        n.filter((r) => r !== o)
      );
  }
  get validateDuringSolve() {
    return !0;
  }
  getSeenCells(e, n) {
    return this.seenIds.get(n);
  }
  validate({ cells: e }) {
    let n = Gs;
    for (let s = 0; s < this.cellIds.length; s++) {
      const o = this.cellIds[s];
      n &= ~e[o].candidates;
    }
    return n !== 0 || this.cellIds.length !== me.digitCount
      ? {
          valid: !1,
          message: `unable to place ${Ee.naming.getDigitSetDescription(n)} in ${
            this.name
          }`,
        }
      : Me;
  }
};
Ir = ym(
  [
    $e("House", "Every digit must appear exactly once in {cells}.", [
      ["cells", K.CellArray],
    ]),
  ],
  Ir
);
var Cm = Object.defineProperty,
  wm = Object.getOwnPropertyDescriptor,
  bm = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? wm(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Cm(e, n, o), o;
  };
let Ul = class extends Pe {
  constructor(e, n) {
    super(e, n);
    L(this, "seenIds", new Map());
    for (const s of n)
      this.seenIds.set(
        s,
        n.filter((o) => o !== s)
      );
  }
  *initialize(e) {
    this.cellIds.length === me.digitCount
      ? yield On(this, new Ir(this.name, this.cellIds))
      : yield* super.initialize(e);
  }
  *update(e) {
    const n = new Mt();
    for (const s of this.cellIds) n.union(e.cells[s].candidates);
    n.size < this.cellIds.length &&
      (yield gt(
        `unable to place ${this.cellIds.length} different values in ${this.name}`,
        this.cellIds
      ));
  }
  getSeenCells(e, n) {
    return this.seenIds.get(n);
  }
};
Ul = bm(
  [
    $e(
      "DifferentDigits",
      "Every cell of {cells} must have a different digit from the rest.",
      [["cells", K.CellArray]]
    ),
  ],
  Ul
);
var km = Object.defineProperty,
  _m = Object.getOwnPropertyDescriptor,
  $m = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? _m(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && km(e, n, o), o;
  };
let Ta = class extends Tn {
  constructor(t, e) {
    super(t, e, () => {
      const n = [];
      return (
        e.length === 2
          ? n.push(new jl(t, 1, e[0], e[1]))
          : e.length === me.digitCount
          ? n.push(new Ir(t, e))
          : (n.push(new Vl(t, e)), n.push(new Ul(t, e))),
        n
      );
    });
  }
};
Ta = $m(
  [
    $e(
      "ConsecutiveDigitsSet",
      "All digits within {cells} must make a set of consecutive digits, without repeats.",
      [["cells", K.CellArray]]
    ),
  ],
  Ta
);
var Sm = Object.defineProperty,
  Im = Object.getOwnPropertyDescriptor,
  xm = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Im(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Sm(e, n, o), o;
  };
let Hl = class extends Pe {
  constructor(e, n, s, o) {
    super(e, [s, ...o]);
    L(this, "digitsName");
    (this.digits = n),
      (this.counterCell = s),
      (this.targetCells = o),
      (this.digitsName = Ee.naming.getDigitFilterDescription(n));
  }
  get validateDuringSolve() {
    return !0;
  }
  validate({ cells: e }) {
    let n = 0,
      s = 0;
    const o = $t(e[this.counterCell].candidates),
      r = Ot(e[this.counterCell].candidates);
    for (const l of this.targetCells) {
      const i = e[l];
      if ((this.digits & i.candidates) === i.candidates && (n++, n > r))
        return {
          valid: !1,
          message: `${this.name} counts at least ${n} cells containing ${this.digitsName} `,
        };
      i.candidates & this.digits && s++;
    }
    return s < o
      ? {
          valid: !1,
          message: `${this.name} counts at most ${s} cells containing ${this.digitsName}`,
        }
      : Me;
  }
};
Hl = xm(
  [
    $e(
      "CountDigits",
      "The digit in {counterCell} must equal the amount of occurrences of digits from {digits}.",
      [
        ["digits", K.DigitSet],
        ["counterCell", K.Cell],
        ["targetCells", K.CellArray],
      ]
    ),
  ],
  Hl
);
var Dm = Object.defineProperty,
  Mm = Object.getOwnPropertyDescriptor,
  Am = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Mm(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Dm(e, n, o), o;
  };
let Va = class extends Tn {
  constructor(t, e, n, s) {
    super(t, s, () => new Hl(t, 1 << e, n, s));
  }
};
Va = Am(
  [
    $e(
      "CountDigit",
      "The digit in {counterCell} must equal the amount of occurrences of {digit} in {targetCells}",
      [
        ["digit", K.Number],
        ["counterCell", K.Cell],
        ["targetCells", K.CellArray],
      ]
    ),
  ],
  Va
);
var Pm = Object.defineProperty,
  Lm = Object.getOwnPropertyDescriptor,
  Em = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Lm(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Pm(e, n, o), o;
  };
let ja = class extends Pe {
  constructor(t, e) {
    super(t, e.flat()), (this.cellGroups = e);
  }
  get validateDuringSolve() {
    return !0;
  }
  validate({ cells: t }) {
    const e = this.cellGroups.filter((s) =>
      s.every((o) => t[o].value !== void 0)
    );
    if (e.length < 2) return Me;
    const n = new Map();
    for (const s of e) {
      const o = this.getMakeUp(t, s);
      if (!n.has(o)) n.set(o, s);
      else
        return {
          valid: !1,
          cells: s,
          message: `the make-ups of ${Ee.naming.getCellsDescription(
            s
          )} and ${Ee.naming.getCellsDescription(n.get(o))} are the same`,
        };
    }
    return Me;
  }
  getMakeUp(t, e) {
    return e
      .map((n) => t[n].value)
      .sort()
      .join("");
  }
};
ja = Em(
  [
    $e(
      "DifferentCombinations",
      "Every group of cells of {cellGroups} must have a distinct make-up of digits.",
      [["cellGroups", "CellId[][]"]]
    ),
  ],
  ja
);
var Fm = Object.defineProperty,
  Bm = Object.getOwnPropertyDescriptor,
  zm = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Bm(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Fm(e, n, o), o;
  };
let Wl = class extends Pe {
  constructor(e, n, s) {
    super(e, s);
    L(this, "groups");
    this.groups = n.map((o) => +o);
  }
  *initialize(e) {
    const n = this.groups.reduce((s, o) => o | s);
    n !== Gs && (yield qt(n, this.cellIds)), yield* this.update(e);
  }
  *update({ cells: e }) {
    for (let n = 0; n < this.cellIds.length; n++) {
      const s = e[this.cellIds[n]].candidates;
      for (const o of this.groups)
        if ((s & o) === s)
          for (let r = 0; r < this.cellIds.length; r++)
            r !== n && (yield Kr(o, this.cellIds[r]));
    }
  }
  getIsDone({ cells: e }) {
    for (let n = 0; n < this.cellIds.length; n++) {
      const s = e[this.cellIds[n]].candidates;
      for (let o = n + 1; o < this.cellIds.length; o++) {
        const r = e[this.cellIds[n]].candidates;
        if (s & r) return !1;
      }
    }
    return !0;
  }
};
Wl = zm(
  [
    $e("DifferentGroups", "$1", [
      ["groups", K.DigitSetArray],
      ["cells", K.CellArray],
    ]),
  ],
  Wl
);
var Rm = Object.defineProperty,
  Om = Object.getOwnPropertyDescriptor,
  Nm = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Om(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Rm(e, n, o), o;
  };
let Zl = class extends Pe {
  constructor(e, n, s) {
    super(e, Et(s));
    L(this, "candidates");
    this.candidates = +n;
  }
  *initialize() {
    yield qt(this.candidates, this.cellIds), yield vn(this);
  }
};
Zl = Nm(
  [
    $e(
      "PredefinedCandidates",
      "The value of {cellOrCells} must be one of {candidates}.",
      [
        ["candidates", K.DigitSet],
        ["cellOrCells", K.CellArray],
      ]
    ),
  ],
  Zl
);
var Tm = Object.defineProperty,
  Vm = Object.getOwnPropertyDescriptor,
  jm = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Vm(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Tm(e, n, o), o;
  };
let Gl = class extends Pe {
  constructor(e, n, s) {
    super(e, s);
    L(this, "groups");
    this.groups = n.map((o) => +o);
  }
  *update(e) {
    for (const n of this.groups) {
      const s = this.getOnlyPossibleIndexForGroup(e, n);
      if (s === !1) {
        yield gt(`impossible to satisfy ${this.name}`, this.cellIds);
        return;
      } else s !== void 0 && (yield it(n, s));
    }
  }
  getOnlyPossibleIndexForGroup(e, n) {
    let s;
    for (let o = 0; o < this.cellIds.length; o++) {
      const r = this.cellIds[o];
      if (e.cells[r].candidates & n) {
        if (s !== void 0) return;
        s = r;
      }
    }
    return s ?? !1;
  }
};
Gl = jm(
  [
    $e(
      "RequiredGroups",
      "\n".join([
        `For every group from {groups}, a digit must appear at least once in {cells}. E.g. If the groups are 123, 456 and 789, then {cells} must be at least 3 cells, and one digit of every group is assigned to a cell. `,
        `**Note:** currently only works properly when the groups do not overlap.`,
      ]),
      [
        ["groups", K.DigitSetArray],
        ["cells", K.CellArray],
      ]
    ),
  ],
  Gl
);
var Um = Object.defineProperty,
  Hm = Object.getOwnPropertyDescriptor,
  Wm = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Hm(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Um(e, n, o), o;
  };
let Ua = class extends Tn {
  constructor(t, e, n) {
    super(t, n, () => {
      const s = [];
      if (n.length === 1) {
        const o = e.reduce((r, l) => r | l, 0);
        s.push(new Zl(t, o, n[0]));
      } else
        n.length >= e.length && s.push(new Gl(t, e, n)),
          n.length <= e.length && s.push(new Wl(t, e, n));
      return s;
    });
  }
};
Ua = Wm(
  [
    $e(
      "DiverseGroups",
      "\n".join([
        `A digit from every group from {groups} must appear at least once in {cells}, or from different groups if there are less cells than there are groups. `,
        `**Note:** currently only works properly when the groups do not overlap.`,
      ]),
      [
        ["groups", K.DigitSetArray],
        ["cells", K.CellArray],
      ]
    ),
  ],
  Ua
);
var Zm = Object.defineProperty,
  Gm = Object.getOwnPropertyDescriptor,
  qm = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Gm(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Zm(e, n, o), o;
  };
let Ha = class extends Pe {
  constructor(e, n, s) {
    super(e, Et(s));
    L(this, "forbiddenCandidates");
    this.forbiddenCandidates = +n;
  }
  *initialize() {
    yield qt(Gs - this.forbiddenCandidates, this.cellIds), yield vn(this);
  }
};
Ha = qm(
  [
    $e(
      "ForbiddenCandidates",
      "The value of {cellOrCells} cannot be any of {candidates}.",
      [
        ["candidates", K.DigitSet],
        ["cellOrCells", K.CellOrCellArray],
      ]
    ),
  ],
  Ha
);
var Km = Object.defineProperty,
  Xm = Object.getOwnPropertyDescriptor,
  Ym = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Xm(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Km(e, n, o), o;
  };
const Jm = new an((t, e) => {
  let n = 0;
  for (let s = e + 1; s <= me.maxDigit; s++) n |= 1 << s;
  return n;
}, Wt.None);
let ql = class extends Kt {
  constructor(t, e, n) {
    const s = Jm.getFriends();
    super(t, s, e, n), (this.lesserCellId = e), (this.greaterCellId = n);
  }
  validate({ cells: t }) {
    const e = $t(t[this.lesserCellId].candidates),
      n = Ot(t[this.greaterCellId].candidates);
    return e < n
      ? Me
      : {
          valid: !1,
          message: `unable to make ${Ee.naming.getCellName(
            this.lesserCellId
          )} be less than ${Ee.naming.getCellName(this.greaterCellId)}`,
        };
  }
};
ql = Ym(
  [
    $e(
      ["GreaterThan", "LessThan"],
      "The digit in {lesserCell} must be less than the one in {greaterCell}",
      [
        ["lesserCell", K.Cell],
        ["greaterCell", K.Cell],
      ]
    ),
  ],
  ql
);
var Qm = Object.defineProperty,
  eg = Object.getOwnPropertyDescriptor,
  tg = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? eg(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Qm(e, n, o), o;
  };
const ng = new an((t, e) => {
  let n = 0;
  for (let s = e; s <= me.maxDigit; s++) n |= 1 << s;
  return n;
}, Wt.None);
let Kl = class extends Kt {
  constructor(t, e, n) {
    const s = ng.getFriends();
    super(t, s, e, n), (this.lesserCellId = e), (this.greaterCellId = n);
  }
  *initialize(t) {
    t.getCellsCanHaveRepeats(this.cellIds)
      ? yield* super.initialize(t)
      : yield On(
          this,
          new ql(this.name, this.lesserCellId, this.greaterCellId)
        );
  }
  validate({ cells: t }) {
    const e = t[this.lesserCellId].value,
      n = t[this.greaterCellId].value;
    return e === void 0 || n === void 0 || e <= n
      ? Me
      : {
          valid: !1,
          message: `unable to make ${Ee.naming.getCellName(
            this.lesserCellId
          )} be less than or equal to ${Ee.naming.getCellName(
            this.greaterCellId
          )}`,
        };
  }
};
Kl = tg(
  [
    $e(
      "GreaterThanOrEquals",
      "The digit in {greaterCell} must be greater than or equal to the one in {lesserCell}",
      [
        ["lesserCell", K.Cell],
        ["greaterCell", K.Cell],
      ]
    ),
  ],
  Kl
);
var sg = Object.defineProperty,
  og = Object.getOwnPropertyDescriptor,
  rg = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? og(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && sg(e, n, o), o;
  };
let Wa = class extends Pe {
  constructor(e, n, s, o) {
    super(e, [s, ...o]);
    L(this, "allowRepeats", !0);
    (this.valueToIndex = n),
      (this.indexerCellId = s),
      (this.indexingCellIds = o);
  }
  *initialize(e) {
    if (
      ((this.allowRepeats = e.getCellsCanHaveRepeats(this.indexingCellIds)),
      !this.allowRepeats)
    ) {
      const n = this.indexingCellIds.indexOf(this.indexerCellId);
      n !== -1 &&
        this.valueToIndex !== n + 1 &&
        (yield Ts(this.valueToIndex, this.indexerCellId));
    }
    yield* super.initialize(e);
  }
  *update(e) {
    yield* this.updateIndexerCandidates(e),
      yield* this.updateFromIndexer(e),
      e.cells[this.indexerCellId].value && (yield vn(this));
  }
  *updateIndexerCandidates(e) {
    let n = 0;
    for (let s = 0; s < this.indexingCellIds.length; s++) {
      const o = s + 1,
        r = this.indexingCellIds[s];
      e.cells[r].candidates & (1 << this.valueToIndex) && (n |= 1 << o);
    }
    yield it(n, this.indexerCellId);
  }
  *updateFromIndexer(e) {
    if (e.cells[this.indexerCellId].value) {
      const n = e.cells[this.indexerCellId].value - 1;
      if (n >= this.indexingCellIds.length) {
        yield gt(`impossible to satisfy ${this.name}`);
        return;
      }
      yield it(1 << this.valueToIndex, this.indexingCellIds[n]);
    }
  }
};
Wa = rg(
  [
    $e(
      "Index",
      "The value of {indexerCell} must be the (1-based) index of an appearance of {valueToIndex} in the sequence of cells {cells}.",
      [
        ["valueToIndex", K.Number],
        ["indexerCell", K.Cell],
        ["cells", K.CellArray],
      ]
    ),
  ],
  Wa
);
var lg = Object.defineProperty,
  ig = Object.getOwnPropertyDescriptor,
  ag = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? ig(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && lg(e, n, o), o;
  };
let Za = class extends Pe {
  constructor(e, n, s, o) {
    super(e, o);
    L(this, "value");
    L(this, "maxCount");
    (this.value = n), (this.maxCount = s);
  }
  getSeenCells(e, n) {
    const s = e.cells[n].value;
    if (s !== this.value) return [];
    let o = 0;
    for (const i of this.cellIds) e.cells[i].value === s && o++;
    if (o < this.maxCount) return [];
    const r = new Set();
    let l = 0;
    for (const i of this.cellIds)
      r.add(i),
        e.cells[i].value === s && (l++, l <= this.maxCount && r.delete(i));
    return r;
  }
  getIsDone({ cells: e }) {
    let n = 0;
    for (const s of this.cellIds) e[s].candidates & (1 << this.value) && n++;
    return n < this.maxCount;
  }
};
Za = ag(
  [
    $e(
      "MaxDigitCount",
      "The digit {value} must appear at most {maxCount} times in {cells}.",
      [
        ["value", K.Number],
        ["maxCount", K.Number],
        ["cells", K.CellArray],
      ]
    ),
  ],
  Za
);
var ug = Object.defineProperty,
  cg = Object.getOwnPropertyDescriptor,
  dg = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? cg(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && ug(e, n, o), o;
  };
const pg = new an((t, e) => {
  let n = 0;
  const s = Math.max(me.minDigit, e - t),
    o = Math.min(me.maxDigit, e + t);
  for (let r = s; r <= o; r++) n |= 1 << r;
  return n;
}, Wt.Number);
let Ga = class extends Kt {
  constructor(t, e, n, s) {
    super(t, pg.getFriends(e), n, s),
      (this.maxDifference = e),
      (this.cellId1 = n),
      (this.cellId2 = s);
  }
  validate({ cells: t }) {
    const e = t[this.cellId1].value,
      n = t[this.cellId2].value;
    return e === void 0 || n === void 0 || Math.abs(e - n) <= this.maxDifference
      ? Me
      : {
          valid: !1,
          message: `unable to keep a maximum difference of ${
            this.maxDifference
          } between cells ${Ee.naming.getCellsDescription(this.cellIds)}`,
        };
  }
};
Ga = dg(
  [
    $e(
      "MaximumDifference",
      "The difference between the values of {cell1} and {cell2} must be at most {maxDifference}.",
      [
        ["maxDifference", K.Number],
        ["cell1", K.Cell],
        ["cell2", K.Cell],
      ]
    ),
  ],
  Ga
);
var fg = Object.defineProperty,
  hg = Object.getOwnPropertyDescriptor,
  mg = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? hg(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && fg(e, n, o), o;
  };
const gg = new an((t, e) => {
  let n = 0;
  const s = e - t,
    o = e + t;
  for (let r = me.minDigit; r <= s; r++) n |= 1 << r;
  for (let r = o; r <= me.maxDigit; r++) n |= 1 << r;
  return n;
}, Wt.Number);
let qa = class extends Kt {
  constructor(t, e, n, s) {
    super(t, gg.getFriends(e), n, s),
      (this.minDifference = e),
      (this.cellId1 = n),
      (this.cellId2 = s);
  }
  validate({ cells: t }) {
    const e = t[this.cellId1].value,
      n = t[this.cellId2].value;
    return e === void 0 || n === void 0 || Math.abs(e - n) >= this.minDifference
      ? Me
      : {
          valid: !1,
          message: `unable to keep a minimum difference of ${
            this.minDifference
          } between cells ${Ee.naming.getCellsDescription(this.cellIds)}`,
        };
  }
};
qa = mg(
  [
    $e(
      "MinimumDifference",
      "The difference between the values of {cell1} and {cell2} must be at least {minDifference}.",
      [
        ["minDifference", K.Number],
        ["cell1", K.Cell],
        ["cell2", K.Cell],
      ]
    ),
  ],
  qa
);
var vg = Object.defineProperty,
  yg = Object.getOwnPropertyDescriptor,
  Cg = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? yg(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && vg(e, n, o), o;
  };
let Ka = class extends Pe {
  constructor(t, e, n) {
    super(t, [...e, ...n]), (this.endPoints = e), (this.midPoints = n);
  }
  *update(t) {
    const e = $t(t.cells[this.endPoints[0]].candidates),
      n = Ot(t.cells[this.endPoints[0]].candidates),
      s = $t(t.cells[this.endPoints[1]].candidates),
      o = Ot(t.cells[this.endPoints[1]].candidates);
    if (!(n >= s && o >= e)) {
      const l = n < s ? Ve(n + 1, s - 1) : Ve(o + 1, e - 1);
      yield _o(fn(l), this.midPoints);
    }
    for (const l of this.midPoints) {
      const i = t.cells[l].value;
      i !== void 0 &&
        (i > n && (yield it(fn(Ve(me.minDigit, i)), this.endPoints[1])),
        i > o && (yield it(fn(Ve(me.minDigit, i)), this.endPoints[0])),
        i < e && (yield it(fn(Ve(i, me.maxDigit)), this.endPoints[1])),
        i < s && (yield it(fn(Ve(i, me.maxDigit)), this.endPoints[0])));
    }
  }
  getIsDone({ cells: t }) {
    return (
      t[this.endPoints[0]].value !== void 0 &&
      t[this.endPoints[1]].value !== void 0
    );
  }
};
Ka = Cg(
  [
    $e(
      "NegativeBetween",
      "The digits on all {midPoints} must not be between the digits on the {endPoints}.",
      [
        ["endPoints", { type: K.CellArray, amount: 2 }],
        ["midPoints", K.CellArray],
      ]
    ),
  ],
  Ka
);
var wg = Object.defineProperty,
  bg = Object.getOwnPropertyDescriptor,
  kg = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? bg(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && wg(e, n, o), o;
  };
const _g = new an((t, e) => {
  const n = Ee.digits.createFullDigitSet();
  for (const s of t) n.delete(e + s), n.delete(e - s);
  return n.valueOf();
}, Wt.Numbers);
let Xa = class extends Kt {
  constructor(e, n, s, o) {
    super(e, _g.getFriends(n), s, o);
    L(this, "differences");
    this.differences = n;
  }
  validate({ cells: e }) {
    const n = e[this.cellId1].value,
      s = e[this.cellId2].value;
    if (n === void 0 || s === void 0) return Me;
    for (const o of this.differences)
      if (Math.abs(n - s) === o)
        return {
          valid: !1,
          message: `${Ee.naming.getCellsDescription(
            this.cellIds
          )} are ${o} different, which is not allowed`,
        };
    return Me;
  }
};
Xa = kg(
  [
    $e(
      "NegativeDifference",
      "The difference between the values of {cell1} and {cell2} must not be any of {differences}.",
      [
        ["differences", K.NumberArray],
        ["cell1", K.Cell],
        ["cell2", K.Cell],
      ]
    ),
  ],
  Xa
);
var $g = Object.defineProperty,
  Sg = Object.getOwnPropertyDescriptor,
  Ig = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Sg(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && $g(e, n, o), o;
  };
let Ya = class extends Pe {
  constructor(t, e, n, s) {
    super(t, [n, ...s]),
      (this.valueToNotIndex = e),
      (this.indexerCellId = n),
      (this.indexingCells = s);
  }
  *onValueSet(t, e, n) {
    if (e === this.indexerCellId)
      yield Ts(this.valueToNotIndex, this.indexingCells[n - 1]), yield vn(this);
    else if (n === this.valueToNotIndex) {
      const s = this.indexingCells.indexOf(e) + 1;
      yield Ts(s, this.indexerCellId);
    }
  }
};
Ya = Ig(
  [
    $e(
      "NegativeIndex",
      "The value of {indexerCell} must **not** be the (1-based) index of {valueToNotIndex} in the sequence of cells {cells}.",
      [
        ["valueToNotIndex", K.Number],
        ["indexerCell", K.Cell],
        ["cells", K.CellArray],
      ]
    ),
  ],
  Ya
);
var xg = Object.defineProperty,
  Dg = Object.getOwnPropertyDescriptor,
  Mg = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Dg(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && xg(e, n, o), o;
  };
const Ag = new an((t, e) => {
  const n = Ee.digits.createFullDigitSet();
  for (const s of t)
    e % s === 0 && n.delete(e / s), e * s <= me.maxDigit && n.delete(e * s);
  return n.valueOf();
}, Wt.Numbers);
let Ja = class extends Kt {
  constructor(e, n, s, o) {
    n = Et(n);
    super(e, Ag.getFriends(n), s, o);
    L(this, "ratios");
    this.ratios = n;
  }
  validate({ cells: e }) {
    const n = e[this.cellId1].value,
      s = e[this.cellId2].value;
    if (n === void 0 || s === void 0) return Me;
    for (const o of this.ratios)
      if (n * o === s || s * o === n)
        return {
          valid: !1,
          message: `${Ee.naming.getCellsDescription(
            this.cellIds
          )} form a disallowed ratio of 1 : ${o}`,
        };
    return Me;
  }
};
Ja = Mg(
  [
    $e(
      "NegativeRatio",
      "The ratio of the values of {cell1} and {cell2} (either way) must not be any of {ratios}.",
      [
        ["ratios", K.NumberArray],
        ["cell1", K.Cell],
        ["cell2", K.Cell],
      ]
    ),
  ],
  Ja
);
class Pg extends Pe {
  constructor(n, s, o) {
    super(n, o);
    L(this, "sums");
    this.sums = s;
  }
  get validateDuringSolve() {
    return !0;
  }
  validate({ cells: n }) {
    if (!this.cellIds.every((o) => n[o].value !== void 0)) return Me;
    let s = 0;
    for (const o of this.cellIds) s += n[o].value;
    return this.sums.includes(s)
      ? {
          valid: !1,
          message: `${Ee.naming.getCellsDescription(
            this.cellIds
          )} must not sum to ${s}`,
        }
      : Me;
  }
}
const Lg = new an((t, e) => {
  const n = Ee.digits.createFullDigitSet();
  for (const s of t) s >= e && n.delete(s - e);
  return n.valueOf();
}, Wt.Numbers);
class Eg extends Kt {
  constructor(n, s, o, r) {
    super(n, Lg.getFriends(s), o, r);
    L(this, "sums");
    this.sums = s;
  }
  validate({ cells: n }) {
    const s = n[this.cellId1].value,
      o = n[this.cellId2].value;
    if (s === void 0 || o === void 0) return Me;
    for (const r of this.sums)
      if (s + o === r)
        return {
          valid: !1,
          message: `${Ee.naming.getCellsDescription(
            this.cellIds
          )} must not sum to ${r}`,
        };
    return Me;
  }
}
var Fg = Object.defineProperty,
  Bg = Object.getOwnPropertyDescriptor,
  zg = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Bg(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Fg(e, n, o), o;
  };
let Qa = class extends Tn {
  constructor(t, e, n) {
    super(t, n, () =>
      n.length === 2 ? new Eg(t, e, n[0], n[1]) : new Pg(t, e, n)
    );
  }
};
Qa = zg(
  [
    $e(
      "NegativeSum",
      "The digits within {cells} must not sum to any of {sums}.",
      [
        ["sums", K.NumberArray],
        ["cells", K.CellArray],
      ]
    ),
  ],
  Qa
);
class Rg extends Pe {
  constructor(n, s, o) {
    super(n, o);
    L(this, "product");
    this.product = s;
  }
  *update(n) {
    const { cellIds: s, product: o } = this;
    let r = o,
      l = 1,
      i = 1;
    for (const u of s) {
      const p = n.cells[u].value;
      if (p !== void 0) {
        if (r % p !== 0) {
          yield gt(`cannot satisfy ${this.name}`, this.cellIds);
          return;
        }
        (r /= p), (l *= p), (i = l);
      }
    }
    const a = Ee.digits.createFilteredDigitSet((u) => r % u === 0);
    for (const u of s) {
      if (n.cells[u].value !== void 0) continue;
      let p = n.cells[u].candidates;
      if (((p &= +a), yield it(p, u), (l *= $t(p)), (i *= Ot(p)), l > o)) {
        yield gt(`${this.name} has a product of at least ${l}`, this.cellIds);
        return;
      }
    }
    i < o &&
      (yield gt(`${this.name} has a product of at most ${i}`, this.cellIds));
  }
}
var Og = Object.defineProperty,
  Ng = Object.getOwnPropertyDescriptor,
  Tg = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Ng(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Og(e, n, o), o;
  };
let xr = class extends Pe {
  constructor(e, n, s) {
    super(e, s);
    L(this, "values");
    L(this, "repeatCounts", new Map());
    this.values = n;
    for (const o of n)
      this.repeatCounts.has(o) || this.repeatCounts.set(o, -1),
        this.repeatCounts.set(o, this.repeatCounts.get(o) + 1);
    for (const [o, r] of this.repeatCounts)
      r === 0 && this.repeatCounts.delete(o);
  }
  get validateDuringSolve() {
    return !0;
  }
  *update({ cells: e }) {
    const n = [],
      s = this.values.slice();
    for (const o of this.cellIds) {
      const r = e[o].value;
      r !== void 0 ? Pn(s, r) : n.push(o);
    }
    n.length === s.length && (yield qt(fn(s), n));
  }
  validate({ cells: e }) {
    const n = this.values.slice(),
      s = fn(this.values);
    for (const r of this.cellIds)
      for (const l of Yn(e[r].candidates & s))
        if ((Pn(n, l), n.length === 0)) return Me;
    let o;
    return (
      this.repeatCounts.size > 0 ? (o = `enough ${At(n)}s`) : (o = At(n)),
      { valid: !1, message: `unable to place ${o} in ${this.name}` }
    );
  }
};
xr = Tg(
  [
    $e(
      "RequiredDigits",
      "Every digit of {values} must be assigned a unique cell of {cells}. Requiring a digit to repeat can be achieved by repeating that digit in {values}.",
      [
        ["values", K.NumberArray],
        ["cells", K.CellArray],
      ]
    ),
  ],
  xr
);
var Vg = Object.defineProperty,
  jg = Object.getOwnPropertyDescriptor,
  Ug = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? jg(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Vg(e, n, o), o;
  };
let eu = class extends Tn {
  constructor(t, e, n) {
    super(t, n, () =>
      Array.isArray(e)
        ? new Hg(t, e, n)
        : e > 0
        ? new Rg(t, e, n)
        : new xr(t, [0], n)
    ),
      (this.name = t),
      (this.productOrProducts = e),
      (this.cellIds = n);
  }
};
eu = Ug(
  [
    $e(
      "Product",
      "The product of the digits in {cells} must equal to {productOrProducts}.",
      [
        ["productOrProducts", K.NumberOrNumberArray],
        ["cells", K.CellArray],
      ]
    ),
  ],
  eu
);
class Hg extends Pe {
  constructor(n, s, o) {
    super(n, o);
    L(this, "products");
    this.products = s;
  }
  get validateDuringSolve() {
    return !0;
  }
  *initialize() {
    const n = new Mt();
    n.add(1);
    for (const s of this.products)
      for (let o = me.minDigit; o <= me.maxDigit; o++)
        (s === 0 || s % o === 0) && n.add(o);
    yield qt(+n, this.cellIds);
  }
  validate({ cells: n }) {
    if (!this.cellIds.every((o) => n[o].value !== void 0)) return Me;
    let s = 1;
    for (const o of this.cellIds) s *= n[o].value;
    return this.products.includes(s)
      ? Me
      : {
          valid: !1,
          message: `the product of ${Ee.naming.getCellsDescription(
            this.cellIds
          )} is ${s} and is not allowed`,
        };
  }
}
var Wg = Object.defineProperty,
  Zg = Object.getOwnPropertyDescriptor,
  Gg = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Zg(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Wg(e, n, o), o;
  };
const qg = new an((t, e) => {
  let n = 0;
  for (const s of t)
    e * s <= me.maxDigit && (n |= 1 << (e * s)),
      e % s === 0 && (n |= 1 << (e / s)),
      e === 0 && s === 0 && (n = Gs);
  return n;
}, Wt.Number);
let tu = class extends Kt {
  constructor(e, n, s, o) {
    n = Et(n);
    super(e, qg.getFriends(n), s, o);
    L(this, "ratios");
    this.ratios = n;
  }
  validate({ cells: e }) {
    const n = e[this.cellId1].value,
      s = e[this.cellId2].value;
    if (n === void 0 || s === void 0) return Me;
    for (const r of this.ratios) if (n * r === s || s * r === n) return Me;
    const o =
      this.ratios.length === 1
        ? `a 1 : ${this.ratios[0]} ratio`
        : `one of the following ratios: ${At(
            this.ratios.map((r) => `1:${r}`),
            "or"
          )}`;
    return {
      valid: !1,
      message: `unable to make ${Ee.naming.getCellsDescription(
        this.cellIds
      )} form ${o}`,
    };
  }
};
tu = Gg(
  [
    $e(
      "RatioComponent",
      "The ratio of the values of {cell1} and {cell2} (either way) must equal {ratioOrRatios}.",
      [
        ["ratioOrRatios", K.NumberOrNumberArray],
        ["cell1", K.Cell],
        ["cell2", K.Cell],
      ]
    ),
  ],
  tu
);
var Kg = Object.defineProperty,
  Xg = Object.getOwnPropertyDescriptor,
  Yg = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Xg(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Kg(e, n, o), o;
  };
let nu = class extends Pe {
  constructor(t, e) {
    super(t, e);
  }
  *initialize(t) {
    if (!this.validateConfiguration(t)) {
      yield gt(
        `check ${this.name} - one or more cloned cells are seeing each other`,
        this.cellIds
      );
      return;
    }
    const e = this.cellIds.find((n) => t.cells[n].value !== void 0);
    e !== void 0
      ? yield* this.onValueSet(t, e, t.cells[e].value)
      : yield* this.update(t);
  }
  *onValueSet(t, e, n) {
    for (const s of this.cellIds) s !== e && (yield U0(n, s));
  }
  *update(t) {
    let e = Gs;
    for (const n of this.cellIds) e &= t.cells[n].candidates;
    yield qt(e, this.cellIds);
  }
  validate({ cells: t }) {
    const e = this.cellIds.filter((r) => t[r].value !== void 0);
    if (e.length === 0) return Me;
    const n = e[0],
      s = t[n].value,
      o = e.find((r) => t[r].value !== s);
    return o !== void 0
      ? {
          valid: !1,
          message: `${Ee.naming.getCellName(
            o
          )} must have the same value as ${Ee.naming.getCellName(
            n
          )}, but it does not`,
        }
      : Me;
  }
  validateConfiguration(t) {
    const e = t.getCellsSeenByCell(this.cellIds[0]);
    return this.cellIds.filter((s) => e.has(s)).length === 0;
  }
};
nu = Yg(
  [
    $e("SameDigit", "Every cell of {cells} must have the same value.", [
      ["cells", K.CellArray],
    ]),
  ],
  nu
);
var Jg = Object.defineProperty,
  Qg = Object.getOwnPropertyDescriptor,
  ev = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Qg(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Jg(e, n, o), o;
  };
let su = class extends Pe {
  constructor(e, n, s) {
    super(e, s);
    L(this, "groups");
    this.groups = n.map((o) => +o);
  }
  *update({ cells: e }) {
    const n = new Set(this.groups);
    for (const o of this.cellIds) {
      const r = e[o].candidates;
      for (const l of n) r & l || n.delete(l);
    }
    let s = 0;
    for (const o of n) s |= o;
    yield qt(s, this.cellIds);
  }
};
su = ev(
  [
    $e(
      "SameGroup",
      "\n".join([
        `Every cell of {cells} must have a digit from the same group within {groups}. E.g. if the groups are the evens and the odds, then either every cell is even, or every cell is odd. `,
        `**Note:** currently only works properly when the groups do not overlap.`,
      ]),
      [
        ["groups", K.DigitSetArray],
        ["cells", K.CellArray],
      ]
    ),
  ],
  su
);
class Bi {
  constructor(e, n, s, o, r = Ee.naming.getCellsDescription(o)) {
    (this.state = e),
      (this.minimumSum = n),
      (this.maximumSum = s),
      (this.cellIds = o),
      (this.cellsName = r);
  }
  *updateCandidates(e, n) {
    e
      ? yield* this.updateCandidatesWithRepeats()
      : yield* this.updateCandidatesWithoutRepeats(n);
  }
  *updateCandidatesWithoutRepeats(e) {
    const { state: n, minimumSum: s, maximumSum: o, cellIds: r } = this;
    let l = s,
      i = o;
    const a = new Set(r);
    let u = 0;
    for (const g of r) {
      const v = n.cells[g].value;
      v !== void 0
        ? ((l -= v), (i -= v), a.delete(g))
        : (u |= n.cells[g].candidates);
    }
    if (a.size === 0) {
      l > 0 && (yield gt(`${this.cellsName} sums to less than ${s}`, r)),
        i < 0 && (yield gt(`${this.cellsName} sums to more than ${o}`, r));
      return;
    }
    l = Math.max(me.minDigit, l);
    const p = [];
    for (let g = l; g <= i; g++) {
      const v = Ee.sums
        .getCombinationsForSumWithoutRepeat(g, a.size)
        .map(($) => fn($))
        .filter(($) => ($ & u) === $);
      p.push(...v);
    }
    const m = p.reduce((g, v) => g | v, 0);
    e && Yr(m) === a.size && (e.value = !0), yield qt(m, a);
  }
  *updateCandidatesWithRepeats() {
    const { state: e, minimumSum: n, maximumSum: s, cellIds: o } = this;
    let r = n,
      l = s;
    const i = new Set(o);
    for (const a of o) {
      const u = e.cells[a].value;
      u !== void 0 && ((r -= u), (l -= u), i.delete(a));
    }
    for (const a of i) {
      const u = e.cells[a],
        p = this.getMinSum(e, i, a),
        m = this.getMaxSum(e, i, a);
      let g = 0;
      for (const v of Yn(u.candidates))
        (p + v > l || m + v < r) && (g |= 1 << v);
      yield Kr(g, a);
    }
  }
  getMinSum({ cells: e }, n, s) {
    let o = 0;
    for (const r of n) {
      if (r === s) continue;
      const l = e[r];
      o += l.value ?? ($t(l.candidates) || 0);
    }
    return o;
  }
  getMaxSum(e, n, s) {
    let o = 0;
    for (const r of n) {
      if (r === s) continue;
      const l = e.cells[r];
      o += l.value ?? (Ot(l.candidates) || 0);
    }
    return o;
  }
}
class ad {
  constructor(e, n, s, o) {
    (this.state = e),
      (this.minimumSum = n),
      (this.maximumSum = s),
      (this.cellIdsAndWeights = o);
  }
  *updateCandidates() {
    const {
      state: e,
      minimumSum: n,
      maximumSum: s,
      cellIdsAndWeights: o,
    } = this;
    let r = n,
      l = s;
    const i = new Map(o);
    for (const [a, u] of o) {
      const p = e.cells[a].value;
      p !== void 0 && ((r -= p * u), (l -= p * u), i.delete(a));
    }
    for (const [a, u] of i) {
      const p = e.cells[a],
        m = this.getMinSum(e, i, a),
        g = this.getMaxSum(e, i, a);
      let v = 0;
      for (const $ of Yn(p.candidates))
        (m + $ * u > l || g + $ * u < r) && (v |= 1 << $);
      yield Kr(v, a);
    }
  }
  getMinSum({ cells: e }, n, s) {
    let o = 0;
    for (const [r, l] of n) {
      if (r === s) continue;
      const i = e[r];
      o += (i.value ?? ($t(i.candidates) || 0)) * l;
    }
    return o;
  }
  getMaxSum(e, n, s) {
    let o = 0;
    for (const [r, l] of n) {
      if (r === s) continue;
      const i = e.cells[r];
      o += (i.value ?? (Ot(i.candidates) || 0)) * l;
    }
    return o;
  }
}
class tv extends Pe {
  constructor(n, s, o, r) {
    super(n, o);
    L(this, "sums");
    L(this, "repeat");
    L(this, "minSum");
    L(this, "maxSum");
    L(this, "sumsDescription");
    (this.sums = s),
      (this.repeat = r),
      (this.sumsDescription = At(this.sums, "or")),
      (this.minSum = Math.min(...this.sums)),
      (this.maxSum = Math.max(...this.sums));
  }
  get validateDuringSolve() {
    return !0;
  }
  *update(n) {
    yield* new Bi(
      n,
      this.minSum,
      this.maxSum,
      this.cellIds,
      this.name
    ).updateCandidates(this.repeat);
  }
  validate(n) {
    let s = 0;
    for (let o = 0; o < this.cellIds.length; o++) {
      const r = n.cells[this.cellIds[o]].value;
      if (r === void 0) return Me;
      s += r;
    }
    return this.sums.includes(s)
      ? Me
      : {
          valid: !1,
          message: `${this.name} cannot sum to ${this.sumsDescription}`,
        };
  }
}
class nv extends Pe {
  constructor(n, s, o, r, l) {
    super(n, r);
    L(this, "minSum");
    L(this, "maxSum");
    L(this, "repeat");
    L(this, "sumsDescription");
    (this.minSum = s),
      (this.maxSum = o),
      (this.repeat = l),
      (this.sumsDescription =
        this.minSum === this.maxSum
          ? this.minSum.toString()
          : `at least ${this.minSum} or at most ${this.maxSum}`);
  }
  get validateDuringSolve() {
    return !0;
  }
  *update(n) {
    const s = new Bi(n, this.minSum, this.maxSum, this.cellIds, this.name),
      o = { value: !1 };
    yield* s.updateCandidates(this.repeat, o), o.value && (yield vn(this));
  }
  validate({ cells: n }) {
    let s, o;
    if (this.repeat) {
      const r = Ee.sums.getExtremeSumsWithRepeat(
        this.cellIds.map((l) => n[l].candidates)
      );
      (s = r.minSum), (o = r.maxSum);
    } else {
      const r = Ee.sums.getExtremeSumsWithoutRepeat(
        this.cellIds.map((l) => n[l].candidates)
      );
      if (!r)
        return {
          valid: !1,
          message: `${this.name} cannot sum to ${this.sumsDescription}`,
        };
      (s = r.minSum), (o = r.maxSum);
    }
    return this.maxSum < s
      ? { valid: !1, message: `${this.name} sum(s) to at least ${s}` }
      : this.minSum > o
      ? { valid: !1, message: `${this.name} sum(s) to at most ${o}` }
      : Me;
  }
}
const sv = new an((t, e) => {
    let n = 0;
    for (const s of t) {
      const o = s - e;
      o !== e && o <= me.maxDigit && o >= me.minDigit && (n |= 1 << o);
    }
    return n;
  }, Wt.Number),
  ov = new an((t, e) => {
    let n = 0;
    for (const s of t) {
      const o = s - e;
      o <= me.maxDigit && o >= me.minDigit && (n |= 1 << o);
    }
    return n;
  }, Wt.Number);
class rv extends Kt {
  constructor(n, s, o, r, l) {
    const i = o ? ov.getFriends(s) : sv.getFriends(s);
    super(n, i, r, l);
    L(this, "sums");
    this.sums = s;
  }
  validate({ cells: n }) {
    const s = n[this.cellId1].value,
      o = n[this.cellId2].value;
    return s === void 0 || o === void 0 || this.sums.includes(s + o)
      ? Me
      : {
          valid: !1,
          message: `unable to make ${Ee.naming.getCellsDescription(
            this.cellIds
          )} sum to ${At(this.sums, "or")}`,
        };
  }
}
var lv = Object.defineProperty,
  iv = Object.getOwnPropertyDescriptor,
  av = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? iv(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && lv(e, n, o), o;
  };
let Dr = class extends Pe {
  constructor(e, n, s) {
    super(e, Array.from(s.keys()));
    L(this, "sums");
    L(this, "cellWeightPairs");
    L(this, "sumsDescription");
    L(this, "minSum");
    L(this, "maxSum");
    (this.sums = Et(n)),
      (this.cellWeightPairs = s),
      (this.sumsDescription = At(this.sums, "or")),
      (this.minSum = Math.min(...this.sums)),
      (this.maxSum = Math.max(...this.sums));
  }
  get validateDuringSolve() {
    return !0;
  }
  *update(e) {
    yield* new ad(
      e,
      this.minSum,
      this.maxSum,
      this.cellWeightPairs
    ).updateCandidates();
  }
  validate(e) {
    let n = 0;
    for (let s = 0; s < this.cellIds.length; s++) {
      const o = e.cells[this.cellIds[s]].value;
      if (o === void 0) return Me;
      n += o * this.cellWeightPairs.get(this.cellIds[s]);
    }
    return this.sums.includes(n)
      ? Me
      : {
          valid: !1,
          message: `${this.name} cannot sum to ${this.sumsDescription}`,
        };
  }
};
Dr = av(
  [
    $e(
      "WeightedSum",
      "\n".join([
        `The sums of every value of cell X in {cellWeightMapping}, multiplied by {cellWeightMapping.get(X)}, must sum to (one of) {sumOrSums}.`,
        `**Note:** to avoid floating point inaccuracies breaking this component, use whole numbers as weights. In case you want to do something like x+y/3=5, multiply it all such that you get 3x+y=15`,
      ]),
      [
        ["sumOrSums", K.NumberOrNumberArray],
        ["cellWeightMapping", "Map<CellId, number>"],
      ]
    ),
  ],
  Dr
);
var uv = Object.defineProperty,
  cv = Object.getOwnPropertyDescriptor,
  dv = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? cv(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && uv(e, n, o), o;
  };
let So = class extends Tn {
  constructor(t, e, n) {
    super(t, n, (s) => {
      if (((e = Et(e)), ki(n))) {
        const a = $i(n),
          u = Ns(n);
        return new Dr(t, e, new Map(u.map((p) => [p, a.get(p)])));
      }
      const o = !s.getCellsSeeEachOther(n);
      if (this.cellIds.length === 2) return new rv(t, e, o, n[0], n[1]);
      const { min: r, max: l, range: i } = pv(e);
      return i ? new nv(t, r, l, n, o) : new tv(t, e, n, o);
    });
  }
};
So = dv(
  [
    $e(
      "Sum",
      "The digits in {cells} must sum to (one of) {sumOrSums}. If a cell appears N times in {cells}, the value in that cell is counted N times.",
      [
        ["sumOrSums", K.NumberOrNumberArray],
        ["cells", K.CellArray],
      ]
    ),
  ],
  So
);
function pv(t) {
  const e = Math.min(...t),
    n = Math.max(...t),
    s = new Set(t);
  for (let o = e; o <= n; o++) if (!s.has(o)) return { range: !1 };
  return { range: !0, min: e, max: n };
}
var fv = Object.defineProperty,
  hv = Object.getOwnPropertyDescriptor,
  mv = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? hv(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && fv(e, n, o), o;
  };
let ou = class extends Pe {
  constructor(e, n) {
    super(e, [...new Set(n.map((s) => s.cells).flat())]);
    L(this, "groups");
    this.groups = n.map(gv);
  }
  get validateDuringSolve() {
    return !0;
  }
  *initialize(e) {
    for (const n of this.groups)
      "allowRepeats" in n.properties &&
        (n.properties.allowRepeats = !e.getCellsSeeEachOther(n.cells));
    yield* super.initialize(e);
  }
  *update(e) {
    let n = 0,
      s = 1 / 0;
    for (const o of this.groups) {
      const r = this.getExtremeValuesForGroup(e, o);
      if (r === null) {
        yield gt(`${o.name} has at least one repeated digit`, o.cells);
        return;
      }
      const { minimum: l, maximum: i } = r;
      (n = Math.max(n, l)), (s = Math.min(s, i));
    }
    if (s === n) yield* this.replaceWithSumConstraintComponents(e, s);
    else if (n <= s)
      for (const o of this.groups) yield* this.restrictGroup(e, o, n, s);
    else
      yield gt(
        `it’s not possible to satisfy equal sums for ${this.name}`,
        this.groups.flatMap((o) => o.cells)
      );
  }
  *replaceWithSumConstraintComponents(e, n) {
    const s = [];
    for (const o of this.groups)
      if (!o.cells.every((r) => e.cells[r].value !== void 0))
        if (o.properties.type === "asNumber") yield* this.setNumberGroup(n, o);
        else if (o.cells.length === 1) {
          const r =
            o.properties.type === "weighted"
              ? o.properties.weights.get(o.cells[0])
              : 1;
          if (n % r !== 0) {
            yield gt(`${n / r} is not a valid digit`, o.cells);
            return;
          }
          yield Rl(n / r, o.cells[0]);
        } else
          o.properties.type === "weighted"
            ? s.push(new Dr(o.name, n, o.properties.weights))
            : s.push(new So(o.name, n, o.cells));
    yield On(this, s);
  }
  *setNumberGroup(e, n) {
    for (const s of n.cells) yield Rl(e % 10, s), (e = Math.floor(e / 10));
  }
  validate(e) {
    let n = 0,
      s = 1 / 0;
    for (const o of this.groups) {
      const r = this.getExtremeValuesForGroup(e, o);
      if (r === null) return { valid: !1, message: `${o.name} has no values` };
      const { minimum: l, maximum: i } = r;
      (n = Math.max(n, l)), (s = Math.min(s, i));
    }
    return n > s
      ? {
          valid: !1,
          message: `it’s not possible to satisfy equal sums for ${this.name}`,
        }
      : Me;
  }
  getExtremeValuesForGroup(e, n) {
    if (n.properties.type === "asNumber")
      return this.getExtremeValuesForNumberGroup(e, n);
    {
      const s =
        n.properties.type === "weighted"
          ? n.cells.map((o) => n.properties.weights.get(o))
          : void 0;
      if (n.properties.allowRepeats) {
        const o = Ee.sums.getExtremeSumsWithRepeat(
          n.cells.map((r) => e.cells[r].candidates),
          s
        );
        return { minimum: o.minSum, maximum: o.maxSum };
      } else {
        const o = Ee.sums.getExtremeSumsWithoutRepeat(
          n.cells.map((r) => e.cells[r].candidates),
          s
        );
        return o === null ? null : { minimum: o.minSum, maximum: o.maxSum };
      }
    }
  }
  getExtremeValuesForNumberGroup(e, n) {
    let s = 0,
      o = 0;
    for (let r = 0; r < n.cells.length; r++) {
      const l = 10 ** r,
        i = e.cells[n.cells[r]],
        a = $t(i.candidates),
        u = Ot(i.candidates);
      (s += a * l), (o += u * l);
    }
    return { minimum: s, maximum: o };
  }
  *restrictGroup(e, n, s, o) {
    if (n.properties.type === "asNumber")
      for (let r = n.cells.length - 1; r >= 0; r--) {
        let l, i;
        if (r === n.cells.length - 1) {
          const u = 10 ** r;
          (l = Math.floor(s / u)), (i = Math.floor(o / u));
        } else (l = me.minDigit), (i = me.maxDigit);
        let a = 0;
        for (let u = l; u <= i; u++) a |= 1 << u;
        yield it(a, n.cells[r]);
      }
    else
      n.properties.type === "weighted"
        ? yield* new ad(e, s, o, n.properties.weights).updateCandidates()
        : yield* new Bi(e, s, o, n.cells, n.name).updateCandidates(
            n.properties.allowRepeats
          );
  }
};
ou = mv(
  [
    $e(
      "SameSum",
      "Every group of cells from {groups} must sum to the same value. Set {asNumber} to true, to interpret that group as a sequence that spells out a number (e.g. for arrows), where the least significant digit is at index 0. Use {weights} to set a custom weight for specific cells (see **WeightedSumComponent** for details)",
      [
        [
          "groups",
          {
            type: K.ObjectArray,
            fields: {
              name: K.String,
              cells: K.CellArray,
              "weights?": "Map<CellId, number>",
              "asNumber?": K.Boolean,
            },
          },
        ],
      ]
    ),
  ],
  ou
);
function gv(t) {
  if (t.weights) {
    const e = Ns(t.cells);
    return {
      name: t.name,
      cells: e,
      properties: {
        type: "weighted",
        allowRepeats: !0,
        weights: new Map(e.map((n) => [n, t.weights.get(n) ?? 1])),
      },
    };
  } else {
    if (t.asNumber)
      return { name: t.name, cells: t.cells, properties: { type: "asNumber" } };
    if (ki(t.cells)) {
      const e = $i(t.cells),
        n = Ns(t.cells);
      return {
        name: t.name,
        cells: n,
        properties: {
          type: "weighted",
          allowRepeats: !0,
          weights: new Map(n.map((s) => [s, e.get(s)])),
        },
      };
    } else
      return {
        name: t.name,
        cells: t.cells,
        properties: { type: "list", allowRepeats: !0 },
      };
  }
}
function* ud(t, e, n = [], s = 0) {
  if ((s === e && (yield n), !(s >= e)))
    for (let o = 0; o < t.length; o++) {
      const r = t[o],
        l = t.slice(o + 1);
      yield* ud(l, e, n.concat([r]), s + r);
    }
}
class vv extends Pe {
  constructor(n, s, o, r) {
    super(n, r);
    L(this, "sum");
    L(this, "sandwichDigits");
    L(this, "combinations", []);
    L(this, "minDistance", 1);
    L(this, "maxDistance", 1);
    L(this, "sandwichDigitsMask", 0);
    if (((this.sum = s), (this.sandwichDigits = o), this.sum > 0)) {
      const l = Ee.digits.createFullDigitSet();
      for (const i of o) l.delete(i);
      (this.combinations = [...ud([...l], this.sum)]),
        (this.minDistance =
          this.combinations.reduce((i, a) => Math.min(i, a.length), 1 / 0) + 1),
        (this.maxDistance =
          this.combinations.reduce((i, a) => Math.max(i, a.length), 0) + 1);
    }
    this.sandwichDigitsMask =
      (1 << this.sandwichDigits[0]) | (1 << this.sandwichDigits[1]);
  }
  *initialize(n) {
    if (this.minDistance === 1 / 0) {
      yield gt(`${this.name} is impossible to satisfy`, this.cellIds);
      return;
    }
    if (this.maxDistance > 1 && this.minDistance > this.cellIds.length / 2) {
      const s = this.cellIds.slice(
        this.cellIds.length - this.minDistance,
        this.minDistance
      );
      yield _o(this.sandwichDigitsMask, s);
    }
    yield* this.update(n);
  }
  *update(n) {
    yield* this.updatePossibleCellsForSandwichDigits(
      n,
      this.sandwichDigits[0],
      this.sandwichDigits[1]
    ),
      yield* this.updatePossibleCellsForSandwichDigits(
        n,
        this.sandwichDigits[1],
        this.sandwichDigits[0]
      ),
      yield* this.updateCandidatesBetweenSandwichDigits(n);
  }
  *updatePossibleCellsForSandwichDigits(n, s, o) {
    const r = this.cellIds.findIndex((i) => n.cells[i].candidates === 1 << s);
    if (r === -1) return;
    const l = [];
    for (let i = 0; i < this.cellIds.length; i++) {
      const a = Math.abs(i - r);
      (a < this.minDistance || a > this.maxDistance) && l.push(this.cellIds[i]);
    }
    yield Fi(o, l);
  }
  *updateCandidatesBetweenSandwichDigits(n) {
    const s = this.getSandwichIndices(n);
    if (s.length !== 2) return;
    const o =
      (n.cells[this.cellIds[s[0]]].candidates |
        n.cells[this.cellIds[s[1]]].candidates) &
      this.sandwichDigitsMask;
    if (Yr(o) !== 2) {
      yield gt(
        `${this.name} cannot be satisfied`,
        s.map((l) => this.cellIds[l])
      );
      return;
    }
    const r = this.cellIds.slice(s[0] + 1, s[1]);
    yield On(this, new So(this.name, this.sum, r));
  }
  getSandwichIndices(n) {
    const s = [];
    for (let o = 0; o < this.cellIds.length; o++) {
      const r = this.cellIds[o];
      (n.cells[r].candidates | this.sandwichDigitsMask) ===
        this.sandwichDigitsMask && s.push(o);
    }
    return s;
  }
  validate({ cells: n }) {
    let s = 0,
      o = 0,
      r = 0;
    for (let l = 0; l < this.cellIds.length; l++) {
      const i = this.cellIds[l],
        a = n[i].value;
      if (a !== void 0 && this.sandwichDigits.includes(a)) {
        if ((s++, s === 2)) {
          if (r === 0 && o !== this.sum)
            return {
              valid: !1,
              message: `The digits between ${this.sandwichDigits[0]} and ${this.sandwichDigits[1]} for ${this.name} do not sum to ${this.sum}`,
            };
          break;
        }
      } else s === 1 && (a !== void 0 ? (o += a) : r++);
    }
    return Me;
  }
}
var yv = Object.defineProperty,
  Cv = Object.getOwnPropertyDescriptor,
  wv = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Cv(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && yv(e, n, o), o;
  };
let ru = class extends Tn {
  constructor(t, e, n, s) {
    super(t, s, () => [new xr(t, n, s), new vv(t, e, n, s)]);
  }
};
ru = wv(
  [
    $e(
      "SandwichSum",
      "\n".join([
        `Along {cells} there must be a sequence of values starting with one of {sandwichDigits}, then some values summing to {sum}, then another digit from {sandwichDigits}. `,
        `**Note:** currently requires all cells to be different.`,
      ]),
      [
        ["sum", K.Number],
        ["sandwichDigits", { type: K.NumberArray, amount: 2 }],
        ["cells", K.CellArray],
      ]
    ),
  ],
  ru
);
var bv = Object.defineProperty,
  kv = Object.getOwnPropertyDescriptor,
  _v = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? kv(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && bv(e, n, o), o;
  };
let lu = class extends Tn {
  constructor(t, e) {
    super(t, e, (n) => {
      let s = 0;
      for (const o of e)
        for (const r of n.getCellsSeenByCell(o))
          if (e.includes(r)) {
            s = 1;
            break;
          }
      return new $v(t, e, s);
    });
  }
};
lu = _v(
  [
    $e(
      "Sequence",
      "Digits along {cells} must increase or decrease by the same amount (or stay the same)",
      [["cells", K.CellArray]]
    ),
  ],
  lu
);
class $v extends Pe {
  constructor(n, s, o = 1) {
    super(n, s);
    L(this, "minimumDifference");
    this.minimumDifference = o;
  }
  *update(n) {
    if (this.cellIds.length <= 2) return;
    const s = this.getValidValuesForDirection(n, !1),
      o = this.getValidValuesForDirection(n, !0);
    for (let r = 0; r < this.cellIds.length; r++)
      yield it(s[r] | o[r], this.cellIds[r]);
  }
  getValidValuesForDirection(n, s = !1) {
    const o = this.cellIds.at(s ? -1 : 0),
      r = this.cellIds.at(s ? 0 : -1),
      l = n.cells[o].candidates,
      i = n.cells[r].candidates,
      a = Ot(i) - $t(l),
      u = this.cellIds.map(() => 0);
    if (a < 0) return [];
    const p = Math.floor(a / (this.cellIds.length - 1)),
      m = [...Ve(this.minimumDifference, p)],
      g = Array.from(this.cellIds, (v) => 0);
    for (const v of Yn(l)) {
      g[s ? this.cellIds.length - 1 : 0] = v;
      e: for (const $ of m) {
        for (let k = 1; k < this.cellIds.length; k++) {
          const M = s ? this.cellIds.length - k - 1 : k,
            P = v + $ * k;
          if (!((n.cells[this.cellIds[M]].candidates & (1 << P)) !== 0))
            continue e;
          g[M] = P;
        }
        for (let k = 0; k < u.length; k++) u[k] |= 1 << g[k];
      }
    }
    return u;
  }
}
var Sv = Object.defineProperty,
  Iv = Object.getOwnPropertyDescriptor,
  xv = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Iv(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Sv(e, n, o), o;
  };
let iu = class extends Pe {
  constructor(e, n, s) {
    super(e, s);
    L(this, "amount");
    this.amount = n;
  }
  get validateDuringSolve() {
    return !0;
  }
  *initialize(e) {
    if (this.amount === 1 && me.minDigit === 1) {
      yield On(
        this,
        this.cellIds.slice(1).map((n) => new Kl(this.name, n, this.cellIds[0]))
      );
      return;
    }
    yield* super.initialize(e);
  }
  *update(e) {
    let n = 0,
      s = me.maxDigit - this.amount + 1;
    for (let o = 0; o < this.cellIds.length; o++) {
      const r = this.cellIds[o];
      let l = 0;
      for (let u = me.minDigit; u <= s; u++) l |= 1 << u;
      yield it(l, r);
      const i = $t(e.cells[r].candidates);
      i > n && (n = i);
      const a = Ot(e.cells[r].candidates);
      a > 0 && a >= n && s++;
    }
  }
  validate({ cells: e }) {
    let n = 0,
      s = 0,
      o = !1;
    for (const r of this.cellIds) {
      if (Ot(e[r].candidates) <= n) continue;
      const i = e[r].value;
      if (i === void 0) {
        o = !0;
        break;
      } else i > n && ((n = i), s++);
    }
    return o
      ? s > this.amount
        ? { valid: !1, message: `${this.name} sees at least ${s} skyscrapers` }
        : Me
      : s !== this.amount
      ? { valid: !1, message: `${this.name} sees exactly ${s} skyscrapers` }
      : Me;
  }
};
iu = xv(
  [
    $e(
      "Skyscraper",
      "Digits along {cells} represent skyscrapers, blocking cells further along the sequence. The amount of skyscrapers seen from the start must equal {amount}.",
      [
        ["amount", K.Number],
        ["cells", K.CellArray],
      ]
    ),
  ],
  iu
);
var Dv = Object.defineProperty,
  Mv = Object.getOwnPropertyDescriptor,
  Av = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Mv(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Dv(e, n, o), o;
  };
let au = class extends Pe {
  constructor(t, e, n, s, o) {
    super(t, [e, s]),
      (this.cellId1 = e),
      (this.value1 = n),
      (this.cellId2 = s),
      (this.value2 = o);
  }
  *onValueSet(t, e, n) {
    e === this.cellId1
      ? n === this.value1 && (yield Ts(this.value2, this.cellId2))
      : n === this.value2 && (yield Ts(this.value1, this.cellId1)),
      yield vn(this);
  }
  validate({ cells: t }) {
    return t[this.cellId1].value === this.value1 &&
      t[this.cellId2].value === this.value2
      ? { valid: !1, message: `unable to satisfy ${this.name}` }
      : Me;
  }
};
au = Av(
  [
    $e(
      "WeakLink",
      "If {cell1} is set to {value1}, {cell2} must not be {value2}. Similarly, if {cell2} is set to {value2}, {cell1} cannot be {value1}.",
      [
        ["cell1", K.Cell],
        ["value1", K.Number],
        ["cell2", K.Cell],
        ["value2", K.Number],
      ]
    ),
  ],
  au
);
var Pv = Object.defineProperty,
  Lv = Object.getOwnPropertyDescriptor,
  Ev = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? Lv(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Pv(e, n, o), o;
  };
let uu = class extends Pe {
  constructor(e, n, s, o, r) {
    (n = Et(n)), (o = Et(o));
    super(e, [...n, ...o]);
    L(this, "cellIds1");
    L(this, "cellIds2");
    L(this, "values1");
    L(this, "values2");
    (this.cellIds1 = n),
      (this.cellIds2 = o),
      (this.values1 = +s),
      (this.values2 = +r);
  }
  *update(e) {
    for (const n of this.cellIds1)
      if ((e.cells[n].candidates | this.values1) === this.values1) {
        yield _o(this.values2, this.cellIds2), yield vn(this);
        return;
      }
    for (const n of this.cellIds2)
      if ((e.cells[n].candidates | this.values2) === this.values2) {
        yield _o(this.values1, this.cellIds1), yield vn(this);
        return;
      }
  }
};
uu = Ev(
  [
    $e(
      "WeakLinks",
      "If any of {cells1} is set to one of {values1}, all of {cells2} cannot be any of {values2}. Similarly, if any of {cells2} is set to one of {values2}, all of {cells1} cannot be any of {values1}.",
      [
        ["cells1", K.CellOrCellArray],
        ["value1", K.DigitSet],
        ["cells2", K.CellOrCellArray],
        ["value2", K.DigitSet],
      ]
    ),
  ],
  uu
);
class Fv extends Pe {
  constructor(n, s, o, r) {
    super(n, [o, ...r]);
    L(this, "sum");
    L(this, "xCellId");
    L(this, "cellsToSum");
    (this.sum = s), (this.xCellId = o), (this.cellsToSum = r);
  }
  get validateDuringSolve() {
    return !0;
  }
  *initialize(n) {
    if (this.sum === 0) yield Rl(0, this.xCellId), yield vn(this);
    else {
      const s = fn(Ve(1, this.cellsToSum.length));
      yield it(s, this.xCellId), yield* super.initialize(n);
    }
  }
  *update({ cells: n }) {
    if (Yr(n[this.xCellId].candidates) === 1) {
      const s = $t(n[this.xCellId].candidates);
      yield On(this, new So(this.name, this.sum, this.cellsToSum.slice(0, s)));
    }
  }
  validate({ cells: n }) {
    const s = $t(n[this.xCellId].candidates),
      o = this.cellsToSum.slice(0, s),
      { minSum: r } = Ee.sums.getExtremeSumsWithRepeat(
        o.map((l) => n[l].candidates)
      );
    return r > this.sum
      ? {
          valid: !1,
          message: `the first ${s} cells of ${this.name} sum to at least ${r}`,
          cells: o,
        }
      : Me;
  }
}
var Bv = Object.defineProperty,
  zv = Object.getOwnPropertyDescriptor,
  Rv = (t, e, n, s) => {
    for (
      var o = s > 1 ? void 0 : s ? zv(e, n) : e, r = t.length - 1, l;
      r >= 0;
      r--
    )
      (l = t[r]) && (o = (s ? l(e, n, o) : l(o)) || o);
    return s && o && Bv(e, n, o), o;
  };
let cu = class extends Tn {
  constructor(t, e, n, s) {
    super(t, [n, ...s], (o) => {
      if (me.minDigit !== 1) return new Fv(t, e, n, s);
    });
  }
};
cu = Rv(
  [
    $e(
      "XSum",
      "The first X digits along {cells} must sum to {sum}, where X is the value of {xCell}.",
      [
        ["sum", K.Number],
        ["xCell", K.Cell],
        ["cells", K.CellArray],
      ]
    ),
  ],
  cu
);
const Io = jo(),
  Xl = {},
  Ov = Xh(Io),
  du = Kh(Io, Xl),
  pu = Fn(Io);
function cd(t) {
  const e = { ...Qh() };
  switch (t) {
    case "backend":
      (e.sudoku = e.puzzle = new Yh(Io, Xl, du)), (e.helpers = du);
      for (const n of Oa().keys()) e[n] = function () {};
      break;
    case "frontend":
      e.helpers = Ov;
      break;
    case "component":
      (e.instance = { cells: [], name: "", params: {} }),
        (e.sudoku = e.puzzle = new Jh({}, Io, Xl, pu)),
        (e.helpers = pu);
      for (const n of Oa().keys()) e[n] = function () {};
      e.customComponents = {};
  }
  return e;
}
function dd(t) {
  if (typeof t == "string") return t;
  if (typeof t == "object")
    switch (t.type) {
      case K.Object:
        return pd(t);
      case K.StringArray:
      case K.CellArray:
      case K.NumberArray:
      case K.DigitSetArray:
      case K.BooleanArray:
      case K.ObjectArray:
        return Tv(t);
    }
  else return Nv(t);
}
function Nv(t) {
  switch (t) {
    case K.String:
      return "string";
    case K.StringArray:
      return "string[]";
    case K.Cell:
      return "CellId";
    case K.CellArray:
      return "CellId[]";
    case K.CellOrCellArray:
      return "CellId | CellId[]";
    case K.Number:
      return "number";
    case K.NumberArray:
      return "number[]";
    case K.NumberOrNumberArray:
      return "number | number[]";
    case K.DigitSet:
      return "DigitSet";
    case K.DigitSetArray:
      return "DigitSet[]";
    case K.Boolean:
      return "boolean";
    case K.BooleanArray:
      return "boolean[]";
    case K.Object:
      return "object";
    case K.ObjectArray:
      return "object[]";
  }
}
function pd(t) {
  const e = [];
  for (const [n, s] of Object.entries(t.fields)) e.push(`${n}: ${dd(s)}`);
  return `{ ${e.join(", ")} }`;
}
function Tv(t) {
  if (t.type === K.ObjectArray) return `${pd(t)}[]`;
  let e;
  switch (t.type) {
    case K.StringArray:
      e = "string";
      break;
    case K.CellArray:
      e = "CellId";
      break;
    case K.NumberArray:
      e = "number";
      break;
    case K.DigitSetArray:
      e = "DigitSet";
      break;
    case K.BooleanArray:
      e = "boolean";
      break;
  }
  return t.amount
    ? t.amount <= 3
      ? `[${Array.from({ length: t.amount }, () => e).join(", ")}]`
      : `${e}[${t.amount}]`
    : `${e}[]`;
}
const Vv = {
    ".cm-selectionBackground": { background: "#292929" },
    "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground":
      { background: "#284040" },
    ".cm-gutters": { background: "var(--mainBgColor)" },
    ".cm-cursor": { borderLeftColor: "#eee" },
    ".cm-activeLine": { backgroundColor: "#99eeff33" },
    ".cm-activeLineGutter": { backgroundColor: "var(--secondaryBgColor)" },
    ".cm-panels": {
      backgroundColor: "var(--mainBgColor)",
      color: "var(--mainTextColor)",
    },
    ".cm-button": { backgroundImage: "none" },
  },
  jv = Nf,
  Uv = Of.define([
    { tag: Fe.keyword, color: "#569CD6" },
    {
      tag: [Fe.name, Fe.deleted, Fe.character, Fe.propertyName],
      color: "#9CDCFE",
    },
    { tag: [Fe.function(Fe.variableName), Fe.labelName], color: "#DCDCAA" },
    {
      tag: [Fe.color, Fe.constant(Fe.name), Fe.standard(Fe.name)],
      color: "#4EC9B0",
    },
    { tag: [Fe.definition(Fe.name), Fe.separator], color: "#FFFFFF" },
    { tag: [Fe.className], color: "#4EC9B0" },
    {
      tag: [
        Fe.number,
        Fe.changed,
        Fe.annotation,
        Fe.modifier,
        Fe.self,
        Fe.namespace,
      ],
      color: "#B5CEA8",
    },
    { tag: [Fe.typeName], color: "#4EC9B0" },
    { tag: [Fe.operator, Fe.operatorKeyword], color: "#D4D4D4" },
    { tag: [Fe.string], color: "#CE9178" },
    { tag: [Fe.meta, Fe.comment], color: "#6A9955" },
  ]);
function Hv(t, e) {
  const n = [
    Tf(),
    Vf(),
    jf(),
    Uf(),
    Hf(),
    Wf(),
    Zf(),
    Gf.allowMultipleSelections.of(!0),
    qf(),
    Kf(),
    Xf(),
    Yf(),
    Jf(),
    Qf(),
    e1(),
    t1(),
    n1.of([...s1, ...o1, ...r1, ...l1, ...i1, ...a1, ...u1, c1]),
    t === "javascript" ? d1() : p1(),
  ];
  return (
    e
      ? n.push(Ml.theme(Vv, { dark: e }), Ca(Uv, { fallback: !0 }))
      : n.push(Ca(jv, { fallback: !0 })),
    n
  );
}
const Wv = S({
    __name: "CodeEditor",
    props: {
      modelValue: { default: "" },
      disabled: { type: Boolean, default: !1 },
      autofocus: { type: Boolean, default: !1 },
      scope: { default: () => ({}) },
      placeholder: { default: "" },
      language: { default: "javascript" },
    },
    emits: ["update:modelValue", "blur", "focus"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = j(null),
        r = ys(null);
      function l(u) {
        !r.value ||
          u === r.value.state.doc.toString() ||
          r.value.dispatch({
            changes: { from: 0, to: r.value.state.doc.length, insert: u },
          });
      }
      function i(u) {
        const p = u.state.doc.toString();
        u.docChanged && p !== n.modelValue && s("update:modelValue", p),
          u.focusChanged && s(u.view.hasFocus ? "focus" : "blur");
      }
      const a = new f1();
      return (
        Xt(() => {
          const u =
            getComputedStyle(document.documentElement).getPropertyValue(
              "--themeName"
            ) === "dark";
          (r.value = new Ml({
            extensions: [
              ...Hv(n.language, u),
              Ml.updateListener.of(i),
              a.of(wa.data.of({ autocomplete: ba(n.scope) })),
            ],
            parent: o.value,
            doc: n.modelValue || n.placeholder,
          })),
            n.autofocus &&
              requestAnimationFrame(() => {
                r.value.focus();
              });
        }),
        Nr(() => {
          var u;
          (u = r.value) == null || u.destroy();
        }),
        ae(
          () => n.modelValue,
          (u) => {
            l(u);
          }
        ),
        ae(
          () => n.scope,
          (u) => {
            var p;
            (p = r.value) == null ||
              p.dispatch({
                effects: a.reconfigure(wa.data.of({ autocomplete: ba(u) })),
              });
          }
        ),
        (u, p) => (
          d(),
          C(
            "div",
            { ref_key: "parent", ref: o, class: "CodeEditor" },
            null,
            512
          )
        )
      );
    },
  }),
  Ho = B(Wv, [["__scopeId", "data-v-714ff9e9"]]),
  vr = new Map();
document.addEventListener(
  "pointerdown",
  (t) => {
    for (const [e, n] of vr) e.contains(t.target) || n(t);
  },
  !0
);
const fd = {
    beforeMount(t, { value: e }) {
      vr.set(t, e);
    },
    updated(t, { value: e }) {
      vr.set(t, e);
    },
    unmounted(t) {
      vr.delete(t);
    },
  },
  Zv = { components: { Icon: he } };
function Gv(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "TrashBin", viewBox: "0 0 11 13" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M6.77 0c.2 0 .41.07.61.2.2.14.34.3.42.5L8.35 2h2.4c.07 0 .13.02.18.06.05.05.07.1.07.18v.5a.24.24 0 0 1-.25.25H10v7.46c0 .43-.12.8-.36 1.1-.25.3-.54.46-.88.46H2.24a1.1 1.1 0 0 1-.88-.46 1.7 1.7 0 0 1-.36-1.1V3H.25A.24.24 0 0 1 0 2.74v-.5c0-.07.02-.13.07-.18.05-.04.1-.06.18-.06h2.4L3.2.7c.07-.2.21-.36.42-.5.2-.13.4-.2.61-.2h2.54ZM1.99 2.99v7.43a.89.89 0 0 0 .17.53c.04.04.06.06.08.06h6.52c.02 0 .04-.02.08-.06a.89.89 0 0 0 .17-.53V2.99H1.99Zm2 1.74v4.48c0 .07-.03.13-.08.18a.25.25 0 0 1-.18.07h-.5a.25.25 0 0 1-.17-.07.25.25 0 0 1-.07-.18V4.73c0-.07.02-.13.07-.18.04-.05.1-.07.18-.07h.5c.07 0 .13.02.17.07.05.05.07.1.07.18Zm2 0v4.48c0 .07-.03.13-.08.18a.25.25 0 0 1-.18.07h-.5a.25.25 0 0 1-.17-.07.25.25 0 0 1-.07-.18V4.73c0-.07.02-.13.07-.18.04-.05.1-.07.18-.07h.5c.07 0 .13.02.17.07.05.05.07.1.07.18Zm1.03 0v4.48c0 .07.02.13.07.18.04.05.1.07.18.07h.5c.07 0 .13-.02.17-.07.05-.05.07-.1.07-.18V4.73a.25.25 0 0 0-.07-.18.24.24 0 0 0-.18-.07h-.5a.24.24 0 0 0-.17.07.24.24 0 0 0-.07.18ZM7.27 2l-.38-.92A.22.22 0 0 0 6.75 1h-2.5a.22.22 0 0 0-.13.08L3.73 2h3.54Z",
                  "fill-rule": "nonzero",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const xo = B(Zv, [["render", Gv]]),
  qv = S({
    methods: {
      onAfterEnter(t) {
        const e = t;
        e.style.width = "auto";
      },
      onEnter(t) {
        const e = t,
          { height: n } = getComputedStyle(e);
        (e.style.height = n),
          (e.style.position = "absolute"),
          (e.style.visibility = "hidden"),
          (e.style.width = "auto");
        const { width: s } = getComputedStyle(e);
        (e.style.height = null),
          (e.style.position = null),
          (e.style.visibility = null),
          (e.style.width = "0"),
          getComputedStyle(e),
          setTimeout(() => {
            e.style.width = s;
          });
      },
      onLeave(t) {
        const e = t,
          { width: n } = getComputedStyle(e);
        (e.style.width = n),
          getComputedStyle(e),
          setTimeout(() => {
            e.style.width = "0";
          });
      },
    },
  });
function Kv(t, e, n, s, o, r) {
  return (
    d(),
    w(
      Tr,
      {
        name: "expandHorizontally",
        mode: "out-in",
        onAfterEnter: t.onAfterEnter,
        onEnter: t.onEnter,
        onLeave: t.onLeave,
      },
      { default: f(() => [G(t.$slots, "default")]), _: 3 },
      8,
      ["onAfterEnter", "onEnter", "onLeave"]
    )
  );
}
const Yl = B(qv, [["render", Kv]]),
  Xv = { key: 0, class: "confirmWrapper" },
  Yv = S({
    __name: "DestroyButton",
    props: { needConfirm: { type: Boolean } },
    emits: ["click"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = j(!1);
      function r(l) {
        n.needConfirm && !o.value ? (o.value = !0) : s("click", l);
      }
      return (l, i) =>
        Ln(
          (d(),
          C(
            "button",
            {
              class: Ae(["DestroyButton", { confirming: o.value }]),
              onClick: st(r, ["stop"]),
            },
            [
              c(xo),
              c(Yl, null, {
                default: f(() => [
                  o.value
                    ? (d(),
                      C(
                        "span",
                        Xv,
                        i[0] ||
                          (i[0] = [
                            h("span", { class: "confirm" }, "Confirm", -1),
                          ])
                      ))
                    : z("", !0),
                ]),
                _: 1,
              }),
            ],
            2
          )),
          [
            [
              y(fd),
              () => {
                o.value = !1;
              },
            ],
          ]
        );
    },
  }),
  Jr = B(Yv, [["__scopeId", "data-v-3ae11ffa"]]),
  Jv = S({
    props: {
      disabled: { type: Boolean, default: !1 },
      active: { type: Boolean, default: !1 },
      toggleable: { type: Boolean, default: !1 },
      icon: { type: Boolean, default: !1 },
      withIcon: { type: Boolean, default: !1 },
      type: { type: String, default: "button" },
      outline: { type: Boolean, default: !1 },
      variant: { type: String, default: "default" },
      size: { type: String, default: "normal" },
    },
    methods: {
      focus() {
        this.$el.focus();
      },
    },
  }),
  Qv = ["disabled", "type"];
function e2(t, e, n, s, o, r) {
  return (
    d(),
    C(
      "button",
      {
        class: Ae([
          "FormButton",
          [
            t.variant,
            t.size,
            {
              toggleable: t.toggleable,
              active: t.active,
              icon: t.icon,
              withIcon: t.withIcon,
              outline: t.outline,
            },
          ],
        ]),
        disabled: t.disabled,
        type: t.type,
      },
      [G(t.$slots, "default", {}, void 0, !0)],
      10,
      Qv
    )
  );
}
const te = B(Jv, [
    ["render", e2],
    ["__scopeId", "data-v-7314fe69"],
  ]),
  t2 = ["placeholder", "value", "size"],
  n2 = S({
    __name: "TextInput",
    props: {
      value: { default: "" },
      placeholder: { default: "" },
      autofocus: { type: Boolean },
      invalid: { type: Boolean },
      isCode: { type: Boolean },
      size: { default: 2 },
      autosize: { type: Boolean },
    },
    emits: ["update:value", "change"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = j();
      ae(
        () => n.invalid,
        (i) => {
          var a;
          (a = o.value) == null || a.setCustomValidity(i ? "Invalid" : "");
        },
        { immediate: !0, flush: "post" }
      ),
        Xt(() => {
          n.autofocus && o.value.focus();
        });
      function r(i) {
        s("update:value", o.value.value, i);
      }
      function l(i) {
        s("change", i.target.value);
      }
      return (i, a) => (
        d(),
        C(
          "input",
          {
            ref_key: "element",
            ref: o,
            class: Ae(["TextInput", { isCode: i.isCode }]),
            type: "text",
            placeholder: i.placeholder,
            value: i.value,
            size: i.size,
            onInput: r,
            onChange: l,
          },
          null,
          42,
          t2
        )
      );
    },
  }),
  vt = B(n2, [["__scopeId", "data-v-5ba643e2"]]),
  s2 = { components: { Icon: he } };
function o2(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "Pencil", viewBox: "0 0 16 16" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h("path", { d: "m2 10-1 4 4-1-3-3ZM3 9l3 3 8-8-3-3" }, null, -1),
            ])
        ),
        _: 1,
      }
    )
  );
}
const ls = B(s2, [["render", o2]]),
  r2 = { class: "ConstraintComponentEntry" },
  l2 = { class: "main" },
  i2 = { key: 2, class: "definition" },
  a2 = { key: 0 },
  u2 = { key: 0, class: "description" },
  c2 = { key: 0, class: "aliases" },
  d2 = ["textContent"],
  p2 = decodeURIComponent(
    "%2F**%0A%20*%20When%20the%20constructor%20of%20this%20component%20is%20called%2C%20by%20default%20it%20is%20assumed%0A%20*%20the%20first%20parameter%20after%20%60name%60%20represents%20the%20affected%20cells.%20Uncomment%0A%20*%20and%20implement%20this%20function%20if%20this%20custom%20component's%20affected%20cells%20are%0A%20*%20determined%20in%20a%20different%20way.%0A%20*%2F%0A%2F%2F%20function%20getAffectedCells%20(param1%2C%20param2%2C%20...)%20%7B%0A%2F%2F%20%7D%0A%0A%2F**%0A%20*%20Uncomment%20and%20implement%20this%20function%20if%20instances%20of%20this%20component%20require%0A%20*%20member%20variables%20based%20on%20the%20constructor's%20parameters.%20Note%20that%20member%0A%20*%20variables%20should%20not%20be%20mutated%20after%20initialization!%0A%20*%2F%0A%2F%2F%20function%20setParams%20(instance%2C%20param1%2C%20param2%2C%20...)%20%7B%0A%2F%2F%20%20%20instance.param1%20%3D%20param1%0A%2F%2F%20%20%20instance.param2%20%3D%20param2%0A%2F%2F%20%20%20...%0A%2F%2F%20%7D%0A%0A%2F**%0A%20*%20Uncomment%20and%20implement%20this%20function%20if%20there%20is%20one-time%20logic%20that%20can%0A%20*%20eliminate%20candidates%2C%20or%20that%20can%20set%20or%20update%20member%20variables%20of%20the%0A%20*%20instance%2C%20based%20on%20the%20state%20of%20the%20puzzle.%0A%20*%20Note%20that%20member%20variables%20should%20not%20be%20mutated%20after%20initialization!%0A%20*%2F%0A%2F%2F%20function*%20initialize%20(instance%2C%20puzzle)%20%2F*%20%3A%20Generator%3CChange%3E%20*%2F%20%7B%0A%2F%2F%20%20%20const%20%7B%20cells%2C%20param1%20%7D%20%3D%20instance%0A%2F%2F%20%20%20%2F%2F%20For%20instance%2C%20if%20you%20know%20you%20can%20remove%201%20as%20a%20candidate%20from%20all%20cells%0A%2F%2F%20%20%20%2F%2F%20regardless%20of%20the%20state%20of%20the%20puzzle%0A%2F%2F%20%20%20yield%20puzzle.removeCandidatesFromCells(SudokuDigitSet.from(%5B1%5D)%2C%20cells)%0A%2F%2F%0A%2F%2F%20%20%20%2F%2F%20At%20the%20moment%2C%20functions%20that%20return%20information%20about%20which%20cells%20see%0A%2F%2F%20%20%20%2F%2F%20which%20are%20not%20very%20fast%2C%20so%20it%20is%20wise%20to%20cache%20that%20if%20deemed%20useful%3A%0A%2F%2F%20%20%20instance.uniqueDigits%20%3D%20param1%20%26%26%20puzzle.getCellsSeeEachOther(cells)%0A%2F%2F%20%7D%0A%0A%2F**%0A%20*%20Uncomment%20and%20implement%20this%20function%20if%20the%20puzzle%20must%20be%20checked%20on%20a%0A%20*%20custom%20condition.%20Should%20return%20false%20if%20and%20only%20if%20the%20condition%0A%20*%20cannot%20hold.%20If%20there%20is%20not%20enough%20information%20whether%20the%20condition%0A%20*%20holds%2C%20it%20should%20return%20true.%0A%20*%2F%0A%2F%2F%20function%20validate%20(instance%2C%20puzzle)%20%2F*%20%3A%20boolean%20*%2F%20%7B%0A%2F%2F%20%20%20const%20%7B%20cells%20%7D%20%3D%20instance%0A%2F%2F%20%20%20if%20(!puzzle.getCellsAreFilled(cells))%20%7B%0A%2F%2F%20%20%20%20%20return%20true%0A%2F%2F%20%20%20%7D%0A%2F%2F%20%20%20return%20cells.every(cell%20%3D%3E%20puzzle.getValue(cell)%20%3D%3D%3D%201)%0A%2F%2F%20%7D%0A%0A%2F**%0A%20*%20Uncomment%20and%20implement%20this%20function%20if%20candidates%20can%20be%20eliminated%20by%0A%20*%20simple%20logic.%0A%20*%2F%0A%2F%2F%20function*%20update%20(instance%2C%20puzzle)%20%2F*%20%3A%20Generator%3CChange%3E%20*%2F%20%7B%0A%2F%2F%20%20%20const%20%7B%20cells%20%7D%20%3D%20instance%0A%2F%2F%20%20%20if%20(puzzle.hasValue(cells%5B0%5D))%20%7B%0A%2F%2F%20%20%20%20%20yield%20puzzle.filterCandidatesInCells(SudokuDigitSet.from(%5B1%5D)%2C%20cells)%0A%2F%2F%20%20%20%7D%0A%2F%2F%20%20%20%2F%2F%20You%20can%20also%20'merge'%20update%20and%20validate%20logic%20in%20some%20cases.%0A%2F%2F%20%20%20%2F%2F%20For%20example%2C%20if%20you%20can%20consider%20a%20component%20to%20be%20'done'%3A%0A%2F%2F%20%20%20if%20(puzzle.getValue(cells%5B1%5D)%20%3D%3D%3D%202)%20%7B%0A%2F%2F%20%20%20%20%20yield%20puzzle.removeComponent(instance)%0A%2F%2F%20%20%20%7D%0A%2F%2F%20%20%20%2F%2F%20Or%20if%20while%20updating%20it%20turns%20out%20something%20is%20impossible%3A%0A%2F%2F%20%20%20if%20(puzzle.hasValue(cells%5B1%5D)%20%26%26%20puzzle.getValue(cells%5B1%5D)%20%3D%3D%3D%20puzzle.getValue(cells%5B2%5D))%20%7B%0A%2F%2F%20%20%20%20%20yield%20puzzle.stop(%60%24%7Bhelpers.naming.getCellsDescription(cells.slice(1%2C%203))%7D%20have%20the%20same%20value%60)%0A%2F%2F%20%20%20%7D%0A%2F%2F%20%7D%0A"
  ),
  f2 = S({
    __name: "ConstraintComponentEntry",
    props: { entry: {}, allCustomComponents: {} },
    emits: ["remove"],
    setup(t) {
      const e = t,
        n = j(e.entry.name);
      ae(
        () => e.entry.name,
        (a) => {
          n.value = a;
        }
      ),
        ae(n, (a) => {
          e.entry.model.name = a;
        });
      const s = j(!1),
        o = b(() => {
          const a = cd("component");
          return (
            e.allCustomComponents &&
              (a.customComponents = Object.fromEntries(
                e.allCustomComponents.map((u) => [u, {}])
              )),
            a
          );
        }),
        r = b(() => e.entry.description);
      function l({ text: a }) {
        const u = [];
        let p = 0;
        for (let m = 0; m < a.length; m++)
          if (a[m] === "{") {
            for (
              u.push(a.substring(p, m)), p = m + 1;
              a[m] !== "}" && m < a.length;

            )
              m++;
            u.push(Qt("code", [a.substring(p, m)])), (p = m + 1);
          } else if (a[m] === "*" && a[m + 1] === "*") {
            for (
              u.push(a.substring(p, m)), m += 2, p = m;
              (a[m] !== "*" || a[m + 1] !== "*") && m < a.length;

            )
              m++;
            u.push(Qt("strong", [a.substring(p, m)])),
              (m += 2),
              (p = m),
              (m -= 1);
          }
        return u.push(a.substring(p)), u;
      }
      function i({ params: a }) {
        a = [["name", K.String], ...a];
        const u = [];
        for (const [p, m] of a)
          u.push(
            Qt("span", { class: "paramName" }, [p]),
            ": ",
            Qt("span", { class: "typeName" }, [dd(m)]),
            ", "
          );
        return u.pop(), u;
      }
      return (a, u) => {
        var p;
        return (
          d(),
          C("div", r2, [
            h("div", l2, [
              a.entry.model
                ? (d(),
                  w(
                    te,
                    {
                      key: 0,
                      icon: "",
                      active: s.value,
                      onClick: u[0] || (u[0] = (m) => (s.value = !s.value)),
                    },
                    { default: f(() => [c(ls)]), _: 1 },
                    8,
                    ["active"]
                  ))
                : z("", !0),
              s.value
                ? (d(),
                  C(
                    Z,
                    { key: 1 },
                    [
                      s.value
                        ? (d(),
                          w(
                            vt,
                            {
                              key: 0,
                              value: n.value,
                              "onUpdate:value":
                                u[1] || (u[1] = (m) => (n.value = m)),
                              class: "nameEditor",
                            },
                            null,
                            8,
                            ["value"]
                          ))
                        : z("", !0),
                      c(Jr, {
                        "need-confirm": "",
                        onClick:
                          u[2] ||
                          (u[2] = (m) => a.$emit("remove", a.entry.model)),
                      }),
                    ],
                    64
                  ))
                : (d(),
                  C("div", i2, [
                    s.value ? z("", !0) : (d(), C("strong", a2, X(n.value), 1)),
                    u[4] || (u[4] = F("(")),
                    c(i, { params: a.entry.params }, null, 8, ["params"]),
                    u[5] || (u[5] = F(") ")),
                  ])),
            ]),
            !s.value && r.value
              ? (d(),
                C("div", u2, [
                  c(l, { text: r.value }, null, 8, ["text"]),
                  (p = a.entry.aliases) != null && p.length
                    ? (d(),
                      C("div", c2, [
                        u[6] || (u[6] = F(" Aliases: ")),
                        (d(!0),
                        C(
                          Z,
                          null,
                          se(
                            a.entry.aliases,
                            (m) => (
                              d(),
                              C(
                                "strong",
                                { key: m, textContent: X(m) },
                                null,
                                8,
                                d2
                              )
                            )
                          ),
                          128
                        )),
                      ]))
                    : z("", !0),
                ]))
              : z("", !0),
            s.value
              ? (d(),
                w(
                  Ho,
                  {
                    key: 1,
                    modelValue: a.entry.model.code,
                    "onUpdate:modelValue":
                      u[3] || (u[3] = (m) => (a.entry.model.code = m)),
                    scope: o.value,
                    placeholder: p2,
                  },
                  null,
                  8,
                  ["modelValue", "scope"]
                ))
              : z("", !0),
          ])
        );
      };
    },
  }),
  h2 = B(f2, [["__scopeId", "data-v-6bb936b3"]]),
  m2 = { class: "ConstraintComponentList" },
  fu = S({
    __name: "ConstraintComponentList",
    props: { entries: {} },
    emits: ["remove"],
    setup(t) {
      const e = t,
        n = b(() => e.entries.map((s) => s.name));
      return (s, o) => (
        d(),
        C("div", m2, [
          (d(!0),
          C(
            Z,
            null,
            se(
              s.entries,
              (r, l) => (
                d(),
                w(
                  h2,
                  {
                    key: l,
                    entry: r,
                    "all-custom-components": n.value,
                    onRemove: o[0] || (o[0] = (i) => s.$emit("remove", i)),
                  },
                  null,
                  8,
                  ["entry", "all-custom-components"]
                )
              )
            ),
            128
          )),
        ])
      );
    },
  }),
  g2 = { components: { Icon: he } };
function v2(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "Plus", viewBox: "0 0 7 7" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h("path", { d: "M0 3h3v-3h1v3h3v1h-3v3h-1v-3h-3z" }, null, -1),
            ])
        ),
        _: 1,
      }
    )
  );
}
const es = B(g2, [["render", v2]]);
function y2(t, e) {
  for (;;) {
    const n = t(
      Math.floor(Math.random() * 16 * 16 * 16 * 16)
        .toString(16)
        .toUpperCase()
    );
    if (!e.has(n)) return n;
  }
}
const C2 = { class: "components" },
  w2 = { class: "components" },
  b2 = decodeURIComponent(
    "%2F%2F%20Enter%20code%20that%20places%20constraint%20components%20here.%20E.g.%3A%0A%2F%2F%20for%20(const%20group%20of%20input.groups)%20%7B%0A%2F%2F%20%20%20const%20name%20%3D%20helpers.naming.getCellsDescription(group.cells)%0A%2F%2F%20%20%20puzzle.addConstraintComponent(new%20DifferentDigitsComponent(name%2C%20group.cells))%0A%2F%2F%20%7D%0A%2F%2F%0A%2F%2F%20puzzle.addConstraintComponent(new%20SameSumComponent(%0A%2F%2F%20%20%20'the%20equal-sum%20constraint'%2C%0A%2F%2F%20%20%20input.groups.map(group%20%3D%3E%20(%7B%0A%2F%2F%20%20%20%20%20name%3A%20helpers.naming.getCellsDescription(group.cells)%2C%0A%2F%2F%20%20%20%20%20cells%3A%20group.cells%0A%2F%2F%20%20%20%7D))%0A%2F%2F%20))"
  ),
  k2 = S({
    __name: "BackendEditor",
    props: { backend: {}, components: {} },
    setup(t) {
      const e = t,
        n = b(() => e.backend),
        s = b(() => e.components),
        o = b(() => ({
          ...cd("backend"),
          ...Object.fromEntries(e.components.map((u) => [u.name, {}])),
        }));
      function r() {
        s.value.push({
          type: "code",
          name: y2(
            (u) => `CustomComponent${u}`,
            new Set(s.value.map((u) => u.name))
          ),
          code: "",
        });
      }
      function l(u) {
        Pn(s.value, u);
      }
      const i = b(() =>
          [...Zh()]
            .filter((u) => !u.isCustom)
            .sort((u, p) => u.name.localeCompare(p.name))
        ),
        a = b(() =>
          s.value.map((u) => ({
            name: u.name,
            params: [["...params", "any[]"]],
            description: "",
            model: u,
          }))
        );
      return (u, p) => (
        d(),
        C(
          Z,
          null,
          [
            p[2] || (p[2] = h("h3", null, "Implementation", -1)),
            c(
              Ho,
              {
                modelValue: n.value.code,
                "onUpdate:modelValue":
                  p[0] || (p[0] = (m) => (n.value.code = m)),
                placeholder: b2,
                scope: o.value,
                multiline: "",
              },
              null,
              8,
              ["modelValue", "scope"]
            ),
            p[3] || (p[3] = h("h3", null, "Custom components", -1)),
            h("section", C2, [
              c(fu, { entries: a.value, onRemove: l }, null, 8, ["entries"]),
              c(
                te,
                { class: "addComponent", "with-icon": "", onClick: r },
                {
                  default: f(() => [
                    c(es),
                    p[1] ||
                      (p[1] = h("span", null, "New custom component", -1)),
                  ]),
                  _: 1,
                }
              ),
            ]),
            p[4] || (p[4] = h("h3", null, "Standard components", -1)),
            h("section", w2, [
              c(fu, { entries: i.value }, null, 8, ["entries"]),
            ]),
          ],
          64
        )
      );
    },
  }),
  _2 = B(k2, [["__scopeId", "data-v-66772ecb"]]),
  dn = j({ show: !1, options: { header: "", body: "" }, callback: () => {} });
async function hd(t) {
  return (
    (dn.value.options = t),
    (dn.value.show = !0),
    new Promise((e) => {
      dn.value.callback = () => {
        e(), (dn.value.show = !1);
      };
    })
  );
}
async function Rs(t) {
  return await hd({ header: "Whoops! 😕", body: t });
}
const $2 = to({
  formatVersion: sr(Rc),
  name: cs(),
  input: vl(
    ka(
      to({
        id: cs(),
        label: cs(),
        params: h1(to({ type: sr("raw"), valueType: vl(cs()) })),
      })
    )
  ),
  backend: to({ type: sr("code"), code: cs() }),
  components: vl(ka(to({ type: sr("code"), name: cs(), code: cs() }))),
});
function S2(t) {
  const e = m1($2, t);
  if (e.ok) return e.result;
}
function I2(t) {
  let e;
  try {
    e = JSON.parse(t);
  } catch {
    return;
  }
  const n = S2(e);
  if (n)
    return {
      name: n.name,
      backend: n.backend,
      input: n.input || [],
      components: n.components || [],
    };
}
function hu(t) {
  const e = { formatVersion: Rc, name: t.name, backend: t.backend };
  return (
    t.input.length > 0 && (e.input = t.input),
    t.components.length > 0 && (e.components = t.components),
    JSON.stringify(e)
  );
}
const x2 = S({ props: { flex: { type: Boolean, default: !1 } } });
function D2(t, e, n, s, o, r) {
  return (
    d(),
    C(
      "div",
      { class: Ae(["ButtonGroup", { flex: t.flex }]) },
      [G(t.$slots, "default", {}, void 0, !0)],
      2
    )
  );
}
const Yt = B(x2, [
    ["render", D2],
    ["__scopeId", "data-v-e1522e9b"],
  ]),
  M2 = S({
    __name: "ClipboardTarget",
    props: { placeholder: {} },
    emits: ["paste"],
    setup(t, { expose: e, emit: n }) {
      const s = n;
      function o(l, i) {
        i.target.value = "";
      }
      async function r(l) {
        var a;
        const i =
          (a = l.clipboardData) == null ? void 0 : a.getData("text/plain");
        i && s("paste", i);
      }
      return (
        e({ onPaste: r }),
        (l, i) => (
          d(),
          w(
            vt,
            {
              class: "ClipboardTarget",
              placeholder: l.placeholder,
              "onUpdate:value": o,
              onPaste: r,
            },
            null,
            8,
            ["placeholder"]
          )
        )
      );
    },
  }),
  Jl = new Set();
function md() {
  requestAnimationFrame(md);
  for (const t of Jl) t();
}
md();
function zi(t, { immediate: e } = {}) {
  Xt(() => {
    e && t(), Jl.add(t);
  }),
    mi(() => Jl.delete(t));
}
const vo = rn({ rem: 16, width: 100, height: 100, pointerPosition: void 0 });
function gd(t) {
  vo.pointerPosition = { x: t.clientX, y: t.clientY };
}
document.addEventListener("pointerdown", gd);
document.addEventListener("pointermove", gd);
function vd() {
  (vo.rem = Number.parseFloat(
    getComputedStyle(document.documentElement).fontSize
  )),
    (vo.width = window.innerWidth),
    (vo.height = window.innerHeight);
}
function yd() {
  setTimeout(vd, td ? 50 : 0);
}
vd();
window.addEventListener("resize", yd);
screen.orientation.addEventListener("change", () => yd);
function Qr() {
  return vo;
}
const A2 = S({
    __name: "Popover",
    props: {
      target: {},
      align: { default: "left" },
      overlay: { type: Boolean },
      fixate: { type: Boolean },
    },
    emits: ["close"],
    setup(t) {
      const e = t,
        n = j();
      let s;
      const o = j(),
        r = Qr();
      function l() {
        e.target === "mouse" || e.target === "touch" ? a() : u(e.target);
      }
      function i(p) {
        Ce(p, o.value) || (o.value = p);
      }
      function a() {
        var O, V;
        const p = r.width,
          m = r.height,
          g = n.value.clientWidth,
          v = n.value.clientHeight,
          $ = e.target === "mouse" ? { y: 20, x: 10 } : { y: -80, x: 20 };
        let k = (((O = r.pointerPosition) == null ? void 0 : O.x) || 0) + $.x,
          M = (((V = r.pointerPosition) == null ? void 0 : V.y) || 0) + $.y;
        const P = k + g - p,
          x = k,
          A = M + v - m;
        P > 0 && (k -= P),
          x < 0 && (k -= x),
          A > 0 && (M -= A),
          i({ transformOrigin: "0 0", left: `${k}px`, top: `${M}px` });
      }
      function u(p) {
        (!e.fixate || !s) && (s = p.getBoundingClientRect());
        const { left: m, top: g, bottom: v, width: $ } = s,
          k = e.overlay ? g + window.scrollY : v + window.scrollY,
          M = m + $,
          P = m + $ / 2,
          x = r.width,
          A = r.height,
          O = n.value.clientWidth,
          V = n.value.clientHeight;
        let I = m,
          U = k;
        const D = m,
          N = P - O / 2,
          E = M - O;
        switch (e.align) {
          case "stretch":
          case "left": {
            I = D;
            break;
          }
          case "center": {
            I = N;
            break;
          }
          case "right": {
            I = E;
            break;
          }
        }
        const R = I + O - x,
          W = I,
          T = U + V - A;
        R > 0 && (I -= R), W < 0 && (I -= W), T > 0 && (U -= T);
        const Y = (I - D) / (E - D);
        i({
          transformOrigin: `${Y * 100}% 0`,
          left: `${I}px`,
          top: `${U}px`,
          ...(e.align === "stretch" ? { width: `${$}px` } : {}),
        });
      }
      return (
        zi(l, { immediate: !0 }),
        (p, m) =>
          Ln(
            (d(),
            C(
              "div",
              { ref_key: "el", ref: n, class: "Popover", style: We(o.value) },
              [G(p.$slots, "default", {}, void 0, !0)],
              4
            )),
            [[y(fd), () => p.$emit("close")]]
          )
      );
    },
  }),
  el = B(A2, [["__scopeId", "data-v-f69a5989"]]),
  P2 = S({
    props: {
      modal: { type: Boolean, default: !1 },
      hideImmediately: { type: Boolean, default: !1 },
    },
    emits: { backdropClick: (t) => !0 },
    data() {
      return { target: null };
    },
    mounted() {
      this.target = this.$el.parentNode;
    },
  });
function L2(t, e, n, s, o, r) {
  return (
    d(),
    w(sc, { to: "#popups" }, [
      t.target && t.modal
        ? (d(),
          C("div", {
            key: 0,
            class: "backdrop",
            onClick:
              e[0] || (e[0] = st((l) => t.$emit("backdropClick", l), ["stop"])),
          }))
        : z("", !0),
      c(
        Tr,
        { name: t.hideImmediately ? "in" : "inout" },
        {
          default: f(() => [
            t.target
              ? G(
                  t.$slots,
                  "default",
                  {
                    key: 0,
                    target: t.target,
                    class: Ae({ hideImmediately: t.hideImmediately }),
                  },
                  void 0,
                  !0
                )
              : z("", !0),
          ]),
          _: 3,
        },
        8,
        ["name"]
      ),
    ])
  );
}
const Oe = B(P2, [
    ["render", L2],
    ["__scopeId", "data-v-2e071e23"],
  ]),
  tl = S({
    __name: "Dropdown",
    props: {
      show: { type: Boolean },
      align: { default: "left" },
      fixate: { type: Boolean },
      persist: { type: Boolean },
    },
    emits: ["close"],
    setup(t) {
      return (e, n) => (
        d(),
        w(
          Oe,
          {
            modal: e.show,
            onBackdropClick: n[0] || (n[0] = (s) => e.$emit("close")),
          },
          {
            default: f(({ target: s }) => [
              e.persist || e.show
                ? Ln(
                    (d(),
                    w(
                      el,
                      {
                        key: 0,
                        class: "Dropdown",
                        target: s,
                        align: e.align,
                        fixate: e.fixate,
                      },
                      { default: f(() => [G(e.$slots, "default")]), _: 2 },
                      1032,
                      ["target", "align", "fixate"]
                    )),
                    [[bs, !e.persist || e.show]]
                  )
                : z("", !0),
            ]),
            _: 3,
          },
          8,
          ["modal"]
        )
      );
    },
  }),
  E2 = ["disabled"],
  F2 = S({
    __name: "DropdownItem",
    props: { disabled: { type: Boolean } },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "button",
          { class: "DropdownItem", disabled: e.disabled },
          [G(e.$slots, "default", {}, void 0, !0)],
          8,
          E2
        )
      );
    },
  }),
  Ge = B(F2, [["__scopeId", "data-v-46b903fb"]]),
  B2 = { components: { Icon: he } };
function z2(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "CaretDown", viewBox: "0 0 10 7" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h("path", { d: "m0 2 2-2 3 3 3-3 2 2-5 5-5-5Z" }, null, -1),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Ri = B(B2, [["render", z2]]),
  R2 = { class: "DropdownSelect" },
  O2 = S({
    __name: "DropdownSelect",
    props: {
      options: {},
      modelValue: {},
      fallbackText: { default: "unknown" },
      multiple: { type: Boolean },
      dropdownAlign: { default: "stretch" },
    },
    emits: ["update:modelValue"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = j({}),
        r = b(() => {
          const v = {};
          for (const $ of n.options) v[$.value] = $.label;
          return v;
        }),
        l = b(() => r.value[n.modelValue] || n.fallbackText);
      function i(v, $) {
        $ ? (o.value[v] = $ instanceof Element ? $ : $.$el) : delete o.value[v];
      }
      const a = j(!1),
        u = j();
      function p() {
        (a.value = !0),
          wn(() => {
            if (n.modelValue === void 0) return;
            const v = Array.isArray(n.modelValue)
                ? n.modelValue[0]
                : n.modelValue,
              $ = o.value[v];
            $ == null || $.focus();
          });
      }
      function m() {
        var v;
        a.value && ((a.value = !1), (v = u.value) == null || v.focus());
      }
      function g(v) {
        if (v === n.modelValue) {
          m();
          return;
        }
        s("update:modelValue", v);
      }
      return (
        ae(() => n.modelValue, m),
        (v, $) => (
          d(),
          C("div", R2, [
            c(
              te,
              {
                ref_key: "button",
                ref: u,
                class: "value",
                type: "button",
                onClick: p,
              },
              { default: f(() => [F(X(l.value) + " ", 1), c(Ri)]), _: 1 },
              512
            ),
            c(
              tl,
              {
                show: a.value,
                align: v.dropdownAlign,
                onClose: $[0] || ($[0] = (k) => (a.value = !1)),
              },
              {
                default: f(() => [
                  (d(!0),
                  C(
                    Z,
                    null,
                    se(
                      v.options,
                      (k) => (
                        d(),
                        w(
                          Ge,
                          {
                            key: k.value,
                            ref_for: !0,
                            ref: (M) => i(k.value, M),
                            onClick: (M) => g(k.value),
                          },
                          { default: f(() => [F(X(k.label), 1)]), _: 2 },
                          1032,
                          ["onClick"]
                        )
                      )
                    ),
                    128
                  )),
                ]),
                _: 1,
              },
              8,
              ["show", "align"]
            ),
          ])
        )
      );
    },
  }),
  qs = B(O2, [["__scopeId", "data-v-161ba096"]]),
  N2 = S({
    __name: "FlexLayout",
    props: {
      tag: { default: "div" },
      align: { default: void 0 },
      vertical: { type: Boolean },
      inline: { type: Boolean, default: !1 },
      gap: { type: Boolean, default: !1 },
    },
    setup(t) {
      const e = t,
        n = b(() => {
          const s = [];
          return (
            e.align && s.push(`align-${e.align}`),
            e.vertical && s.push("vertical"),
            e.inline && s.push("inline"),
            e.gap && s.push("gap"),
            s
          );
        });
      return (s, o) => (
        d(),
        w(
          qe(s.tag),
          { class: Ae(["FlexLayout", n.value]) },
          { default: f(() => [G(s.$slots, "default", {}, void 0, !0)]), _: 3 },
          8,
          ["class"]
        )
      );
    },
  }),
  be = B(N2, [["__scopeId", "data-v-b4052b1a"]]),
  T2 = { components: { Icon: he } };
function V2(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "Cross", viewBox: "0 0 16 16" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M3.72 3.72a.75.75 0 011.06 0L8 6.94l3.22-3.22a.75.75 0 111.06 1.06L9.06 8l3.22 3.22a.75.75 0 11-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 01-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 010-1.06z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Ks = B(T2, [["render", V2]]),
  j2 = { style: { flex: "1" } },
  U2 = S({
    __name: "FileUploadPreview",
    props: { text: {} },
    emits: ["remove"],
    setup(t) {
      return (e, n) => (
        d(),
        w(
          be,
          { class: "FileUploadPreview", align: "center" },
          {
            default: f(() => [
              h("span", j2, X(e.text), 1),
              c(
                te,
                {
                  icon: "",
                  onClick: n[0] || (n[0] = (s) => e.$emit("remove")),
                },
                { default: f(() => [c(Ks)]), _: 1 }
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  Ql = B(U2, [["__scopeId", "data-v-ea6388f9"]]),
  H2 = {},
  W2 = { class: "FormFooter" };
function Z2(t, e) {
  return d(), C("div", W2, [G(t.$slots, "default", {}, void 0, !0)]);
}
const Ft = B(H2, [
    ["render", Z2],
    ["__scopeId", "data-v-cef1d8da"],
  ]),
  G2 = S({
    props: {
      label: { type: String, default: "" },
      disabled: { type: Boolean, default: !1 },
      clickable: { type: Boolean, default: !1 },
      vertical: { type: Boolean, default: !1 },
      topAlignLabel: { type: Boolean, default: !1 },
    },
    emits: { labelClick: () => !0 },
    data() {
      return { controlId: `control-${fe()}` };
    },
  }),
  q2 = ["for"];
function K2(t, e, n, s, o, r) {
  return (
    d(),
    C(
      "div",
      {
        class: Ae([
          "FormRow",
          {
            vertical: t.vertical,
            topAlignLabel: t.topAlignLabel,
            disabled: t.disabled,
          },
        ]),
      },
      [
        h(
          "label",
          {
            class: Ae({ clickable: t.clickable }),
            for: t.controlId,
            onClick: e[0] || (e[0] = (l) => t.$emit("labelClick")),
          },
          [G(t.$slots, "label", {}, () => [F(X(t.label), 1)], !0)],
          10,
          q2
        ),
        G(t.$slots, "default", { controlId: t.controlId }, void 0, !0),
      ],
      2
    )
  );
}
const ve = B(G2, [
    ["render", K2],
    ["__scopeId", "data-v-e17233b5"],
  ]),
  X2 = {
    components: { Icon: he },
    computed: {
      animatedBlocks() {
        return [
          { x: 0, y: 0 },
          { x: 1, y: 0 },
          { x: 2, y: 0 },
          { x: 2, y: 1 },
          { x: 2, y: 2 },
          { x: 1, y: 2 },
          { x: 0, y: 2 },
          { x: 0, y: 1 },
        ];
      },
    },
  },
  Y2 = ["x", "y"],
  J2 = ["begin"];
function Q2(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "LoadingIcon", viewBox: "0 0 20 20" },
      {
        default: f(() => [
          e[0] ||
            (e[0] = h(
              "rect",
              { x: "8", y: "8", height: "4", width: "4", fill: "#0004" },
              null,
              -1
            )),
          (d(!0),
          C(
            Z,
            null,
            se(
              r.animatedBlocks,
              ({ x: i, y: a }, u) => (
                d(),
                C(
                  "rect",
                  {
                    key: u,
                    x: i * 6 + 2,
                    y: a * 6 + 2,
                    height: "4",
                    width: "4",
                    fill: "#0004",
                  },
                  [
                    h(
                      "animate",
                      {
                        attributeName: "fill",
                        values: "#000;#0004;#0004",
                        keyTimes: "0;0.125;1",
                        dur: "1s",
                        repeatCount: "indefinite",
                        begin: `${u / 8}s`,
                        calcMode: "discrete",
                      },
                      null,
                      8,
                      J2
                    ),
                  ],
                  8,
                  Y2
                )
              )
            ),
            128
          )),
        ]),
        _: 1,
      }
    )
  );
}
const ey = B(X2, [["render", Q2]]),
  ty = {};
function ny(t, e) {
  return (
    d(),
    w(
      Tr,
      { name: "fade" },
      { default: f(() => [G(t.$slots, "default")]), _: 3 }
    )
  );
}
const Cd = B(ty, [["render", ny]]),
  sy = S({
    components: { LoadingIcon: ey, Fade: Cd, FormButton: te },
    props: {
      loading: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      withIcon: { type: Boolean, default: !1 },
    },
  }),
  oy = { key: 0, class: "rotatingIcon" };
function ry(t, e, n, s, o, r) {
  const l = H("LoadingIcon"),
    i = H("Fade"),
    a = H("FormButton");
  return (
    d(),
    w(
      a,
      { class: "LoadingButton", disabled: t.disabled, "with-icon": t.withIcon },
      {
        default: f(() => [
          G(t.$slots, "default", {}, void 0, !0),
          c(i, null, {
            default: f(() => [
              t.loading ? (d(), C("div", oy, [c(l)])) : z("", !0),
            ]),
            _: 1,
          }),
        ]),
        _: 3,
      },
      8,
      ["disabled", "with-icon"]
    )
  );
}
const nl = B(sy, [
    ["render", ry],
    ["__scopeId", "data-v-d30ab2f6"],
  ]),
  ro = [],
  ly = ["onKeydown"],
  iy = S({
    __name: "ModalBase",
    props: {
      dismissible: { type: Boolean },
      backdropDismissible: { type: Boolean },
    },
    emits: ["close"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = j(),
        r = j();
      function l(a) {
        !n.dismissible ||
          !n.backdropDismissible ||
          (a.target === r.value && s("close", a));
      }
      function i(a) {
        n.dismissible && s("close", a);
      }
      return (
        Xt(() => {
          const a = o.value;
          ro.push({ modal: a, lastFocus: document.activeElement }),
            a.contains(document.activeElement) || a.focus();
        }),
        mi(() => {
          var u;
          const a = ro.findIndex((p) => p.modal === o.value);
          a > -1 &&
            (a === ro.length - 1 &&
              ((u = ro[a].lastFocus) == null || u.focus()),
            ro.splice(a, 1));
        }),
        (a, u) => (
          d(),
          C(
            "div",
            {
              ref_key: "element",
              ref: o,
              class: "Modal",
              tabindex: "0",
              onKeydown: Dn(st(i, ["stop"]), ["esc"]),
            },
            [
              h(
                "div",
                {
                  ref_key: "backdrop",
                  ref: r,
                  class: "backdrop",
                  onPointerdown: l,
                },
                [G(a.$slots, "default", {}, void 0, !0)],
                544
              ),
            ],
            40,
            ly
          )
        )
      );
    },
  }),
  wd = B(iy, [["__scopeId", "data-v-fa9555cb"]]),
  ay = S({
    __name: "ModalContainer",
    props: {
      width: { default: 30 },
      dismissible: { type: Boolean },
      variant: { default: "responsive" },
    },
    emits: ["close"],
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "div",
          {
            class: Ae(["ModalContainer", e.variant]),
            style: We({ width: `${e.width}rem` }),
          },
          [
            e.dismissible
              ? (d(),
                w(
                  te,
                  {
                    key: 0,
                    class: "closeButton",
                    icon: "",
                    onClick: n[0] || (n[0] = (s) => e.$emit("close", s)),
                  },
                  {
                    default: f(() => [c(Ks, { style: { scale: "1.5" } })]),
                    _: 1,
                  }
                ))
              : z("", !0),
            G(e.$slots, "default", {}, void 0, !0),
          ],
          6
        )
      );
    },
  }),
  bd = B(ay, [["__scopeId", "data-v-d0b78540"]]),
  uy = S({
    __name: "Modal",
    props: {
      width: { default: 30 },
      dismissible: { type: Boolean, default: !0 },
      backdropDismissible: { type: Boolean, default: !0 },
      variant: {},
      responsiveFlex: { type: Boolean },
    },
    emits: ["close"],
    setup(t) {
      return (e, n) => (
        d(),
        w(
          wd,
          {
            dismissible: e.dismissible,
            "backdrop-dismissible": e.backdropDismissible,
            onClose: n[1] || (n[1] = (s) => e.$emit("close", s)),
          },
          {
            default: f(() => [
              c(
                bd,
                {
                  width: e.width,
                  dismissible: e.dismissible,
                  variant: e.variant,
                  class: Ae({ responsiveFlex: e.responsiveFlex }),
                  onClose: n[0] || (n[0] = (s) => e.$emit("close", s)),
                },
                {
                  default: f(() => [G(e.$slots, "default", {}, void 0, !0)]),
                  _: 3,
                },
                8,
                ["width", "dismissible", "variant", "class"]
              ),
            ]),
            _: 3,
          },
          8,
          ["dismissible", "backdrop-dismissible"]
        )
      );
    },
  }),
  Bt = B(uy, [["__scopeId", "data-v-122f77ca"]]),
  cy = {},
  dy = { class: "ModalHeader" };
function py(t, e) {
  return (
    d(),
    C("div", dy, [
      h("h1", null, [G(t.$slots, "default", {}, void 0, !0)]),
      G(t.$slots, "extra", {}, void 0, !0),
    ])
  );
}
const un = B(cy, [
    ["render", py],
    ["__scopeId", "data-v-e9987a7c"],
  ]),
  fy = {},
  hy = { class: "UiSpacer" };
function my(t, e) {
  return d(), C("div", hy);
}
const Je = B(fy, [
  ["render", my],
  ["__scopeId", "data-v-5c6887a5"],
]);
function Oi(t) {
  const e = document.createElement("input");
  (e.type = "file"), (e.accept = "application/json");
  const n = j(null),
    s = new Uo();
  return (
    e.addEventListener("change", (i) => {
      (n.value = i.target.files), s.emit("change", n.value);
    }),
    {
      open: () => {
        e.click();
      },
      clear: () => {
        e.value = "";
      },
      files: n,
      addEventListener: (i) => {
        Pt(s, "change", i);
      },
    }
  );
}
const gy = { components: { Icon: he } };
function vy(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "OpenIcon", viewBox: "0 0 12 12" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M2.4 11H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h2.11l.89.9h3a1 1 0 0 1 1 1v.58",
                  fill: "none",
                  stroke: "currentColor",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M2.8 4.23c.12-.46.7-.74 1.2-.73h5.97c.44 0 .92.28.8.74-.53 1.96-1.05 4.07-1.57 6.03-.13.46-.72.73-1.2.73H2c-.44 0-.92-.28-.8-.74.53-1.98 1.06-4.05 1.6-6.03Z",
                  fill: "none",
                  stroke: "currentColor",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Wo = B(gy, [["render", vy]]),
  yy = S({
    __name: "LoadConstraintDialog",
    props: { constraint: {} },
    emits: ["load", "close"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        { project: o } = ke(),
        r = j();
      function l(O) {
        var V;
        (V = r.value) == null || V.onPaste(O);
      }
      const i = b(() =>
          o.value.allConstraints.filter((O) => O.config.type === _.Custom)
        ),
        a = j(!1),
        u = j(),
        p = j("this"),
        m = b({
          get() {
            var O;
            return !u.value || p.value !== "this"
              ? -1
              : ((O = i.value.find((V) => Ce(V.config.definition, u.value))) ==
                null
                  ? void 0
                  : O.id) || -1;
          },
          set(O) {
            var V;
            (u.value = ue(
              (V = i.value.find((I) => I.id === O)) == null
                ? void 0
                : V.config.definition
            )),
              (p.value = "this");
          },
        }),
        g = b(() =>
          o.value.allConstraints
            .filter((O) => {
              var V;
              return (
                O.id !== ((V = n.constraint) == null ? void 0 : V.id) &&
                O.config.type === _.Custom
              );
            })
            .map((O) => ({ label: O.config.definition.name, value: O.id }))
        ),
        { open: v, addEventListener: $, clear: k } = Oi();
      $((O) => {
        if (O === null || O.length === 0) return;
        const V = new FileReader();
        V.readAsText(O[0]),
          V.addEventListener("load", () => {
            const I = V.result;
            x(I) && (p.value = "file");
          });
      });
      function M() {
        (u.value = void 0), k();
      }
      function P(O) {
        x(O) && (p.value = "clipboard");
      }
      function x(O) {
        const V = I2(O);
        return (
          V
            ? (u.value = V)
            : hd({
                header: "Error",
                body: "Unable to import custom constraint: format not supported or data is corrupt.",
              }),
          V
        );
      }
      function A() {
        u.value && s("load", u.value);
      }
      return (O, V) => (
        d(),
        w(
          Bt,
          {
            class: "LoadConstraintDialog",
            variant: "content",
            onClose: V[4] || (V[4] = (I) => O.$emit("close")),
            onPaste: l,
          },
          {
            default: f(() => [
              c(un, null, {
                default: f(
                  () => V[5] || (V[5] = [F("Load custom constraint")])
                ),
                _: 1,
              }),
              h(
                "form",
                { onSubmit: st(A, ["prevent"]) },
                [
                  c(
                    be,
                    { vertical: "", gap: "" },
                    {
                      default: f(() => [
                        g.value.length > 0
                          ? (d(),
                            w(
                              ve,
                              {
                                key: 0,
                                vertical: "",
                                label: "From this puzzle",
                                disabled: !!u.value && p.value !== "this",
                              },
                              {
                                default: f(() => [
                                  c(Yt, null, {
                                    default: f(() => [
                                      c(
                                        qs,
                                        {
                                          modelValue: m.value,
                                          "onUpdate:modelValue":
                                            V[0] ||
                                            (V[0] = (I) => (m.value = I)),
                                          options: g.value,
                                          "dropdown-align": "left",
                                          "fallback-text": "Select",
                                          style: { flex: "1" },
                                        },
                                        {
                                          default: f(
                                            () =>
                                              V[6] || (V[6] = [F(" Select ")])
                                          ),
                                          _: 1,
                                        },
                                        8,
                                        ["modelValue", "options"]
                                      ),
                                      u.value && p.value === "this"
                                        ? (d(),
                                          w(
                                            te,
                                            {
                                              key: 0,
                                              icon: "",
                                              onClick:
                                                V[1] ||
                                                (V[1] = (I) =>
                                                  (u.value = void 0)),
                                            },
                                            { default: f(() => [c(Ks)]), _: 1 }
                                          ))
                                        : z("", !0),
                                    ]),
                                    _: 1,
                                  }),
                                ]),
                                _: 1,
                              },
                              8,
                              ["disabled"]
                            ))
                          : z("", !0),
                        c(
                          ve,
                          {
                            label: "From a Constraint Maker file",
                            vertical: "",
                            disabled: !!u.value && p.value !== "file",
                          },
                          {
                            default: f(() => [
                              u.value && p.value === "file"
                                ? (d(),
                                  w(
                                    Ql,
                                    {
                                      key: 0,
                                      text: `Loaded constraint: ${u.value.name}`,
                                      onRemove: M,
                                    },
                                    null,
                                    8,
                                    ["text"]
                                  ))
                                : (d(),
                                  w(
                                    te,
                                    { key: 1, onClick: y(v) },
                                    {
                                      default: f(
                                        () =>
                                          V[7] || (V[7] = [F(" Select file ")])
                                      ),
                                      _: 1,
                                    },
                                    8,
                                    ["onClick"]
                                  )),
                            ]),
                            _: 1,
                          },
                          8,
                          ["disabled"]
                        ),
                        c(
                          ve,
                          {
                            label: "From the clipboard",
                            vertical: "",
                            disabled: !!u.value && p.value !== "clipboard",
                          },
                          {
                            default: f(() => [
                              u.value && p.value === "clipboard"
                                ? (d(),
                                  w(
                                    Ql,
                                    {
                                      key: 0,
                                      text: u.value.name,
                                      onRemove:
                                        V[2] ||
                                        (V[2] = (I) => (u.value = void 0)),
                                    },
                                    null,
                                    8,
                                    ["text"]
                                  ))
                                : (d(),
                                  w(
                                    M2,
                                    {
                                      key: 1,
                                      ref_key: "clipboardTarget",
                                      ref: r,
                                      placeholder:
                                        "Paste your clipboard data here or press ctrl/cmd+V",
                                      onPaste: P,
                                    },
                                    null,
                                    512
                                  )),
                            ]),
                            _: 1,
                          },
                          8,
                          ["disabled"]
                        ),
                      ]),
                      _: 1,
                    }
                  ),
                  c(Ft, null, {
                    default: f(() => [
                      c(
                        te,
                        { onClick: V[3] || (V[3] = (I) => O.$emit("close")) },
                        {
                          default: f(() => V[8] || (V[8] = [F(" Cancel ")])),
                          _: 1,
                        }
                      ),
                      c(Je),
                      c(
                        nl,
                        {
                          type: "submit",
                          "with-icon": "",
                          disabled: !u.value,
                          loading: a.value,
                        },
                        {
                          default: f(() => [
                            V[9] || (V[9] = h("span", null, "Load", -1)),
                            c(Wo),
                          ]),
                          _: 1,
                        },
                        8,
                        ["disabled", "loading"]
                      ),
                    ]),
                    _: 1,
                  }),
                ],
                32
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  });
function Dt(t, e, n, s) {
  const o = Rn(t) ? t : j(t);
  ae(
    o,
    (r, l) => {
      l && l.removeEventListener(e, n, s), r && r.addEventListener(e, n, s);
    },
    { immediate: !0 }
  ),
    zo(() => {
      var r;
      (r = o.value) == null || r.removeEventListener(e, n, s);
    });
}
const Cy = { components: { Icon: he } };
function wy(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "VerticalDots", viewBox: "0 0 6 16", stroke: "none" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h("circle", { r: "2", cx: "3", cy: "3" }, null, -1),
              h("circle", { r: "2", cx: "3", cy: "8" }, null, -1),
              h("circle", { r: "2", cx: "3", cy: "13" }, null, -1),
            ])
        ),
        _: 1,
      }
    )
  );
}
const by = B(Cy, [["render", wy]]),
  sl = S({
    __name: "DropdownButton",
    props: {
      variant: { default: "default" },
      align: { default: "center" },
      persist: { type: Boolean },
    },
    setup(t) {
      const e = j(!1),
        n = j();
      return (
        Dt(n, "click", () => {
          e.value = !1;
        }),
        (s, o) => (
          d(),
          w(
            te,
            {
              class: "DropdownButton",
              icon: "",
              variant: s.variant,
              onClick: o[1] || (o[1] = st((r) => (e.value = !0), ["stop"])),
            },
            {
              default: f(() => [
                G(s.$slots, "icon", {}, () => [c(by)]),
                c(
                  tl,
                  {
                    show: e.value,
                    align: s.align,
                    persist: s.persist,
                    onClose: o[0] || (o[0] = (r) => (e.value = !1)),
                  },
                  {
                    default: f(() => [
                      h(
                        "div",
                        { ref_key: "dropdown", ref: n },
                        [G(s.$slots, "default")],
                        512
                      ),
                    ]),
                    _: 3,
                  },
                  8,
                  ["show", "align", "persist"]
                ),
              ]),
              _: 3,
            },
            8,
            ["variant"]
          )
        )
      );
    },
  }),
  ky = S({
    components: { PopupWrapper: Oe, Popover: el },
    props: {
      text: { type: String, default: "" },
      delay: { type: Boolean, default: !1 },
      triggerOnTouch: { type: Boolean, default: !1 },
    },
    data() {
      return {
        visible: !1,
        pointer: "mouse",
        requestedVisibility: !1,
        trigger: null,
      };
    },
    watch: {
      requestedVisibility(t) {
        if (!t) {
          this.visible = !1;
          return;
        }
        this.delay
          ? setTimeout(() => {
              this.requestedVisibility && (this.visible = !0);
            }, 1e3)
          : (this.visible = t);
      },
    },
    mounted() {
      var t, e, n;
      (this.trigger = this.$el.parentNode),
        (t = this.trigger) == null ||
          t.addEventListener("pointerenter", this.onPointerEnter, !1),
        (e = this.trigger) == null ||
          e.addEventListener("pointerleave", this.onPointerLeave, !1),
        (n = this.trigger) == null ||
          n.addEventListener("pointerdown", this.onPointerDown, !1);
    },
    beforeUnmount() {
      var t, e, n;
      (t = this.trigger) == null ||
        t.removeEventListener("pointerenter", this.onPointerEnter, !1),
        (e = this.trigger) == null ||
          e.removeEventListener("pointerleave", this.onPointerLeave, !1),
        (n = this.trigger) == null ||
          n.removeEventListener("pointerdown", this.onPointerDown, !1);
    },
    methods: {
      show() {
        this.requestedVisibility || (this.requestedVisibility = !0);
      },
      hide() {
        this.requestedVisibility = !1;
      },
      onPointerEnter(t) {
        t.pointerType === "mouse" && ((this.pointer = "mouse"), this.show());
      },
      onPointerDown(t) {
        t.pointerType === "mouse" ||
          !this.triggerOnTouch ||
          ((this.pointer = "touch"),
          this.requestedVisibility ? this.hide() : this.show());
      },
      onPointerLeave(t) {
        t.pointerType === "mouse" && this.hide();
      },
      getTarget(t) {
        return this.pointer === "touch" ? t : "mouse";
      },
    },
  });
function _y(t, e, n, s, o, r) {
  const l = H("Popover"),
    i = H("PopupWrapper");
  return (
    d(),
    w(
      i,
      {
        "hide-immediately": "",
        modal: t.visible && t.pointer === "touch",
        onBackdropClick: t.hide,
      },
      {
        default: f(({ target: a }) => [
          t.visible
            ? (d(),
              w(
                l,
                { key: 0, class: "Tooltip", target: t.getTarget(a) },
                {
                  default: f(() => [
                    G(t.$slots, "default", {}, () => [F(X(t.text), 1)], !0),
                  ]),
                  _: 2,
                },
                1032,
                ["target"]
              ))
            : z("", !0),
        ]),
        _: 3,
      },
      8,
      ["modal", "onBackdropClick"]
    )
  );
}
const Te = B(ky, [
    ["render", _y],
    ["__scopeId", "data-v-2c2cfb40"],
  ]),
  $y = { components: { Icon: he } };
function Sy(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      {
        class: "CopyIcon",
        viewBox: "0 0 12 14",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
      },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                { d: "M3 3H1v10h8v-2", fill: "none", stroke: "currentColor" },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M9 1H3v10h8V3L9 1Z",
                  fill: "none",
                  stroke: "currentColor",
                },
                null,
                -1
              ),
              h(
                "path",
                { d: "M8 1v3h3", fill: "none", stroke: "currentColor" },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Ni = B($y, [["render", Sy]]),
  Iy = { components: { Icon: he } };
function xy(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "TrashBin", viewBox: "0 0 16 16" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M15 4v10a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h1v4.5a.5.5 0 0 0 .5.5H11a.5.5 0 0 0 .5-.5V1h.5l3 3Zm-1.5 4a.5.5 0 0 0-.5-.5H3a.5.5 0 0 0-.5.5v5a.5.5 0 0 0 .5.5h10a.5.5 0 0 0 .5-.5V8Z",
                },
                null,
                -1
              ),
              h(
                "path",
                { d: "M10.5 1H7v3.5a.5.5 0 0 0 .5.5H10a.5.5 0 0 0 .5-.5V1Z" },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const mu = B(Iy, [["render", xy]]);
async function kd({ value: t, mimeType: e = "text/plain" }) {
  if (window.ClipboardItem && navigator.clipboard.write)
    await navigator.clipboard.write([
      new ClipboardItem({
        [e]: Promise.resolve(t).then((n) =>
          typeof n == "string" ? new Blob([n], { type: e }) : n
        ),
      }),
    ]);
  else {
    const n = await t;
    if (typeof n != "string") {
      window.alert(
        "Copying files to clipboard is not supported on this platform"
      );
      return;
    }
    await navigator.clipboard.writeText(n);
  }
}
function _d(t, e) {
  const n = document.createElement("a");
  (n.href = t),
    (n.download = e),
    document.body.appendChild(n),
    n.click(),
    document.body.removeChild(n);
}
function $d(t, e) {
  const n = URL.createObjectURL(t);
  _d(n, e),
    setTimeout(() => {
      URL.revokeObjectURL(n);
    }, 1e3);
}
const Dy = S({
    __name: "SaveShareDropdown",
    props: { definition: {} },
    setup(t) {
      const e = t;
      function n() {
        kd({ value: hu(e.definition) });
      }
      function s() {
        const o = new Blob([hu(e.definition)], { type: "application/json" }),
          r = URL.createObjectURL(o);
        _d(r, `${e.definition.name}.json`), URL.revokeObjectURL(r);
      }
      return (o, r) => (
        d(),
        w(sl, null, {
          icon: f(() => [c(mu), c(Te, { text: "Save/share" })]),
          default: f(() => [
            c(
              Ge,
              { onClick: n },
              {
                default: f(() => [
                  c(Ni),
                  r[0] || (r[0] = F(" Copy to clipboard ")),
                ]),
                _: 1,
              }
            ),
            c(
              Ge,
              { onClick: s },
              {
                default: f(() => [
                  c(mu),
                  r[1] || (r[1] = F(" Save as Constraint Maker-file ")),
                ]),
                _: 1,
              }
            ),
          ]),
          _: 1,
        })
      );
    },
  }),
  bt = rn({ show: !1, busy: !1 });
function ws(t) {
  (bt.show = !0),
    (bt.options = t),
    (bt.callback = async () => {
      bt.busy = !0;
      try {
        await t.callback(), (bt.show = !1);
      } catch {}
      bt.busy = !1;
    }),
    (bt.cancelCallback = t.cancelCallback);
}
const My = { class: "AlphaLabel" },
  Ay = S({
    __name: "AlphaLabel",
    setup(t) {
      return (e, n) => (
        d(),
        C("span", My, [
          n[1] || (n[1] = F(" Alpha")),
          c(
            Te,
            { "trigger-on-touch": "" },
            {
              default: f(
                () =>
                  n[0] ||
                  (n[0] = [
                    F(
                      "This feature is in alpha and will be improved upon or changed in the future."
                    ),
                  ])
              ),
              _: 1,
            }
          ),
        ])
      );
    },
  }),
  Sd = B(Ay, [["__scopeId", "data-v-5722500c"]]),
  Py = ["disabled", "checked"],
  Ly = S({
    __name: "CheckBox",
    props: { checked: { type: Boolean }, disabled: { type: Boolean } },
    emits: ["update:checked"],
    setup(t, { emit: e }) {
      const n = e;
      function s(o) {
        const r = o.target.checked;
        n("update:checked", r);
      }
      return (o, r) => (
        d(),
        C(
          "span",
          {
            class: Ae([
              "CheckBox",
              { checked: o.checked, disabled: o.disabled },
            ]),
          },
          [
            h(
              "input",
              {
                type: "checkbox",
                disabled: o.disabled,
                checked: o.checked,
                onInput: s,
              },
              null,
              40,
              Py
            ),
            r[0] ||
              (r[0] = h(
                "svg",
                { viewBox: "0 -2 14 12", class: "tick" },
                [
                  h("path", {
                    d: "M6 10L0 6L2 3L5.5 5.5L11-2L14 0z",
                    fill: "currentColor",
                  }),
                ],
                -1
              )),
          ],
          2
        )
      );
    },
  }),
  at = B(Ly, [["__scopeId", "data-v-89984837"]]),
  Ey = S({
    __name: "InsetScrollContainer",
    props: { vertical: { type: Boolean } },
    setup(t) {
      zn((l) => ({ "589b8393": s.value, "89a95fe0": o.value }));
      const e = t,
        n = j(),
        s = j("0"),
        o = j("0"),
        r = Qr().rem;
      return (
        zi(() => {
          const l = n.value;
          e.vertical
            ? ((s.value = `${Math.min(r, 2 * l.scrollTop) - r}px`),
              (o.value = `${
                Rt(2 * (l.scrollHeight - l.scrollTop - l.clientHeight), 0, r) -
                r
              }px`))
            : ((s.value = `${Math.min(r, 2 * l.scrollLeft) - r}px`),
              (o.value = `${
                Rt(2 * (l.scrollWidth - l.scrollLeft - l.clientWidth), 0, r) - r
              }px`));
        }),
        (l, i) => (
          d(),
          C(
            "div",
            { class: Ae(["InsetScrollContainer", { vertical: l.vertical }]) },
            [
              h(
                "div",
                { ref_key: "element", ref: n, class: "scroller" },
                [G(l.$slots, "default", {}, void 0, !0)],
                512
              ),
            ],
            2
          )
        )
      );
    },
  }),
  Ti = B(Ey, [["__scopeId", "data-v-cb464dad"]]),
  Fy = { class: "header" },
  By = { class: "body" },
  zy = { class: "bodyWrapper" },
  Ry = { key: 0, class: "footer" },
  Oy = S({
    __name: "ComplexModal",
    props: {
      header: {},
      hideFooter: { type: Boolean },
      maxWidth: { default: 70 },
    },
    emits: ["close"],
    setup(t) {
      return (e, n) => (
        d(),
        w(
          wd,
          { onClose: n[1] || (n[1] = (s) => e.$emit("close")) },
          {
            default: f(() => [
              c(
                bd,
                {
                  width: e.maxWidth,
                  variant: "fullscreen",
                  onClose: n[0] || (n[0] = (s) => e.$emit("close")),
                },
                {
                  default: f(() => [
                    h("div", Fy, [
                      G(
                        e.$slots,
                        "header",
                        {},
                        () => [
                          c(un, null, {
                            default: f(() => [F(X(e.header), 1)]),
                            _: 1,
                          }),
                        ],
                        !0
                      ),
                    ]),
                    h("div", By, [
                      c(
                        Ti,
                        { vertical: "" },
                        {
                          default: f(() => [
                            h("div", zy, [G(e.$slots, "body", {}, void 0, !0)]),
                          ]),
                          _: 3,
                        }
                      ),
                    ]),
                    e.hideFooter
                      ? z("", !0)
                      : (d(),
                        C("div", Ry, [G(e.$slots, "footer", {}, void 0, !0)])),
                  ]),
                  _: 3,
                },
                8,
                ["width"]
              ),
            ]),
            _: 3,
          }
        )
      );
    },
  }),
  Id = B(Oy, [["__scopeId", "data-v-73823076"]]),
  Ny = S({ props: { disabled: { type: Boolean, default: !1 } } });
function Ty(t, e, n, s, o, r) {
  return (
    d(),
    C(
      "label",
      { class: Ae(["FormControlLabel", { disabled: t.disabled }]) },
      [G(t.$slots, "default", {}, void 0, !0)],
      2
    )
  );
}
const ut = B(Ny, [
    ["render", Ty],
    ["__scopeId", "data-v-cabe849a"],
  ]),
  Vy = S({
    __name: "WarningIcon",
    setup(t) {
      return (e, n) => (d(), w(Vc, { class: "WarningIcon" }));
    },
  }),
  xd = B(Vy, [["__scopeId", "data-v-f6ac6d4d"]]),
  jy = { class: "content" },
  Uy = S({
    __name: "InfoBlock",
    props: { type: {}, border: { type: Boolean } },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "div",
          { class: Ae(["InfoBlock", { border: e.border }]) },
          [
            e.type === "error"
              ? (d(), w(Vo, { key: 0 }))
              : e.type === "warning"
              ? (d(), w(xd, { key: 1 }))
              : (d(), w(_s, { key: 2 })),
            h("div", jy, [G(e.$slots, "default", {}, void 0, !0)]),
          ],
          2
        )
      );
    },
  }),
  lt = B(Uy, [["__scopeId", "data-v-d29ef57b"]]);
function Hy(t) {
  function e(n) {
    t() && n.preventDefault();
  }
  Xt(() => {
    window.addEventListener("beforeunload", e, { capture: !0 });
  }),
    Nr(() => {
      window.removeEventListener("beforeunload", e, { capture: !0 });
    });
}
const Wy = { components: { Icon: he } };
function Zy(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "Check", viewBox: "0 0 13 10" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h("path", { d: "m0 5 2-2 3 3 6-6 2 2-8 8-5-5Z" }, null, -1),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Dd = B(Wy, [["render", Zy]]),
  Gy = S({
    __name: "CustomConstraintModal",
    props: { constraint: {} },
    emits: ["close"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        { project: o, updateConstraint: r } = ke(),
        l = j(!1),
        i = ue(n.constraint.config.definition),
        a = rn(ue(n.constraint.config.definition));
      Hy(() => !Ce(i, a));
      function u(M) {
        Object.assign(a, M), (l.value = !1);
      }
      const p = b(() => a.input.length === 0);
      function m() {
        a.input.length > 0
          ? (a.input = [])
          : a.input.push({
              id: "groups",
              label: "Groups",
              params: { type: "raw" },
            });
      }
      function g() {
        Ce(a, i)
          ? s("close")
          : ws({
              header: "Unsaved changes",
              body: "This custom constraint has unsaved changes. Are you sure you want to dismiss them?",
              callback: () => s("close"),
            });
      }
      const v = b(() =>
        o.value.allConstraints.filter(
          (M) =>
            M.config.type === _.Custom &&
            (M.id === n.constraint.id ||
              M.config.definition.name === a.name ||
              Ce(M.config.definition, i))
        )
      );
      function $() {
        n.constraint &&
          (v.value.length > 1 && !Ce(i, a)
            ? ws({
                header: "Update all",
                body: "Would you also like to update the implementations of all custom constraints in this Sudoku that previously shared the same implementation and/or name? Clicking “no” will keep these changes exclusive to this instance.",
                callback: () => k(!0),
                cancelCallback: () => k(!1),
              })
            : k(!1));
      }
      function k(M = !1) {
        const P = {};
        for (const A of n.constraint.config.definition.input)
          P[A.id] = A.params.type;
        const x = M ? v.value : [n.constraint];
        for (const A of x)
          r(
            A,
            (O) => {
              O.config.definition = ue(a);
              for (const V of Object.keys(O.config.input))
                O.config.definition.input.find((I) => I.id === V) ||
                  delete O.config.input[V];
              for (const V of Object.keys(O.config.style))
                O.config.definition.input.find((I) => I.id === V) ||
                  delete O.config.input[V];
              for (const V of O.config.definition.input) {
                const I = V.id;
                (!O.config.input[I] || (P[I] && V.params.type !== P[I])) &&
                  (O.config.input[I] = []);
              }
            },
            "update:customImplementation",
            {
              async preUndoHook() {
                return new Promise((O) => {
                  ws({
                    header: "Undo changes?",
                    body: `Are you sure you want to undo your changes to the implementation of “${A.config.definition.name}”?`,
                    callback: () => O(!0),
                    cancelCallback: () => O(!1),
                  });
                });
              },
            }
          );
        s("close");
      }
      return (M, P) => (
        d(),
        w(
          Id,
          {
            class: "CustomConstraintModal",
            header: "Constraint Maker",
            onClose: g,
          },
          {
            header: f(() => [
              c(un, null, {
                default: f(() => [
                  P[3] || (P[3] = F(" Constraint Maker ")),
                  c(Sd),
                ]),
                _: 1,
              }),
              c(Oe, null, {
                default: f(() => [
                  l.value
                    ? (d(),
                      w(
                        yy,
                        {
                          key: 0,
                          constraint: M.constraint,
                          onLoad: u,
                          onClose: P[0] || (P[0] = (x) => (l.value = !1)),
                        },
                        null,
                        8,
                        ["constraint"]
                      ))
                    : z("", !0),
                ]),
                _: 1,
              }),
            ]),
            body: f(() => [
              c(
                lt,
                { class: "experimentNotice" },
                {
                  default: f(
                    () =>
                      P[4] ||
                      (P[4] = [
                        F(
                          " Note: Constraint Maker is currently in early development and everything you see here should be considered "
                        ),
                        h("strong", null, "experimental", -1),
                        F(
                          ". Please be aware that future changes might impact your custom constraints. "
                        ),
                      ])
                  ),
                  _: 1,
                }
              ),
              c(
                be,
                { vertical: "" },
                {
                  default: f(() => [
                    c(
                      be,
                      { vertical: "", gap: "", class: "properties" },
                      {
                        default: f(() => [
                          c(
                            ve,
                            { label: "Constraint name" },
                            {
                              default: f(() => [
                                c(
                                  vt,
                                  {
                                    value: a.name,
                                    "onUpdate:value":
                                      P[1] || (P[1] = (x) => (a.name = x)),
                                    size: 2,
                                    style: { flex: "1" },
                                  },
                                  null,
                                  8,
                                  ["value"]
                                ),
                              ]),
                              _: 1,
                            }
                          ),
                          P[6] || (P[6] = h("h3", null, "Properties", -1)),
                          c(ut, null, {
                            default: f(() => [
                              c(
                                at,
                                { checked: p.value, "onUpdate:checked": m },
                                null,
                                8,
                                ["checked"]
                              ),
                              P[5] || (P[5] = F(" Global constraint ")),
                            ]),
                            _: 1,
                          }),
                        ]),
                        _: 1,
                      }
                    ),
                    a.input.length > 0
                      ? (d(),
                        w(
                          lt,
                          { key: 0 },
                          {
                            default: f(
                              () =>
                                P[7] ||
                                (P[7] = [
                                  F(
                                    " In code, the groups can be accessed via "
                                  ),
                                  h("code", null, "input.groups", -1),
                                  F(". "),
                                ])
                            ),
                            _: 1,
                          }
                        ))
                      : z("", !0),
                    c(
                      _2,
                      { backend: a.backend, components: a.components },
                      null,
                      8,
                      ["backend", "components"]
                    ),
                  ]),
                  _: 1,
                }
              ),
            ]),
            footer: f(() => [
              c(
                te,
                { onClick: g },
                { default: f(() => P[8] || (P[8] = [F(" Cancel ")])), _: 1 }
              ),
              c(Je),
              c(Yt, null, {
                default: f(() => [
                  c(
                    Dy,
                    { style: { "font-size": "1rem" }, definition: a },
                    null,
                    8,
                    ["definition"]
                  ),
                  c(
                    te,
                    {
                      style: { "font-size": "1rem" },
                      icon: "",
                      onClick: P[2] || (P[2] = (x) => (l.value = !0)),
                    },
                    {
                      default: f(() => [
                        c(Wo),
                        c(Te, { text: "Load implementation" }),
                      ]),
                      _: 1,
                    }
                  ),
                ]),
                _: 1,
              }),
              c(Je),
              c(
                te,
                { "with-icon": "", onClick: $ },
                {
                  default: f(() => [
                    P[9] || (P[9] = h("span", null, "Update", -1)),
                    c(Dd),
                  ]),
                  _: 1,
                }
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  qy = B(Gy, [["__scopeId", "data-v-c80f3a7d"]]),
  Ky = "modulepreload",
  Xy = function (t) {
    return "/" + t;
  },
  gu = {},
  Md = function (e, n, s) {
    let o = Promise.resolve();
    if (n && n.length > 0) {
      document.getElementsByTagName("link");
      const r = document.querySelector("meta[property=csp-nonce]"),
        l =
          (r == null ? void 0 : r.nonce) ||
          (r == null ? void 0 : r.getAttribute("nonce"));
      o = Promise.all(
        n.map((i) => {
          if (((i = Xy(i)), i in gu)) return;
          gu[i] = !0;
          const a = i.endsWith(".css"),
            u = a ? '[rel="stylesheet"]' : "";
          if (document.querySelector(`link[href="${i}"]${u}`)) return;
          const p = document.createElement("link");
          if (
            ((p.rel = a ? "stylesheet" : Ky),
            a || ((p.as = "script"), (p.crossOrigin = "")),
            (p.href = i),
            l && p.setAttribute("nonce", l),
            document.head.appendChild(p),
            a)
          )
            return new Promise((m, g) => {
              p.addEventListener("load", m),
                p.addEventListener("error", () =>
                  g(new Error(`Unable to preload CSS for ${i}`))
                );
            });
        })
      );
    }
    return o
      .then(() => e())
      .catch((r) => {
        const l = new Event("vite:preloadError", { cancelable: !0 });
        if (((l.payload = r), window.dispatchEvent(l), !l.defaultPrevented))
          throw r;
      });
  },
  Yy = {},
  Jy = { class: "ChangelogEntryMeta" };
function Qy(t, e) {
  return (
    d(),
    C("div", Jy, [h("span", null, [G(t.$slots, "default", {}, void 0, !0)])])
  );
}
const Ad = B(Yy, [
    ["render", Qy],
    ["__scopeId", "data-v-408fdae2"],
  ]),
  e5 = { class: "hash" },
  t5 = { class: "message" },
  n5 = { class: "icon" },
  s5 = { class: "text" },
  o5 = ["innerHTML"],
  r5 = ["innerHTML"],
  l5 = S({
    __name: "ChangelogEntry",
    props: { timestamp: {}, hashes: {}, type: {}, message: {}, details: {} },
    setup(t) {
      const e = t,
        n =
          new Map([
            ["chore", "🧹"],
            ["feature", "✨"],
            ["fix", "🩹"],
          ]).get(e.type) || "🧹";
      return (s, o) => (
        d(),
        C(
          Z,
          null,
          [
            c(Ad, null, {
              default: f(() => [
                s.hashes
                  ? (d(),
                    C(
                      Z,
                      { key: 0 },
                      [
                        F(
                          X(y(Wc)(s.timestamp)) +
                            " - commit" +
                            X(s.hashes.length === 1 ? "" : "s") +
                            " ",
                          1
                        ),
                        h("span", e5, X(s.hashes.join(", ")), 1),
                      ],
                      64
                    ))
                  : z("", !0),
              ]),
              _: 1,
            }),
            h("div", t5, [
              h("div", n5, X(y(n)), 1),
              h("div", s5, [
                h("h4", null, [
                  s.type === "chore"
                    ? (d(),
                      C(
                        Z,
                        { key: 0 },
                        [F(" Code or UX or UI improvements ")],
                        64
                      ))
                    : (d(),
                      C(
                        Z,
                        { key: 1 },
                        [
                          F(X(`${s.type}:`) + " ", 1),
                          h("span", { innerHTML: s.message }, null, 8, o5),
                        ],
                        64
                      )),
                ]),
                s.details
                  ? (d(),
                    C(
                      "div",
                      { key: 0, class: "details", innerHTML: s.details },
                      null,
                      8,
                      r5
                    ))
                  : z("", !0),
              ]),
            ]),
          ],
          64
        )
      );
    },
  }),
  i5 = B(l5, [["__scopeId", "data-v-ffc4e559"]]),
  a5 = ["innerHTML"],
  u5 = S({
    __name: "ChangelogModal",
    setup(t) {
      const n = j();
      return (
        Xt(async () => {
          n.value = (
            await Md(async () => {
              const { changelog: s } = await import(
                "./_virtual_changelog-BBJZ3A1e.js"
              );
              return { changelog: s };
            }, [])
          ).changelog;
        }),
        (s, o) => (
          d(),
          w(
            Bt,
            {
              width: 50,
              variant: "responsive",
              onClose: o[0] || (o[0] = (r) => (n.value = void 0)),
            },
            {
              default: f(() => {
                var r, l, i;
                return [
                  c(un, null, {
                    default: f(() => o[1] || (o[1] = [F("Changelog")])),
                    _: 1,
                  }),
                  (r = n.value) != null && r.html
                    ? (d(),
                      C(
                        "div",
                        {
                          key: 0,
                          class: "htmlContent",
                          innerHTML: (l = n.value) == null ? void 0 : l.html,
                        },
                        null,
                        8,
                        a5
                      ))
                    : (i = n.value) != null && i.items
                    ? (d(),
                      w(
                        be,
                        { key: 1, vertical: "" },
                        {
                          default: f(() => [
                            (d(!0),
                            C(
                              Z,
                              null,
                              se(
                                n.value.items,
                                (a, u) => (
                                  d(),
                                  w(
                                    i5,
                                    St({ key: u, ref_for: !0 }, a),
                                    null,
                                    16
                                  )
                                )
                              ),
                              128
                            )),
                            y(!1)
                              ? (d(),
                                w(
                                  Ad,
                                  { key: 0 },
                                  {
                                    default: f(
                                      () =>
                                        o[2] ||
                                        (o[2] = [
                                          F(" The start of labelled commits "),
                                        ])
                                    ),
                                    _: 1,
                                  }
                                ))
                              : z("", !0),
                          ]),
                          _: 1,
                        }
                      ))
                    : z("", !0),
                ];
              }),
              _: 1,
            }
          )
        )
      );
    },
  }),
  c5 = B(u5, [["__scopeId", "data-v-cd7e241d"]]),
  Pd = "/assets/sudoku-pad-logo-BVU8tb7c.png";
class Mr {
  constructor(e, n = 0) {
    L(this, "grid", {});
    L(this, "segments", []);
    L(this, "pointOffsets");
    for (const s of e) this.grid[`${s.x}_${s.y}`] = s;
    this.pointOffsets = {
      tl: { y: n, x: n },
      tr: { y: n, x: 1 - n },
      bl: { y: 1 - n, x: n },
      br: { y: 1 - n, x: 1 - n },
      tc: { y: n, x: 0.5 },
      rc: { y: 0.5, x: 1 - n },
      bc: { y: 1 - n, x: 0.5 },
      lc: { y: 0.5, x: n },
    };
  }
  isSet(e) {
    return `${e.x}_${e.y}` in this.grid;
  }
  getSvgDString() {
    this.collectSegments();
    const e = [];
    for (; this.segments.length > 0; ) e.push(this.getNextShape());
    const n = [];
    return (
      e.forEach((s) => {
        this.shapeToPoints(s).forEach(({ x: o, y: r }, l) => {
          n.push(`${l === 0 ? "M" : "L"}${o} ${r}`);
        }),
          n.push("Z");
      }),
      n.join("")
    );
  }
  collectSegments() {
    (this.segments = []),
      Object.values(this.grid).forEach(({ x: e, y: n }) => {
        this.getSegmentTypesAtPosition({ x: e, y: n }).forEach((o) => {
          this.segments.push({ x: e, y: n, type: o });
        });
      });
  }
  getSegmentTypesAtPosition(e) {
    const { x: n, y: s } = e,
      o = [];
    for (const r of p5)
      r.pattern.every(({ bit: i, offsetX: a, offsetY: u }) => {
        const p = { x: n + a, y: s + u },
          m = this.isSet(p);
        return i === m;
      }) && o.push(r);
    return o;
  }
  findSegment(e, n) {
    return this.segments.find(
      ({ x: s, y: o, type: r }) => s === e.x && o === e.y && r.enter === n
    );
  }
  getNextShape() {
    const e = [];
    let n = this.segments[0];
    const s = (o) => {
      if (!o.type.exit) return;
      const [r, l] = o.type.exit.split(""),
        i = { x: o.x + vu[r][0], y: o.y + vu[r][1] },
        a = d5[r] + l;
      return this.findSegment(i, a);
    };
    do e.push(n), this.segments.splice(this.segments.indexOf(n), 1), (n = s(n));
    while (n && !e.includes(n));
    return e;
  }
  shapeToPoints(e) {
    const n = [];
    return (
      e.forEach(({ x: s, y: o, type: r }) => {
        for (const l of r.points)
          n.push({
            x: s + this.pointOffsets[l].x,
            y: o + this.pointOffsets[l].y,
          });
      }),
      n
    );
  }
}
const vu = { t: [0, -1], r: [1, 0], b: [0, 1], l: [-1, 0] },
  d5 = { t: "b", r: "l", b: "t", l: "r" };
function ht(t, e, n, s) {
  const o = [];
  for (let r = 0; r < t.length; r++)
    t[r] !== "_" &&
      o.push({
        bit: t[r] === "1",
        offsetX: (r % 3) - 1,
        offsetY: Math.floor(r / 3) - 1,
      });
  return { pattern: o, enter: e, exit: n, points: s };
}
const p5 = [
  ht("_0_011_1_", "bl", "rt", ["tl"]),
  ht("_0_110_1_", "lt", "br", ["tr"]),
  ht("_1_110_0_", "tr", "lb", ["br"]),
  ht("_1_011_0_", "rb", "tl", ["bl"]),
  ht("01_11____", "lt", "tl", ["tl"]),
  ht("_10_11___", "tr", "rt", ["tr"]),
  ht("____11_10", "rb", "br", ["br"]),
  ht("___11_01_", "bl", "lb", ["bl"]),
  ht("_0_111___", "lt", "rt", ["tc"]),
  ht("_1__10_1_", "tr", "br", ["rc"]),
  ht("___111_0_", "rb", "lb", ["bc"]),
  ht("_1_01__1_", "bl", "tl", ["lc"]),
  ht("_0_010_1_", "bl", "br", ["tl", "tr"]),
  ht("_0_110_0_", "lt", "lb", ["tr", "br"]),
  ht("_1_010_0_", "tr", "tl", ["br", "bl"]),
  ht("_0_011_0_", "rb", "rt", ["bl", "tl"]),
  ht("_0_010_0_", void 0, void 0, ["tl", "tr", "br", "bl"]),
];
class Ld {
  constructor(e) {
    L(this, "helpers");
    (this.spec = e), (this.helpers = Fn(e));
  }
}
const et = Symbol("SudokuRenderContextKey"),
  f5 = ["d", "fill", "stroke", "stroke-width", "stroke-dasharray"],
  Vs = S({
    __name: "Cage",
    props: {
      cells: {},
      offset: { default: 0 },
      strokeColor: { default: void 0 },
      strokeWidth: { default: 0.1 },
      strokeDasharray: { default: "" },
      fillColor: { default: "transparent" },
    },
    setup(t) {
      const e = t,
        { helpers: n } = Qe(et).value,
        s = b(() => {
          const o = [...e.cells].map((l) => n.cellIds.getCoordsFromId(l));
          return new Mr(o, e.offset).getSvgDString();
        });
      return (o, r) => (
        d(),
        C(
          "path",
          {
            d: s.value,
            fill: o.fillColor,
            stroke: o.strokeColor,
            "stroke-width": o.strokeWidth,
            "stroke-dasharray": o.strokeDasharray,
          },
          null,
          8,
          f5
        )
      );
    },
  }),
  h5 = S({
    components: { Cage: Vs },
    props: {
      selection: { type: [Array, Set], required: !0 },
      color: { type: String, default: "#5274eac0" },
      fillColor: { type: String, default: "#fff7" },
    },
  });
function m5(t, e, n, s, o, r) {
  const l = H("Cage");
  return (
    d(),
    C(
      Z,
      null,
      [
        c(l, { cells: t.selection, "fill-color": t.fillColor }, null, 8, [
          "cells",
          "fill-color",
        ]),
        c(
          l,
          {
            cells: t.selection,
            "stroke-color": t.color,
            "stroke-width": 0.14,
            offset: 0.07,
          },
          null,
          8,
          ["cells", "stroke-color"]
        ),
      ],
      64
    )
  );
}
const Zo = B(h5, [["render", m5]]),
  ei = j(0);
setInterval(() => {
  ei.value = 1 - ei.value;
}, 500);
function g5() {
  return ei;
}
function js(t, e, n) {
  const s = new ResizeObserver(e);
  ae(
    t,
    (o, r) => {
      r && s.unobserve(r), o && s.observe(o, n);
    },
    { immediate: !0, flush: "post" }
  ),
    zo(() => {
      s.disconnect();
    });
}
const v5 = ["x", "y", "font-size", "fill", "text-anchor"],
  y5 = ["x", "y", "height", "width", "fill", "opacity"],
  kn = S({
    __name: "CenteredText",
    props: {
      value: {},
      fontSize: { default: 0.1 },
      fill: { default: void 0 },
      x: { default: 0 },
      y: { default: 0 },
      showCaret: { type: Boolean },
      align: { default: "center" },
    },
    setup(t) {
      const e = t,
        n = j(),
        s = j(0),
        o = g5(),
        r = b(() => {
          const a = e.align === "center" ? 0.5 : 1;
          return e.x + s.value * a + (String(e.value).length > 0 ? 0.02 : 0);
        }),
        l = b(() => e.y + e.fontSize * 0.35),
        i = b(() => (e.showCaret ? n.value : void 0));
      return (
        js(i, (a) => {
          s.value = a[0].contentRect.width;
        }),
        (a, u) => (
          d(),
          C("g", null, [
            h(
              "text",
              {
                ref_key: "mainText",
                ref: n,
                x: a.x,
                y: l.value,
                "font-size": a.fontSize,
                fill: a.fill,
                "stroke-miterlimit": "1.5",
                "stroke-linejoin": "round",
                "text-anchor": a.align === "center" ? "middle" : "start",
              },
              X(a.value),
              9,
              v5
            ),
            a.showCaret
              ? (d(),
                C(
                  "rect",
                  {
                    key: 0,
                    x: r.value,
                    y: a.y - a.fontSize * 0.5,
                    height: a.fontSize,
                    width: 0.05 * a.fontSize,
                    fill: a.fill,
                    opacity: y(o),
                    stroke: "#fff",
                    "stroke-width": "0.025",
                  },
                  null,
                  8,
                  y5
                ))
              : z("", !0),
          ])
        )
      );
    },
  }),
  C5 = 1.5,
  tt = 50,
  w5 = [
    { x: -0.7, y: -0.6 },
    { x: 0.7, y: -0.6 },
    { x: -0.7, y: 0.6 },
    { x: 0.7, y: 0.6 },
    { x: 0, y: -0.6 },
    { x: 0, y: 0.6 },
    { x: -0.7, y: 0 },
    { x: 0.7, y: 0 },
    { x: -100, y: -100 },
  ],
  b5 = S({
    components: { CenteredText: kn },
    props: { cell: { type: rs, required: !0 } },
    computed: {
      nonGivenColor() {
        return ee.nonGivenColor;
      },
      valueColor() {
        return this.cell.valid ? (this.cell.given ? "#000" : "") : "#f00";
      },
      transform() {
        const t = tt * (this.cell.x + 0.5),
          e = tt * (this.cell.y + 0.5);
        return `translate(${t} ${e}) scale(${tt / 2})`;
      },
      candidates() {
        return [...nn(this.cell.candidates, 0, 9)];
      },
      candidatesLines() {
        const t = this.candidates.length;
        if (t === 0) return [];
        if (t <= 5 || !ee.multilineCandidates)
          return [this.candidates.join("")];
        const e = Math.ceil(t / 2);
        return [
          this.candidates.slice(0, e).join(""),
          this.candidates.slice(e).join(""),
        ];
      },
      candidatesSize() {
        return 0.62 - 0.03 * this.candidates.length;
      },
      cornerMarks() {
        return [...nn(this.cell.cornerPencilMarks, 0, 9)].map((t, e) => ({
          ...w5[e],
          digit: t,
        }));
      },
    },
  }),
  k5 = ["transform", "fill"];
function _5(t, e, n, s, o, r) {
  const l = H("CenteredText");
  return (
    d(),
    C(
      "g",
      {
        transform: t.transform,
        "paint-order": "stroke",
        stroke: "#fff",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        fill: t.nonGivenColor,
      },
      [
        t.cell.value !== void 0
          ? (d(),
            w(
              l,
              {
                key: 0,
                value: t.cell.value,
                fill: t.valueColor,
                "font-size": 1.6,
                "stroke-width": "0.05",
              },
              null,
              8,
              ["value", "fill"]
            ))
          : (d(),
            C(
              Z,
              { key: 1 },
              [
                t.candidatesLines.length > 1
                  ? (d(!0),
                    C(
                      Z,
                      { key: 0 },
                      se(
                        t.candidatesLines,
                        (i, a) => (
                          d(),
                          w(
                            l,
                            {
                              key: a,
                              value: i,
                              y: -0.25 + 0.5 * a,
                              "font-size": 0.5,
                              "stroke-width": "0.08",
                            },
                            null,
                            8,
                            ["value", "y"]
                          )
                        )
                      ),
                      128
                    ))
                  : t.candidatesLines.length > 0
                  ? (d(),
                    w(
                      l,
                      {
                        key: 1,
                        value: t.candidatesLines[0],
                        "font-size": t.candidatesSize,
                        "stroke-width": "0.08",
                      },
                      null,
                      8,
                      ["value", "font-size"]
                    ))
                  : z("", !0),
                (d(!0),
                C(
                  Z,
                  null,
                  se(
                    t.cornerMarks,
                    (i, a) => (
                      d(),
                      w(
                        l,
                        {
                          key: a,
                          value: i.digit,
                          x: i.x,
                          y: i.y,
                          "font-size": 0.48,
                          "stroke-width": "0.08",
                        },
                        null,
                        8,
                        ["value", "x", "y"]
                      )
                    )
                  ),
                  128
                )),
              ],
              64
            )),
      ],
      8,
      k5
    )
  );
}
const Ed = B(b5, [["render", _5]]),
  $5 = ["transform"],
  is = S({
    __name: "CellSymbolRenderer",
    props: { cells: {} },
    setup(t) {
      const e = t,
        { helpers: n } = Qe(et).value,
        s = b(() =>
          Kn(e.cells, (o) => ({
            position: n.cellIds.getCoordsFromId(o),
            cell: o,
          }))
        );
      return (o, r) => (
        d(!0),
        C(
          Z,
          null,
          se(
            s.value,
            ({ position: l, cell: i }) => (
              d(),
              C(
                "g",
                { key: i, transform: `translate(${l.x + 0.5} ${l.y + 0.5})` },
                [G(o.$slots, "default", { position: l, cell: i })],
                8,
                $5
              )
            )
          ),
          128
        )
      );
    },
  }),
  S5 = ["x1", "y1", "x2", "y2"],
  Vi = S({
    __name: "RegionsRenderer",
    props: { regions: {} },
    setup(t) {
      const e = t,
        { spec: n, helpers: s } = Qe(et).value,
        o = b(() => {
          const r = e.regions,
            { width: l, height: i } = n.size,
            a = [];
          let u = 0;
          for (let p = 0; p < i; p++)
            for (let m = 0; m < l; m++) {
              const g = r[u];
              if (
                (g >= 0 &&
                  (m === 0
                    ? a.push({ x1: m, y1: p, x2: m, y2: p + 1 })
                    : m === l - 1 &&
                      a.push({ x1: m + 1, y1: p, x2: m + 1, y2: p + 1 }),
                  p === 0
                    ? a.push({ x1: m, y1: p, x2: m + 1, y2: p })
                    : p === i - 1 &&
                      a.push({ x1: m, y1: p + 1, x2: m + 1, y2: p + 1 })),
                m < l - 1)
              ) {
                const v = r[s.cellIds.getIdFromCoords({ x: m + 1, y: p })];
                g !== v && a.push({ x1: m + 1, y1: p, x2: m + 1, y2: p + 1 });
              }
              if (p < i - 1) {
                const v = r[s.cellIds.getIdFromCoords({ x: m, y: p + 1 })];
                g !== v && a.push({ x1: m, y1: p + 1, x2: m + 1, y2: p + 1 });
              }
              u++;
            }
          return a;
        });
      return (r, l) => (
        d(!0),
        C(
          Z,
          null,
          se(
            o.value,
            (i, a) => (
              d(),
              C(
                "line",
                {
                  key: a,
                  x1: i.x1,
                  y1: i.y1,
                  x2: i.x2,
                  y2: i.y2,
                  "stroke-width": "0.06",
                  stroke: "#000",
                  "stroke-linecap": "round",
                },
                null,
                8,
                S5
              )
            )
          ),
          128
        )
      );
    },
  });
class yu {
  constructor(e, n, s, o) {
    L(this, "x1");
    L(this, "y1");
    L(this, "x2");
    L(this, "y2");
    (this.x1 = e), (this.y1 = n), (this.x2 = s), (this.y2 = o);
  }
}
const I5 = S({
    props: { size: { type: Object, required: !0 } },
    computed: {
      lines() {
        const t = [];
        for (let e = 1; e < this.size.width; e++)
          t.push(new yu(e, 0, e, this.size.height));
        for (let e = 1; e < this.size.height; e++)
          t.push(new yu(0, e, this.size.width, e));
        return t;
      },
    },
  }),
  x5 = ["x1", "y1", "x2", "y2"];
function D5(t, e, n, s, o, r) {
  return (
    d(),
    C(
      Z,
      null,
      [
        (d(!0),
        C(
          Z,
          null,
          se(
            t.lines,
            (l) => (
              d(),
              C(
                "line",
                {
                  x1: l.x1,
                  y1: l.y1,
                  x2: l.x2,
                  y2: l.y2,
                  "stroke-width": "0.015",
                  stroke: "#000",
                },
                null,
                8,
                x5
              )
            )
          ),
          256
        )),
        h(
          "rect",
          St(t.size, { fill: "none", stroke: "#000", "stroke-width": "0.015" }),
          null,
          16
        ),
      ],
      64
    )
  );
}
const Fd = B(I5, [["render", D5]]),
  M5 = ["opacity"],
  A5 = ["id", "d"],
  P5 = ["id"],
  L5 = ["href"],
  E5 = ["href"],
  F5 = ["href"],
  B5 = ["mask"],
  z5 = ["width", "height"],
  ol = S({
    __name: "FogLayer",
    props: { fogCells: {}, regions: {}, transparent: { type: Boolean } },
    setup(t) {
      var l;
      const e = t,
        { helpers: n, spec: s } = Qe(et).value,
        o = ((l = g1()) == null ? void 0 : l.uid) || Date.now(),
        r = b(() => {
          const i = Kn(e.fogCells, (u) => n.cellIds.getCoordsFromId(u));
          return new Mr(i, -0.01).getSvgDString();
        });
      return (i, a) => (
        d(),
        C(
          "g",
          { opacity: i.transparent ? 0.5 : 1 },
          [
            h("defs", null, [
              h(
                "path",
                { id: `path${y(o)}`, d: r.value, "stroke-linejoin": "round" },
                null,
                8,
                A5
              ),
              h(
                "mask",
                { id: `mask${y(o)}` },
                [
                  h(
                    "use",
                    {
                      href: `#path${y(o)}`,
                      stroke: "#101010",
                      "stroke-width": "0.4",
                    },
                    null,
                    8,
                    L5
                  ),
                  h(
                    "use",
                    {
                      href: `#path${y(o)}`,
                      stroke: "#2c2c2c",
                      "stroke-width": "0.2",
                    },
                    null,
                    8,
                    E5
                  ),
                  h(
                    "use",
                    {
                      href: `#path${y(o)}`,
                      stroke: "#5e5e5e",
                      "stroke-width": "0.09",
                      fill: "#fff",
                      "paint-order": "stroke",
                    },
                    null,
                    8,
                    F5
                  ),
                ],
                8,
                P5
              ),
            ]),
            h(
              "g",
              { mask: `url(#mask${y(o)})` },
              [
                h(
                  "rect",
                  {
                    width: y(s).size.width,
                    height: y(s).size.height,
                    fill: "#ababab",
                  },
                  null,
                  8,
                  z5
                ),
                G(i.$slots, "default"),
                c(Fd, { size: y(s).size }, null, 8, ["size"]),
                i.regions
                  ? (d(),
                    w(Vi, { key: 0, regions: i.regions }, null, 8, ["regions"]))
                  : z("", !0),
              ],
              8,
              B5
            ),
          ],
          8,
          M5
        )
      );
    },
  }),
  R5 = {},
  O5 = { transform: "translate(-0.4 -0.4) scale(0.04)" };
function N5(t, e) {
  return (
    d(),
    C(
      "g",
      O5,
      e[0] ||
        (e[0] = [
          h(
            "path",
            {
              d: "M7.83 13.67a4.29 4.29 0 0 1 2.18-8.02 4.29 4.29 0 0 1 2.18 8.02",
              fill: "#ff0c",
              stroke: "none",
            },
            null,
            -1
          ),
          h(
            "path",
            {
              d: "M7.83 13.67a4.29 4.29 0 0 1 2.18-8.02 4.29 4.29 0 0 1 2.18 8.02",
              fill: "none",
              stroke: "#000",
              "stroke-width": "0.5",
            },
            null,
            -1
          ),
          h(
            "path",
            {
              d: "M7.83 13.67v3.44m4.36-.73v-2.71m-4.36 3.44 4.36-.71m0-1.44-4.36.72m4.36-2.01-4.36.58z",
              fill: "none",
              stroke: "#000",
              "stroke-width": "0.5",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const Bd = B(R5, [["render", N5]]);
function T5(t, e, n) {
  let s = !1;
  const o = [];
  for (const r of t)
    r.config.type === _.FogLights && (o.push(...r.config.lightCells), (s = !0)),
      r.config.type === _.FogTriggers && (s = !0);
  if (!s) return [];
  if ((n == null ? void 0 : n.context) === "exportPreview") {
    const r = t.find((a) => a.config.type === _.Regions),
      l = r ? r.config.regions : void 0,
      i = Lt.withoutAll(new jr(e).getAllCellIds(), o);
    return [
      {
        layer: oe.AboveDigits,
        component: c(ol, { fogCells: i, regions: l }, null),
      },
    ];
  }
  return [
    {
      layer: oe.Foreground,
      component: c(is, { cells: o }, { default: () => c(Bd, null, null) }),
    },
  ];
}
const V5 = ["transform"],
  Cu = S({
    __name: "ScaledWrapper",
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "g",
          { transform: `scale(${y(tt)})` },
          [G(e.$slots, "default")],
          8,
          V5
        )
      );
    },
  });
function j5(t, e = { width: 0, height: 0 }, n) {
  const s = rn({ width: e.width, height: e.height });
  return (
    js(
      t,
      ([o]) => {
        var i;
        const r =
            (i = o.target.namespaceURI) == null ? void 0 : i.includes("svg"),
          l = o.contentBoxSize;
        if (r) {
          const a = window.getComputedStyle(o.target);
          (s.width = Number.parseFloat(a.width)),
            (s.height = Number.parseFloat(a.height));
        } else if (l) {
          const a = Array.isArray(l) ? l : [l];
          (s.width = a.reduce((u, { inlineSize: p }) => u + p, 0)),
            (s.height = a.reduce((u, { blockSize: p }) => u + p, 0));
        } else
          (s.width = o.contentRect.width), (s.height = o.contentRect.height);
      },
      n
    ),
    s
  );
}
function Bn(t) {
  return { left: t, right: t, top: t, bottom: t };
}
function wu(t) {
  const e = Bn(-1 / 0);
  for (const n of t)
    (e.left = Math.max(e.left, n.left)),
      (e.right = Math.max(e.right, n.right)),
      (e.top = Math.max(e.top, n.top)),
      (e.bottom = Math.max(e.bottom, n.bottom));
  return e;
}
function U5(t, e, n = 500) {
  const s = setTimeout(e, n),
    o = (l) => {
      Wr(t, l) > 10 && clearTimeout(s);
    },
    r = () => {
      clearTimeout(s),
        document.removeEventListener("pointermove", o),
        document.removeEventListener("pointerup", r);
    };
  document.addEventListener("pointermove", o),
    document.addEventListener("pointerup", r);
}
function* zd(t) {
  for (let e = 0; e <= 27; e++) t & (1 << e) && (yield e);
}
var Rd = ((t) => ((t[(t.Move = 0)] = "Move"), (t[(t.Line = 1)] = "Line"), t))(
  Rd || {}
);
class Od {
  constructor() {
    L(this, "segments", []);
  }
  moveTo(e) {
    this.segments.push({ type: 0, point: e });
  }
  lineTo(e) {
    this.segments.push({ type: 1, point: e });
  }
  toString() {
    const e = [];
    for (const n of this.segments)
      switch (n.type) {
        case 0:
          e.push(`M${n.point.x} ${n.point.y}`);
          break;
        case 1:
          e.push(`L${n.point.x} ${n.point.y}`);
          break;
      }
    return e.join("");
  }
}
const H5 = S({
    props: { cell: { type: rs, required: !0 } },
    computed: {
      transform() {
        const t = this.cell.x + 0.5,
          e = this.cell.y + 0.5;
        return `translate(${t}, ${e}) scale(0.5)`;
      },
      shapes() {
        const t = [...zd(this.cell.colors)].map((o) => ee.markColors[o - 1]);
        if (t.length === 1)
          return t[0] ? [{ fill: t[0], path: "M-1-1H1V1H-1z" }] : [];
        const e = (Math.PI * 2) / t.length,
          n = -1.23,
          s = [];
        for (let o = 0; o < t.length; o++)
          t[o] &&
            s.push({
              fill: t[o],
              path: this.createPath(n + o * e, n + (o + 1) * e).toString(),
            });
        return s;
      },
    },
    methods: {
      createPath(t, e) {
        function n(l) {
          const i = Math.floor((8 * l) / (2 * Math.PI));
          return (
            ((Math.floor((i + 1) / 2) * 2 - 1) / 4) * Math.PI + Math.PI / 2
          );
        }
        const s = new Od();
        s.moveTo({ x: 0, y: 0 });
        function o(l) {
          const i = Math.cos(l),
            a = Math.sin(l),
            u = Math.max(Math.abs(i), Math.abs(a));
          s.lineTo({ x: i / u, y: a / u });
        }
        let r = t;
        for (o(r); r < e; ) (r = Math.min(n(r), e)), o(r);
        return s;
      },
    },
  }),
  W5 = ["transform"],
  Z5 = ["d", "fill"];
function G5(t, e, n, s, o, r) {
  return (
    d(),
    C(
      "g",
      { transform: t.transform },
      [
        (d(!0),
        C(
          Z,
          null,
          se(
            t.shapes,
            (l, i) => (
              d(), C("path", { key: i, d: l.path, fill: l.fill }, null, 8, Z5)
            )
          ),
          128
        )),
      ],
      8,
      W5
    )
  );
}
const Nd = B(H5, [["render", G5]]),
  q5 = S({
    components: { CellBackdrop: Nd },
    props: {
      cells: { type: Array, required: !0 },
      size: { type: Object, required: !0 },
    },
    computed: {
      coloredCells() {
        return this.cells.filter((t) => t.colors !== 0);
      },
      actualSize() {
        return { width: this.size.width, height: this.size.height };
      },
    },
  });
function K5(t, e, n, s, o, r) {
  const l = H("CellBackdrop");
  return (
    d(),
    C(
      Z,
      null,
      [
        h("rect", St(t.actualSize, { fill: "#fff" }), null, 16),
        (d(!0),
        C(
          Z,
          null,
          se(
            t.coloredCells,
            (i) => (d(), w(l, { key: i.id, cell: i }, null, 8, ["cell"]))
          ),
          128
        )),
      ],
      64
    )
  );
}
const X5 = B(q5, [["render", K5]]),
  Y5 = ["viewBox"],
  J5 = ["transform"],
  Q5 = { key: 0, class: "editorContainer-background" },
  e3 = { key: 1, class: "editorContainer-default" },
  t3 = { key: 2, class: "editorContainer-grid" },
  n3 = { key: 3, class: "editorContainer-foreground" },
  s3 = { key: 0, class: "editorContainer-aboveDigits" },
  o3 = S({
    __name: "SudokuSvg",
    props: {
      spec: {},
      cells: {},
      constraints: { default: () => [] },
      highlight: { default: void 0 },
      minimumMargins: { default: () => Bn(0) },
      includeEditorContainers: { type: Boolean, default: !1 },
      readonly: { type: Boolean, default: !1 },
      isExportPreview: { type: Boolean, default: !1 },
      zoom: { default: void 0 },
      darkModeStyle: { type: Boolean, default: !1 },
    },
    emits: [
      "pointerdown",
      "pointermove",
      "pointerup",
      "pointerhold",
      "blur",
      "update:canvas-props",
    ],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = j(),
        r = j();
      function l(I) {
        return "x" in I[0];
      }
      const i = b(() =>
          l(n.cells)
            ? n.cells
            : n.cells.map((I, U) => {
                const D = new rs(
                  U,
                  U % n.spec.size.width,
                  Math.floor(U / n.spec.size.width)
                );
                return Object.assign(D, I), D;
              })
        ),
        a = b(() => new Ld(n.spec));
      gi(et, a);
      const u = b(() =>
          wu([
            n.minimumMargins,
            ...n.constraints.map((I) => je.getMargins(I.config, n.spec)),
          ])
        ),
        p = b(() => (n.highlight ? new Set(n.highlight) : new Set())),
        m = j5(o),
        g = b(() => {
          const I = wu([
              Bn(C5),
              {
                left: u.value.left * tt,
                right: u.value.right * tt,
                top: u.value.top * tt,
                bottom: u.value.bottom * tt,
              },
            ]),
            U = n.spec.size.width * tt + I.left + I.right,
            D = n.spec.size.height * tt + I.top + I.bottom;
          return { x: -I.left, y: -I.top, width: U, height: D };
        }),
        v = b(() => {
          if (n.readonly || !n.zoom) {
            const { x: I, y: U, width: D, height: N } = g.value;
            return `${I} ${U} ${D} ${N}`;
          }
          return `0 0 ${m.width} ${m.height}`;
        }),
        $ = b(() => ({ canvasSize: ue(m), boundingBox: g.value }));
      ae($, () => {
        $.value.canvasSize.width === 0 ||
          $.value.canvasSize.height === 0 ||
          s("update:canvas-props", $.value);
      });
      const k = b(() => {
          if (n.readonly || !n.zoom || !m.width || !m.height) return "";
          const I = n.zoom,
            U = -I.target.x * I.scale + m.width / 2,
            D = -I.target.y * I.scale + m.height / 2;
          return `matrix(${I.scale} 0 0 ${I.scale} ${U} ${D})`;
        }),
        M = b(() => {
          const I = {
              [oe.Background]: [],
              [oe.Default]: [],
              [oe.Grid]: [],
              [oe.Foreground]: [],
              [oe.AboveDigits]: [],
            },
            U = {
              context: n.isExportPreview ? "exportPreview" : "default",
              constraints: n.constraints,
            };
          for (const D of n.constraints) {
            const N = je.getRenderers(D.config, n.spec, U);
            if (N) for (const E of N) I[E.layer].push(E);
          }
          for (const D of T5(n.constraints, n.spec, U)) I[D.layer].push(D);
          return I;
        }),
        P = j(!1);
      function x(I) {
        if (I.pointerType === "mouse" && I.button !== 0) return;
        P.value = !0;
        const U = V(I);
        s("pointerdown", U),
          U5(I, () => s("pointerhold", U)),
          document.addEventListener("pointerup", O, !1);
      }
      function A(I) {
        (!P.value && o.value && !o.value.contains(I.target)) ||
          m.width === 0 ||
          m.height === 0 ||
          s("pointermove", V(I));
      }
      function O(I) {
        (I.pointerType === "mouse" && I.button !== 0) ||
          (document.removeEventListener("pointerup", O, !1),
          s("pointerup", V(I)),
          (P.value = !1));
      }
      function V(I) {
        let U = o.value.createSVGPoint();
        (U.x = I.clientX),
          (U.y = I.clientY),
          (U = U.matrixTransform(r.value.getScreenCTM().inverse()));
        const D = U.x / tt,
          N = U.y / tt,
          E = Math.floor(D),
          R = Math.floor(N),
          W =
            E < 0 || R < 0 || E >= n.spec.size.width || R >= n.spec.size.height;
        return {
          pointerDown: P.value,
          pointerType: I.pointerType,
          x: E,
          y: R,
          cell: { x: E, y: R },
          cellId: W ? void 0 : E + R * n.spec.size.width,
          outside: W,
          offsetX: D - E,
          offsetY: N - R,
          pointerX: D,
          pointerY: N,
          originalEvent: I,
        };
      }
      return (
        Xt(() => {
          document.addEventListener("pointermove", A, !1);
        }),
        mi(() => {
          document.removeEventListener("pointermove", A, !1);
        }),
        (I, U) => (
          d(),
          C(
            "svg",
            {
              ref_key: "svg",
              ref: o,
              class: Ae([
                "SudokuSvg",
                { readonly: I.readonly, darkModeStyle: I.darkModeStyle },
              ]),
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: v.value,
              "font-size": "16",
              "font-family": "Arial, sans-serif",
              onPointerdown: x,
              onBlur: U[0] || (U[0] = (D) => I.$emit("blur")),
            },
            [
              h(
                "g",
                { ref_key: "root", ref: r, transform: k.value },
                [
                  h("rect", St(g.value, { fill: "#fff" }), null, 16),
                  c(Cu, null, {
                    default: f(() => [
                      c(X5, { cells: i.value, size: I.spec.size }, null, 8, [
                        "cells",
                        "size",
                      ]),
                      G(I.$slots, "background", {}, void 0, !0),
                      (d(!0),
                      C(
                        Z,
                        null,
                        se(
                          M.value.background,
                          (D, N) => (d(), w(qe(D.component), { key: N }))
                        ),
                        128
                      )),
                      I.includeEditorContainers ? (d(), C("g", Q5)) : z("", !0),
                      c(
                        Zo,
                        {
                          selection: p.value,
                          color: y(ee).highlightColor,
                          "fill-color": "#fff0",
                        },
                        null,
                        8,
                        ["selection", "color"]
                      ),
                      (d(!0),
                      C(
                        Z,
                        null,
                        se(
                          M.value.default,
                          (D, N) => (d(), w(qe(D.component), { key: N }))
                        ),
                        128
                      )),
                      I.includeEditorContainers ? (d(), C("g", e3)) : z("", !0),
                      G(I.$slots, "grid", {}, void 0, !0),
                      (d(!0),
                      C(
                        Z,
                        null,
                        se(
                          M.value.grid,
                          (D, N) => (d(), w(qe(D.component), { key: N }))
                        ),
                        128
                      )),
                      I.includeEditorContainers ? (d(), C("g", t3)) : z("", !0),
                      c(Fd, { size: I.spec.size }, null, 8, ["size"]),
                      (d(!0),
                      C(
                        Z,
                        null,
                        se(
                          M.value.foreground,
                          (D, N) => (d(), w(qe(D.component), { key: N }))
                        ),
                        128
                      )),
                      G(I.$slots, "foreground", {}, void 0, !0),
                      I.includeEditorContainers ? (d(), C("g", n3)) : z("", !0),
                    ]),
                    _: 3,
                  }),
                  (d(!0),
                  C(
                    Z,
                    null,
                    se(
                      i.value,
                      (D) => (
                        d(), w(Ed, { key: D.id, cell: D }, null, 8, ["cell"])
                      )
                    ),
                    128
                  )),
                  c(Cu, null, {
                    default: f(() => [
                      G(I.$slots, "aboveDigits", {}, void 0, !0),
                      (d(!0),
                      C(
                        Z,
                        null,
                        se(
                          M.value.aboveDigits,
                          (D, N) => (d(), w(qe(D.component), { key: N }))
                        ),
                        128
                      )),
                      I.includeEditorContainers ? (d(), C("g", s3)) : z("", !0),
                    ]),
                    _: 3,
                  }),
                ],
                8,
                J5
              ),
            ],
            42,
            Y5
          )
        )
      );
    },
  }),
  Xs = B(o3, [["__scopeId", "data-v-aa578b5b"]]),
  r3 = { class: "ExportPreview" },
  l3 = S({
    __name: "ExportPreview",
    props: { puzzle: {}, editorState: { type: Boolean } },
    setup(t) {
      return (e, n) => (
        d(),
        C("div", r3, [
          c(
            Xs,
            {
              spec: e.puzzle.spec,
              cells: e.puzzle.cells,
              constraints: e.puzzle.constraints,
              readonly: "",
              "is-export-preview": !e.editorState,
            },
            null,
            8,
            ["spec", "cells", "constraints", "is-export-preview"]
          ),
        ])
      );
    },
  }),
  ji = B(l3, [["__scopeId", "data-v-e3bda7b9"]]),
  i3 = ["textContent"],
  Td = S({
    __name: "CopyButton",
    props: {
      text: { default: "Copy" },
      value: {},
      mimeType: { default: "text/plain" },
      disabled: { type: Boolean },
    },
    emits: ["error"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = j(!1),
        r = j(!1);
      ae(
        () => n.value,
        () => {
          r.value = !1;
        }
      );
      async function l() {
        o.value = !0;
        try {
          await kd({
            value: typeof n.value == "function" ? n.value() : n.value,
            mimeType: n.mimeType,
          }),
            (r.value = !0);
        } catch (i) {
          s("error", i);
        }
        o.value = !1;
      }
      return (i, a) => (
        d(),
        w(
          nl,
          {
            class: "CopyButton",
            loading: o.value,
            "with-icon": !r.value,
            disabled: i.disabled,
            onClick: l,
          },
          {
            default: f(() => [
              r.value
                ? (d(), C(Z, { key: 0 }, [F(" Copied! ")], 64))
                : (d(),
                  C(
                    Z,
                    { key: 1 },
                    [c(Ni), h("span", { textContent: X(i.text) }, null, 8, i3)],
                    64
                  )),
            ]),
            _: 1,
          },
          8,
          ["loading", "with-icon", "disabled"]
        )
      );
    },
  }),
  a3 = { components: { Icon: he } };
function u3(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "OutArrow", viewBox: "0 0 7 7" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M2 1v1H1v4h4V5h1v2H0V1h2Zm3.3 0L2.37 3.91l.7.71L6 1.71V4h1V0H3v1h2.3Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const c3 = B(a3, [["render", u3]]),
  d3 = S({
    components: { OutArrow: c3 },
    props: {
      to: { type: String, required: !0 },
      variant: { type: String, default: "default" },
    },
  }),
  p3 = ["href"];
function f3(t, e, n, s, o, r) {
  const l = H("OutArrow");
  return (
    d(),
    C(
      "a",
      { class: "ExternalLink", href: t.to, target: "_blank" },
      [
        G(t.$slots, "default", {}, void 0, !0),
        t.variant === "default"
          ? (d(), w(l, { key: 0, "aria-hidden": "true" }))
          : z("", !0),
      ],
      8,
      p3
    )
  );
}
const Jn = B(d3, [
    ["render", f3],
    ["__scopeId", "data-v-9d79af60"],
  ]),
  h3 = S({
    components: { ExternalLink: Jn },
    props: { to: { type: String, required: !0 } },
  });
function m3(t, e, n, s, o, r) {
  const l = H("ExternalLink");
  return (
    d(),
    w(
      l,
      { class: "ExportLink", to: t.to },
      { default: f(() => [F(X(t.to), 1)]), _: 1 },
      8,
      ["to"]
    )
  );
}
const Vd = B(h3, [
    ["render", m3],
    ["__scopeId", "data-v-1735e3f1"],
  ]),
  g3 = { components: { Icon: he } };
function v3(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      {
        class: "DownloadIcon",
        viewBox: "0 0 20 20",
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        "stroke-linejoin": "round",
        "stroke-miterlimit": "2",
      },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M15.5 19a4.5 4.5 0 0 0 4.5-4.5v-1a1.5 1.5 0 0 0-3 0v1a1.5 1.5 0 0 1-1.5 1.5h-11A1.5 1.5 0 0 1 3 14.5v-1a1.5 1.5 0 0 0-3 0v1A4.5 4.5 0 0 0 4.5 19h11Z",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M11.26 13.94a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1v-6H7.02a1 1 0 0 1-.8-1.6l3-3.95a1 1 0 0 1 1.59 0l2.98 3.95a1 1 0 0 1-.8 1.6h-1.73v6Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Ui = B(g3, [["render", v3]]),
  Ys = S({
    __name: "ExportIcon",
    props: { inline: { type: Boolean } },
    setup(t) {
      return (e, n) => (
        d(),
        w(
          he,
          {
            class: "ExportIcon",
            viewBox: "0 0 20 20",
            "fill-rule": "evenodd",
            "clip-rule": "evenodd",
            "stroke-linejoin": "round",
            "stroke-miterlimit": "2",
            inline: e.inline,
          },
          {
            default: f(
              () =>
                n[0] ||
                (n[0] = [
                  h(
                    "path",
                    {
                      d: "M3 5.5C3 4.67 3.67 4 4.5 4h2a1.5 1.5 0 0 0 0-3h-2A4.5 4.5 0 0 0 0 5.5v9A4.5 4.5 0 0 0 4.5 19h11a4.5 4.5 0 0 0 4.5-4.5v-1a1.5 1.5 0 0 0-3 0v1a1.5 1.5 0 0 1-1.5 1.5h-11A1.5 1.5 0 0 1 3 14.5v-9Z",
                    },
                    null,
                    -1
                  ),
                  h(
                    "path",
                    {
                      d: "M13 4.64V2.5c0-.19.1-.36.25-.44a.43.43 0 0 1 .47.03 22867 22867 0 0 0 6.08 4.55.52.52 0 0 1 0 .83A22867 22867 0 0 0 13.72 12a.43.43 0 0 1-.47.03.5.5 0 0 1-.25-.44V9.07c-.42-.08-4.73-.78-7.97 4 0-4.67 3.48-8.41 7.97-8.43Z",
                    },
                    null,
                    -1
                  ),
                ])
            ),
            _: 1,
          },
          8,
          ["inline"]
        )
      );
    },
  }),
  y3 = S({
    __name: "ShareOrCopy",
    props: {
      name: { type: [String, Function] },
      getData: { type: Function },
      type: {},
      disabled: { type: Boolean },
    },
    emits: ["error"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = b(() => {
          switch (n.type) {
            case "url":
              return "text/plain";
            case "png":
              return "image/png";
            case "svg":
              return "image/svg+xml";
            case "json":
              return "application/json";
            default:
              return;
          }
        }),
        r = j(),
        l = b(
          () =>
            !!navigator.share &&
            (n.type === "url" || n.type === "png" || n.type === "svg")
        ),
        i = b(
          () => !!navigator.clipboard && (n.type === "url" || n.type === "png")
        );
      async function a() {
        n.type === "url" && (r.value = await n.getData());
      }
      async function u() {
        if (n.type === "url")
          await navigator.share({ title: gn(n.name), url: await n.getData() });
        else {
          const g = gn(n.name),
            v = await n.getData(),
            $ = new File([v], g, { type: o.value });
          await navigator.share({ files: [$], title: g });
        }
      }
      async function p() {
        const g = gn(n.name);
        $d(await n.getData(), g);
      }
      function m(g) {
        s("error", g);
      }
      return (g, v) => (
        d(),
        C(
          Z,
          null,
          [
            r.value
              ? (d(), w(Vd, { key: 0, to: r.value }, null, 8, ["to"]))
              : z("", !0),
            c(Je),
            c(Yt, null, {
              default: f(() => [
                g.type === "png" || g.type === "svg" || g.type === "json"
                  ? (d(),
                    w(
                      te,
                      { key: 0, "with-icon": "", onClick: p },
                      {
                        default: f(() => [
                          c(Ui),
                          v[0] || (v[0] = h("span", null, "Download", -1)),
                        ]),
                        _: 1,
                      }
                    ))
                  : z("", !0),
                i.value && !r.value
                  ? (d(),
                    w(
                      Td,
                      {
                        key: 1,
                        text: "To clipboard",
                        value: g.getData,
                        "mime-type": o.value,
                        disabled: g.disabled,
                        onError: m,
                      },
                      null,
                      8,
                      ["value", "mime-type", "disabled"]
                    ))
                  : !r.value && g.type === "url"
                  ? (d(),
                    w(
                      te,
                      { key: 2, disabled: g.disabled, onClick: a },
                      {
                        default: f(() => v[1] || (v[1] = [F(" Get URL ")])),
                        _: 1,
                      },
                      8,
                      ["disabled"]
                    ))
                  : z("", !0),
                l.value
                  ? (d(),
                    w(
                      te,
                      {
                        key: 3,
                        "with-icon": "",
                        disabled: g.disabled,
                        onClick: u,
                      },
                      {
                        default: f(() => [
                          c(Ys),
                          v[2] || (v[2] = h("span", null, "Share", -1)),
                        ]),
                        _: 1,
                      },
                      8,
                      ["disabled"]
                    ))
                  : z("", !0),
              ]),
              _: 1,
            }),
          ],
          64
        )
      );
    },
  }),
  Ar = B(y3, [["__scopeId", "data-v-38a67a9b"]]);
function Hi(t, e) {
  const n = b(() =>
      (e == null ? void 0 : e.value)
        ? t.cells
        : t.cells.map((u) => ({
            candidates: 0,
            colors: 0,
            cornerPencilMarks: 0,
            given: u.given,
            value: u.given ? u.value : void 0,
          }))
    ),
    s = b(() =>
      t.cells.some(
        (a) => a.cornerPencilMarks || a.candidates || (a.value && !a.given)
      )
    ),
    o = b(() => t.cells.some((a) => a.colors)),
    r = b(() => s.value || o.value),
    l = new Map();
  async function i(a) {
    if (!l.has(a)) {
      const u = `https://tinyurl.com/api-create.php?url=${encodeURIComponent(
          a
        )}`,
        p = await fetch(u);
      if (!p.ok) throw new Error("TinyURL failed to shorten the URL.");
      l.set(a, await p.text());
    }
    return l.get(a);
  }
  return {
    cells: n,
    hasCandidateMarkings: s,
    hasColorMarkings: o,
    hasMarkings: r,
    getTinyUrlLink: i,
  };
}
const bu = 2;
var Zn = ((t) => (
  (t.Project = "directLink"),
  (t.Image = "image"),
  (t.SudokuPad = "sudokuPad"),
  t
))(Zn || {});
function ti() {
  return {
    activeTab: "directLink",
    project: { includeMarkings: !1, type: "tinyUrl" },
    image: { includeMarkings: !1, format: "png" },
  };
}
const Ye = xs({
  name: "exportFormSettings",
  version: bu,
  getDefault: ti,
  migrate: Zc([C3], ti, bu),
});
function C3() {
  return ti();
}
const w3 = S({
    props: {
      modelValue: { type: [String, Number], default: void 0 },
      value: { type: [String, Number], required: !0 },
    },
    emits: { "update:model-value": (t) => !0 },
    methods: {
      handleInput() {
        this.$emit("update:model-value", this.value);
      },
    },
  }),
  b3 = { class: "RadioButton" },
  k3 = ["checked"];
function _3(t, e, n, s, o, r) {
  return (
    d(),
    C("span", b3, [
      h(
        "input",
        {
          type: "radio",
          checked: t.modelValue === t.value,
          onInput:
            e[0] || (e[0] = (...l) => t.handleInput && t.handleInput(...l)),
        },
        null,
        40,
        k3
      ),
      e[1] || (e[1] = h("span", { class: "circle" }, null, -1)),
      e[2] || (e[2] = h("span", { class: "dot" }, null, -1)),
    ])
  );
}
const $3 = B(w3, [
    ["render", _3],
    ["__scopeId", "data-v-757f8ea9"],
  ]),
  S3 = { components: { Icon: he } };
function I3(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "TooltipIcon", viewBox: "0 0 14 14" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M7 0a7 7 0 1 1 0 14A7 7 0 0 1 7 0ZM5.95 8.74H7.9v-.31c0-.63.23-.94 1.1-1.47.9-.57 1.34-1.25 1.34-2.24V4.7c0-1.6-1.24-2.68-3.14-2.68-2 0-3.18 1.15-3.2 2.9v.02h2.02l.02-.01c0-.65.42-1.08 1.02-1.08.59 0 1 .38 1 .92 0 .6-.22.88-1.07 1.41-.87.54-1.18 1.15-1.06 2.3l.02.26Zm1.04.84a1.25 1.25 0 1 0 0 2.5 1.25 1.25 0 0 0 0-2.5Z",
                  "fill-rule": "evenodd",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const x3 = B(S3, [["render", I3]]),
  D3 = S({
    __name: "TooltipIndicator",
    props: { asInfo: { type: Boolean } },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "span",
          {
            class: "TooltipIndicator",
            onTouchstart: n[0] || (n[0] = st(() => {}, ["prevent"])),
          },
          [
            e.asInfo ? (d(), w(Tc, { key: 0 })) : (d(), w(x3, { key: 1 })),
            c(
              Te,
              { "trigger-on-touch": "" },
              {
                default: f(() => [G(e.$slots, "default", {}, void 0, !0)]),
                _: 3,
              }
            ),
          ],
          32
        )
      );
    },
  }),
  dt = B(D3, [["__scopeId", "data-v-d4c9dea9"]]),
  M3 = S({
    components: { TooltipIndicator: dt, FormControlLabel: ut, RadioButton: $3 },
    props: {
      value: { type: [String, Number], required: !0 },
      options: { type: Array, required: !0 },
      variant: { type: String, default: "vertical" },
    },
    emits: { "update:value": (t) => !0 },
  }),
  A3 = ["innerHTML"];
function P3(t, e, n, s, o, r) {
  const l = H("RadioButton"),
    i = H("TooltipIndicator"),
    a = H("FormControlLabel");
  return (
    d(),
    C(
      "div",
      { class: Ae(["RadioList", t.variant]) },
      [
        (d(!0),
        C(
          Z,
          null,
          se(
            t.options,
            (u) => (
              d(),
              w(
                a,
                { key: u.value },
                {
                  default: f(() => [
                    c(
                      l,
                      {
                        "model-value": t.value,
                        value: u.value,
                        "onUpdate:modelValue": (p) =>
                          t.$emit("update:value", u.value),
                      },
                      null,
                      8,
                      ["model-value", "value", "onUpdate:modelValue"]
                    ),
                    h("span", null, [
                      F(X(u.label) + " ", 1),
                      u.tooltip
                        ? (d(),
                          w(
                            i,
                            { key: 0 },
                            {
                              default: f(() => [
                                h(
                                  "span",
                                  { innerHTML: u.tooltip },
                                  null,
                                  8,
                                  A3
                                ),
                              ]),
                              _: 2,
                            },
                            1024
                          ))
                        : z("", !0),
                    ]),
                    G(t.$slots, "default", { option: u }, void 0, !0),
                  ]),
                  _: 2,
                },
                1024
              )
            )
          ),
          128
        )),
      ],
      2
    )
  );
}
const Go = B(M3, [
    ["render", P3],
    ["__scopeId", "data-v-f3a8be9c"],
  ]),
  L3 = { class: "DirectLinkForm" },
  E3 = { key: 0 },
  F3 = S({
    __name: "DirectLinkForm",
    props: { project: {} },
    setup(t) {
      const e = t,
        {
          hasMarkings: n,
          hasColorMarkings: s,
          cells: o,
          getTinyUrlLink: r,
        } = Hi(
          e.project,
          b(() => Ye.project.includeMarkings)
        ),
        l = b({
          get() {
            return Ye.project.type;
          },
          set(k) {
            Ye.project.type = k;
          },
        }),
        i = b(() => {
          const k = e.project.toPuzzleData();
          return (k.cells = o.value), k;
        }),
        a = b(() => {
          const k = e.project.toPuzzlePreviewData();
          return (k.cells = o.value), k;
        }),
        u = b(() => new zl(i.value).saveToUrl()),
        p = b(() => u.value.length >= 12e3);
      async function m() {
        return Ye.project.type === "tinyUrl" ? r(u.value) : u.value;
      }
      async function g() {
        return new zl(i.value).saveToFile();
      }
      function v() {
        return Gc({
          date: new Date(),
          name: e.project.name || T1,
          author: e.project.author,
          extension: "puzzle.json",
        });
      }
      function $() {
        Rs(
          "Creating a URL to share failed. The puzzle might be too big. Try downloading it as a file instead."
        );
      }
      return (k, M) => (
        d(),
        C("div", L3, [
          c(
            be,
            { vertical: "", gap: "" },
            {
              default: f(() => [
                y(n) || y(s)
                  ? (d(),
                    C("div", E3, [
                      y(n)
                        ? (d(),
                          w(
                            ut,
                            { key: 0 },
                            {
                              default: f(() => [
                                c(
                                  at,
                                  {
                                    checked: y(Ye).project.includeMarkings,
                                    "onUpdate:checked":
                                      M[0] ||
                                      (M[0] = (P) =>
                                        (y(Ye).project.includeMarkings = P)),
                                  },
                                  null,
                                  8,
                                  ["checked"]
                                ),
                                M[2] ||
                                  (M[2] = F(
                                    " Include entered digits, pencil marks, color marks etc. "
                                  )),
                              ]),
                              _: 1,
                            }
                          ))
                        : z("", !0),
                      y(s)
                        ? (d(),
                          w(
                            lt,
                            { key: 1, style: { marginLeft: "1.5rem" } },
                            {
                              default: f(
                                () =>
                                  M[3] ||
                                  (M[3] = [
                                    h(
                                      "p",
                                      null,
                                      " Note: the display of color markings is dependent on user preferences and might appear differently for other users. ",
                                      -1
                                    ),
                                  ])
                              ),
                              _: 1,
                            }
                          ))
                        : z("", !0),
                    ]))
                  : z("", !0),
                c(ji, { puzzle: a.value, "editor-state": "" }, null, 8, [
                  "puzzle",
                ]),
                c(
                  ve,
                  { label: "Share:" },
                  {
                    default: f(() => [
                      c(
                        Go,
                        {
                          value: l.value,
                          "onUpdate:value":
                            M[1] || (M[1] = (P) => (l.value = P)),
                          options: [
                            { value: "tinyUrl", label: "TinyURL link" },
                            { value: "dataUrl", label: "link" },
                            { value: "file", label: "file" },
                          ],
                          variant: "horizontal",
                        },
                        null,
                        8,
                        ["value"]
                      ),
                    ]),
                    _: 1,
                  }
                ),
                l.value === "tinyUrl" && p.value
                  ? (d(),
                    w(
                      lt,
                      { key: 1, type: "warning", border: "" },
                      {
                        default: f(() => [
                          F(
                            " The generated URL might be too big for TinyURL to shorten (" +
                              X(y(Sa)(u.value.length)) +
                              "). Consider sharing your puzzle as a file instead. ",
                            1
                          ),
                        ]),
                        _: 1,
                      }
                    ))
                  : z("", !0),
                l.value === "dataUrl" && p.value
                  ? (d(),
                    w(
                      lt,
                      { key: 2, type: "warning", border: "" },
                      {
                        default: f(() => [
                          F(
                            " The generated URL is " +
                              X(y(Sa)(u.value.length)) +
                              " big. Consider sharing your puzzle as a file instead. ",
                            1
                          ),
                        ]),
                        _: 1,
                      }
                    ))
                  : z("", !0),
              ]),
              _: 1,
            }
          ),
          z("", !0),
          c(Ft, null, {
            default: f(() => [
              l.value === "file"
                ? (d(), w(Ar, { key: 0, "get-data": g, type: "json", name: v }))
                : (d(),
                  w(
                    Ar,
                    {
                      key: 1,
                      "get-data": m,
                      type: "url",
                      name: k.project.name,
                      onError: $,
                    },
                    null,
                    8,
                    ["name"]
                  )),
            ]),
            _: 1,
          }),
        ])
      );
    },
  }),
  B3 = B(F3, [["__scopeId", "data-v-034cbbe9"]]);
function Gn(t, e) {
  const n = 10 ** e;
  return Math.round(t * n) / n;
}
function Jt(t, e, n = 1e-4) {
  return Math.abs(t - e) < n;
}
function z3(t, e) {
  const n = t.cloneNode(!0);
  if (e) {
    const r = (t.width.baseVal.value * 100) / tt,
      l = (t.height.baseVal.value * 100) / tt;
    n.setAttribute("width", r.toString()),
      n.setAttribute("height", l.toString());
  }
  return n.outerHTML
    .replace(/data-v-\w+=""\s*/g, "")
    .replace(/<!--.*?-->/g, "")
    .replace(/&nbsp;/g, "&#xa0;")
    .replace(/"(\d+\.\d+)"/g, (o, r) => `"${Gn(Number(r), 5)}"`)
    .replace(/svg class="[^"]+"/, "svg")
    .replace(/ transform=""/, "");
}
async function ku(t, { asPng: e = !1 } = {}) {
  const n = z3(t, e),
    s = new Blob([n], { type: "image/svg+xml" });
  return e
    ? new Promise((o, r) => {
        const l = new Image();
        (l.src = URL.createObjectURL(s)),
          (l.onload = () => {
            const i = document.createElement("canvas");
            (i.width = l.naturalWidth), (i.height = l.naturalHeight);
            const a = i.getContext("2d");
            (a.fillStyle = "#fff"),
              a.fillRect(0, 0, i.width, i.height),
              a.drawImage(l, 0, 0),
              URL.revokeObjectURL(l.src),
              i.toBlob((u) => {
                u
                  ? o(u)
                  : r(new Error("Could not generate a blob from the canvas"));
              }, "png");
          });
      })
    : s;
}
const R3 = { class: "ImageForm" },
  O3 = S({
    __name: "ImageForm",
    props: { project: {} },
    setup(t) {
      const e = t,
        n = j(),
        { cells: s, hasMarkings: o } = Hi(
          e.project,
          b(() => Ye.image.includeMarkings)
        ),
        r = b(() => {
          const a = e.project.toPuzzlePreviewData();
          return (a.cells = s.value), a;
        });
      async function l() {
        const a = n.value.$el.querySelector("svg");
        switch (Ye.image.format) {
          case "png":
            return ku(a, { asPng: !0 });
          case "svg":
            return await ku(a);
          default:
            throw new Error(`unsupported format ${Ye.image.format}`);
        }
      }
      function i() {
        return Gc({
          date: new Date(),
          name: r.value.name || wr,
          author: r.value.author,
          extension: Ye.image.format,
        });
      }
      return (a, u) => (
        d(),
        C("div", R3, [
          c(
            be,
            { vertical: "", gap: "" },
            {
              default: f(() => [
                y(o)
                  ? (d(),
                    w(
                      ut,
                      { key: 0 },
                      {
                        default: f(() => [
                          c(
                            at,
                            {
                              checked: y(Ye).image.includeMarkings,
                              "onUpdate:checked":
                                u[0] ||
                                (u[0] = (p) =>
                                  (y(Ye).image.includeMarkings = p)),
                            },
                            null,
                            8,
                            ["checked"]
                          ),
                          u[2] ||
                            (u[2] = F(
                              " Include entered digits, pencil marks, color marks etc. "
                            )),
                        ]),
                        _: 1,
                      }
                    ))
                  : z("", !0),
                c(
                  ji,
                  { ref_key: "previewRef", ref: n, puzzle: r.value },
                  null,
                  8,
                  ["puzzle"]
                ),
                c(
                  ve,
                  { label: "File format:" },
                  {
                    default: f(() => [
                      c(
                        Go,
                        {
                          value: y(Ye).image.format,
                          "onUpdate:value":
                            u[1] || (u[1] = (p) => (y(Ye).image.format = p)),
                          variant: "horizontal",
                          options: [
                            { value: "png", label: "PNG" },
                            { value: "svg", label: "SVG" },
                          ],
                        },
                        null,
                        8,
                        ["value"]
                      ),
                    ]),
                    _: 1,
                  }
                ),
              ]),
              _: 1,
            }
          ),
          c(Ft, null, {
            default: f(() => [
              c(
                Ar,
                { name: i, type: y(Ye).image.format, "get-data": l },
                null,
                8,
                ["type"]
              ),
            ]),
            _: 1,
          }),
        ])
      );
    },
  }),
  N3 = B(O3, [["__scopeId", "data-v-44b75d6a"]]);
function qo(t) {
  const e = Symbol(`${t}Modal`);
  return {
    provide() {
      const n = rn({ params: void 0, isOpen: !1 });
      return gi(e, n), n;
    },
    inject() {
      const n = Qe(e);
      if (!n) throw new Error(`Runtime error: missing modal state for ${t}`);
      return {
        params: n.params,
        open(s) {
          s && (n.params = s), (n.isOpen = !0);
        },
        close() {
          (n.params = void 0), (n.isOpen = !1);
        },
      };
    },
  };
}
const { provide: T3, inject: Wi } = qo("puzzleMetaData"),
  V3 = S({
    __name: "ReviewPuzzleButton",
    props: { project: {} },
    setup(t) {
      const e = Wi();
      return (n, s) => (
        d(),
        C("div", null, [
          c(
            te,
            {
              class: "ReviewPuzzleButton",
              "with-icon": "",
              onClick: s[0] || (s[0] = (o) => y(e).open(n.project)),
            },
            {
              default: f(() => [
                c(ls, { inline: "" }),
                s[1] || (s[1] = h("span", null, "Review puzzle details", -1)),
              ]),
              _: 1,
            }
          ),
        ])
      );
    },
  }),
  ni = new Map();
function Le(t, e) {
  ni.set(t, e);
}
function Hn(t) {
  return [t.y, t.x];
}
function rr(t) {
  return t * 64;
}
function Zi(t) {
  const e = new Set();
  for (const n of t)
    [n[0], n.at(-1)].forEach((s) => {
      e.add(s);
    });
  return e;
}
function j3(t) {
  const e = new v1();
  return e.appendStr(t), e.end();
}
function sn(t, ...e) {
  const n = {};
  return (
    e.forEach((s) => {
      n[s] = t[s];
    }),
    n
  );
}
var Xe = ((t) => (
    (t[(t.Cell = 0)] = "Cell"),
    (t[(t.Shape = 1)] = "Shape"),
    (t[(t.BelowLine = 2)] = "BelowLine"),
    (t[(t.AboveLine = 3)] = "AboveLine"),
    (t[(t.AboveGrid = 4)] = "AboveGrid"),
    t
  ))(Xe || {}),
  si = ((t) => (
    (t[(t.Background = 0)] = "Background"),
    (t[(t.Main = 1)] = "Main"),
    (t[(t.Foreground = 2)] = "Foreground"),
    t
  ))(si || {});
const _u = {
  "#ffffffff": "#FFFFFF",
  "#cfcfcfff": "#CFCFCF",
  "#000000ff": "#000000",
};
class U3 {
  constructor(e, n) {
    L(this, "metadata", {});
    L(this, "cages", []);
    L(this, "arrows", []);
    L(this, "cells", []);
    L(this, "lines", { 0: [], 1: [], 2: [] });
    L(this, "shapes", { 0: [], 1: [], 2: [], 3: [], 4: [] });
    L(this, "fogLights");
    L(this, "triggerEffects", []);
    L(this, "regions", []);
    L(this, "helpers");
    L(this, "constructionData", {});
    var r;
    (this.projectData = e),
      (this.solution = n),
      (this.helpers = Fn(e.spec)),
      this.setMetaData("source", "Sudoku Maker v2025.07.05-57cd531"),
      this.setMetaData("title", this.projectData.name || "Untitled"),
      this.projectData.author &&
        this.setMetaData("author", this.projectData.author),
      this.projectData.comment &&
        this.setMetaData("rules", this.projectData.comment),
      (r = this.projectData.messages) != null &&
        r.completion &&
        this.setMetaData(
          "msgcorrect",
          this.projectData.messages.completion.trim()
        ),
      n &&
        this.setMetaData(
          "solution",
          typeof n == "string" ? n : n.map((l) => l ?? ".").join("")
        );
    const { width: s, height: o } = e.spec.size;
    for (let l = 0; l < o; l++) {
      const i = [];
      this.cells.push(i);
      for (let a = 0; a < s; a++) {
        const u = e.cells[a + l * s];
        i.push({
          value: u.given ? e.cells[a + l * s].value : void 0,
          centremarks: u.candidates ? [...nn(u.candidates, 0, 9)] : void 0,
          pencilMarks: u.cornerPencilMarks
            ? [...nn(u.cornerPencilMarks, 0, 9)]
            : void 0,
        });
        const p = u.colors & 65534;
        if (p) {
          const m = [...zd(p)][0];
          this.shapes[0].push({
            center: [l + 0.5, a + 0.5],
            width: 1,
            height: 1,
            backgroundColor: ee.markColors[m - 1],
          });
        }
      }
    }
  }
  getPuzzle() {
    return this.optimizePuzzle({
      id: this.getId(),
      metadata: this.metadata,
      foglight: this.getOptimizedFogLights(),
      triggereffect:
        this.triggerEffects.length === 0 ? void 0 : this.triggerEffects,
      cages: this.cages,
      cells: this.cells,
      regions: this.regions,
      lines: [
        ...this.lines[0].map((e) => ({ ...e, target: "underlay" })),
        ...this.lines[1],
        ...this.lines[2].map((e) => ({ ...e, target: "overlay" })),
      ],
      overlays: [...this.shapes[3], ...this.shapes[4]],
      underlays: [...this.shapes[0], ...this.shapes[1], ...this.shapes[2]],
      arrows: this.arrows,
    });
  }
  setMetaData(e, n) {
    this.metadata[e] = n;
  }
  getCustomData(e, n) {
    let s = this.constructionData[e];
    return (
      !this.constructionData[e] && n && (s = this.constructionData[e] = n()), s
    );
  }
  getGiven(e) {
    const { x: n, y: s } = this.helpers.cellIds.getCoordsFromId(e);
    return this.cells[s][n].value;
  }
  setRegions(e) {
    const n = [];
    for (let s = 0; s < e.length; s++)
      e[s] !== -1 &&
        (n[e[s]] || (n[e[s]] = []),
        n[e[s]].push(Hn(this.helpers.cellIds.getCoordsFromId(s))));
    this.regions = n.filter(Boolean);
  }
  addStandardLines(e, n, s, o = 1) {
    for (const r of this.optimizedLines(e))
      this.lines[o].push({
        wayPoints: r.map((l) =>
          Hn(this.helpers.cellIds.getCellCenterFromId(l))
        ),
        color: n,
        thickness: rr(s),
      });
  }
  addShapeLines(e, n, s, o = 1) {
    for (const r of e) this.addShapeLine(r, n, s, o);
  }
  addShapeLine(e, n, s, o = 1) {
    this.lines[o].push({ wayPoints: e.map(Hn), color: n, thickness: rr(s) });
  }
  addShape(e, n) {
    const s = n.outlineThickness || 0,
      o = n.text !== void 0 && n.text !== "",
      r =
        o && !n.height
          ? 0.026 * (n.fontSize || 16) + 0.114
          : (n.height || 0) + s,
      l = {
        center: Hn(e),
        width: (n.width || 0) + s,
        height: r,
        stroke: (o && n.textOutlineColor) || void 0,
        thickness: s ? rr(s) : void 0,
        text: n.text,
        fontSize: n.fontSize,
        color: n.textColor,
        angle: n.angle,
        rounded: n.rounded,
      };
    n.color && (l.backgroundColor = n.color),
      n.outlineColor && (l.borderColor = n.outlineColor),
      this.shapes[n.layer].push(l);
  }
  addCellShape(e, n) {
    this.addShape(this.helpers.cellIds.getCellCenterFromId(e), n);
  }
  addEdgeShape(e, n) {
    this.addShape(this.helpers.edgeIds.getCoordsFromId(e), n);
  }
  addCornerShape(e, n) {
    this.addShape(this.helpers.cornerIds.getCoordsFromId(e), n);
  }
  addOuterShape(e, n) {
    this.addShape(this.helpers.outerCellIds.getCellCenterFromId(e), n);
  }
  addCage(e, n = {}) {
    (n.unique && e.cells.length === 0) ||
      this.cages.push({
        cells: e.cells.map((s) => Hn(this.helpers.cellIds.getCoordsFromId(s))),
        value: e.value,
        fontC: n.textColor,
        outlineC: n.cageColor,
        unique: n.unique,
        hidden: n.hidden,
        type: n.type,
      });
  }
  addGlobalUniqueDigitsGroup(e) {
    const n = Kn(new Set(e), (s) =>
      Hn(this.helpers.cellIds.getCoordsFromId(s))
    );
    n.length !== 0 &&
      this.cages.push({ cells: n, hidden: !0, unique: !0, type: "rowcol" });
  }
  addArrow(e, n, s, o) {
    this.arrows || (this.arrows = []),
      this.arrows.push({
        wayPoints: e.map(Hn),
        headLength: o,
        color: n,
        thickness: rr(s),
      });
  }
  enableFog() {
    this.fogLights = [];
  }
  addFogLight(e) {
    this.fogLights || this.enableFog(),
      this.fogLights.push(Hn(this.helpers.cellIds.getCoordsFromId(e)));
  }
  addRevealTrigger(e, n) {
    const s = new Set(e),
      o = new Set(n);
    if (s.size === 0 || o.size === 0) return;
    const r = Kn(e, (i) => this.getCellName(i)).join(""),
      l = Kn(o, (i) => this.getCellName(i)).join("");
    this.triggerEffects.push({
      trigger: { type: "cellvalue", cell: r },
      effect: { type: "foglight", cells: l },
    });
  }
  getCellName(e) {
    return this.helpers.naming.getCellName(e).toLowerCase();
  }
  getId() {
    return `sxsm_${(
      this.projectData.author.replace(/\W/g, "") || "unknown"
    ).substring(0, 20)}_${j3(JSON.stringify(this.getCanonicalProjectData()))}`;
  }
  getCanonicalProjectData() {
    const e = sn(
      this.projectData,
      "spec",
      "cells",
      "constraints",
      "name",
      "author",
      "comment"
    );
    return (
      (e.cells = e.cells.map((n) =>
        sn(n, "given", "value", "candidates", "cornerPencilMarks", "colors")
      )),
      e
    );
  }
  optimizedLines(e) {
    return new Ut(e).toArrays();
  }
  optimizePuzzle(e) {
    var n, s, o, r;
    return (
      e.lines && (e.lines = this.getOptimizedLines(e.lines)),
      e.arrows && (e.arrows = this.getOptimizedLines(e.arrows)),
      e.overlays && (e.overlays = this.getOptimizedShapeArray(e.overlays)),
      e.underlays && (e.underlays = this.getOptimizedShapeArray(e.underlays)),
      e.cages && (e.cages = this.getOptimizedCages(e.cages)),
      ((n = e.lines) == null ? void 0 : n.length) === 0 && delete e.lines,
      ((s = e.overlays) == null ? void 0 : s.length) === 0 && delete e.overlays,
      ((o = e.underlays) == null ? void 0 : o.length) === 0 &&
        delete e.underlays,
      ((r = e.arrows) == null ? void 0 : r.length) === 0 && delete e.arrows,
      e
    );
  }
  getOptimizedShapeArray(e) {
    return ue(e)
      .filter((n) => this.getIsShapeVisible(n))
      .map(
        (n) => (
          (n.center = this.getCompactedPoint(n.center)),
          n.color && (n.color = this.getOptimizedColorOrUndefined(n.color)),
          n.backgroundColor &&
            (n.backgroundColor = this.getOptimizedColorOrUndefined(
              n.backgroundColor
            )),
          n.borderColor &&
            (n.borderColor = this.getOptimizedColorOrUndefined(n.borderColor)),
          n.width && (n.width = Gn(n.width, 3)),
          n.height && (n.height = Gn(n.height, 3)),
          n.angle && (n.angle = Gn(n.angle, 3)),
          n.fontSize && (n.fontSize = Gn(n.fontSize, 3)),
          n
        )
      );
  }
  getOptimizedLines(e) {
    return ue(e)
      .filter((n) => n.wayPoints.length > 1 && n.thickness > 0 && !Wn(n.color))
      .map(
        (n) => (
          (n.color = this.getOptimizedColor(n.color)),
          (n.wayPoints = this.removeRedundantPoints(
            n.wayPoints.map((s) => this.getCompactedPoint(s))
          )),
          (n.thickness = Gn(n.thickness, 3)),
          n
        )
      );
  }
  getOptimizedCages(e) {
    return ue(e)
      .filter((n) =>
        this.isVisibleCage(n) ? n.hidden ?? !0 : n.unique || n.hidden
      )
      .map(
        (n) => (
          this.isRemovableCageColor(n.fontC) && delete n.fontC,
          this.isRemovableCageColor(n.outlineC) && delete n.outlineC,
          n.value || (delete n.value, delete n.fontC),
          this.isVisibleCage(n) ||
            (delete n.fontC, delete n.outlineC, (n.hidden = !0)),
          n.fontC && (n.fontC = this.getOptimizedColor(n.fontC)),
          n.outlineC && (n.outlineC = this.getOptimizedColor(n.outlineC)),
          n
        )
      );
  }
  isVisibleCage(e) {
    const n = e.value && !Wn(e.fontC || "#000000"),
      s = !Wn(e.outlineC || "#000000");
    return n || s;
  }
  isRemovableCageColor(e) {
    return e === void 0 || mr(e, "#000000");
  }
  getCompactedPoint(e) {
    return [Gn(e[0], 3), Gn(e[1], 3)];
  }
  getOptimizedColorOrUndefined(e) {
    if (!Wn(e)) return this.getOptimizedColor(e);
  }
  getOptimizedColor(e) {
    const n = Gt(e);
    return (
      (e = Hs(n)),
      e in _u
        ? _u[e]
        : (e.match(/^#(.)\1(.)\2(.)\3(.)\4$/) &&
            (e = `#${e[1]}${e[3]}${e[5]}${e[7]}`),
          e)
    );
  }
  getIsShapeVisible(e) {
    const n =
        e.text !== void 0 &&
        !/^\s*$/.exec(e.text.toString()) &&
        (!e.color || !Wn(e.color)),
      s = e.backgroundColor && !Wn(e.backgroundColor),
      o = e.borderColor && !Wn(e.borderColor),
      r = e.width && e.height && e.width > 0 && e.height > 0;
    return !!(n || ((s || o) && r));
  }
  removeRedundantPoints(e) {
    const n = [];
    for (let s = 0; s < e.length; s++)
      if (s === 0 || s === e.length - 1) n.push(e[s]);
      else {
        const o = Ze(
            { x: e[s - 1][0], y: e[s - 1][1] },
            { x: e[s][0], y: e[s][1] }
          ),
          r = Ze(
            { x: e[s][0], y: e[s][1] },
            { x: e[s + 1][0], y: e[s + 1][1] }
          );
        kr(o, r) > 0.05 && n.push(e[s]);
      }
    return n;
  }
  getOptimizedFogLights() {
    if (!this.fogLights) return;
    const e = Lt.withoutDuplicates(this.fogLights, { comparator: Ce });
    if (e.length !== this.helpers.cellIds.getAllCellIds().length) return e;
  }
}
const H3 = {
  color: "c",
  cages: "ca",
  center: "ct",
  borderColor: "c1",
  backgroundColor: "c2",
  cells: "ce",
  cellSize: "cs",
  arrows: "a",
  overlays: "o",
  underlays: "u",
  width: "w",
  height: "h",
  value: "v",
  videos: "vd",
  lines: "l",
  rounded: "r",
  regions: "re",
  fontSize: "fs",
  thickness: "th",
  headLength: "hl",
  wayPoints: "wp",
  title: "t",
  text: "te",
  duration: "d",
};
class W3 {
  constructor(e) {
    L(this, "zippedPuzzle");
    this.zippedPuzzle = JSON.parse(JSON.stringify(e));
  }
  zip() {
    this.clearEmptyArrays(this.zippedPuzzle),
      this.mapProps(this.zippedPuzzle, H3),
      this.mapValues(
        this.zippedPuzzle,
        (n) => (
          typeof n == "string" &&
            String(Number.parseInt(n)) === n &&
            (n = Number.parseInt(n)),
          n
        )
      );
    let e = JSON.stringify(this.zippedPuzzle)
      .replace(/([,{[])"([a-z0-9]+)":/gi, "$1$2:")
      .replace(/([,{[])\{\}(?=[,}\]])/g, "$1")
      .replace(/(:)false([,}\]])/g, "$1f$2")
      .replace(/(:)true([,}\]])/g, "$1t$2")
      .replace(/(:)"#000000"([,}\]])/g, "$1#0$2")
      .replace(/(:)"#FFFFFF"([,}\]])/g, "$1#F$2")
      .replace(/(:)"#([0-9a-f]{6})"([,}\]])/gi, "$1$2$3");
    return (e = this.zipQuotes(e)), e;
  }
  mapProps(e, n) {
    return (
      Array.isArray(e)
        ? e.forEach((s) => this.mapProps(s, n))
        : e !== null &&
          typeof e == "object" &&
          Object.keys(e).forEach((s) => {
            if (n[s] !== void 0) {
              if (e[n[s]] !== void 0)
                throw new Error(
                  `Prop mapping collision from ${s}: ${e[s]} to ${n[s]}: ${
                    e[n[s]]
                  }`
                );
              (e[n[s]] = e[s]), delete e[s], (s = n[s]);
            }
            this.mapProps(e[s], n);
          }),
      e
    );
  }
  mapValues(e, n) {
    return (
      Array.isArray(e)
        ? e.forEach((s, o) => {
            e[o] = this.mapValues(s, n);
          })
        : e !== null && typeof e == "object"
        ? Object.keys(e).forEach((s) => {
            s !== "metadata" && (e[s] = this.mapValues(e[s], n));
          })
        : (e = n(e)),
      e
    );
  }
  clearEmptyArrays(e) {
    return (
      Array.isArray(e)
        ? e.forEach((n) => this.clearEmptyArrays(n))
        : e !== null &&
          typeof e == "object" &&
          Object.keys(e).forEach((n) => {
            this.clearEmptyArrays(e[n]),
              Array.isArray(e[n]) && e[n].length === 0 && delete e[n];
          }),
      e
    );
  }
  zipQuotes(e) {
    return e.replace(/'/g, "\\'").replace(/"/g, "'");
  }
}
const jd = 0.025;
function Ud(t, e, n, s, o) {
  const r = n - Math.sqrt(n ** 2 - 0.25 * s ** 2) || n,
    l = o.cellIds.getCellCenterFromId(t),
    i = o.cellIds.getCellCenterFromId(e),
    a = bo(Ze(i, l));
  return Qn(l, a, n - r);
}
function Z3(t, e, n, s, o = jd) {
  const r = [];
  for (let l = 0; l < t.length; l++)
    if (l === 0) r.push(Ud(t[0], t[1], e, n, s));
    else if (l === t.length - 1) {
      const i = s.cellIds.getCellCenterFromId(t[l]),
        a = s.cellIds.getCellCenterFromId(t[l - 1]),
        u = bo(Ze(i, a));
      r.push(Qn(i, u, -o));
    } else r.push(s.cellIds.getCellCenterFromId(t[l]));
  return r;
}
function G3(t) {
  if (t.length < 3) return !1;
  const e = t[1].x - t[0].x,
    n = t[1].y - t[0].y;
  for (let s = 1; s < t.length - 1; s++)
    if (t[s + 1].x - t[s].x !== e || t[s + 1].y - t[s].y !== n) return !0;
  return !1;
}
function q3(t) {
  const e = t[0],
    n = t.at(-1);
  if (t.length < 2)
    return {
      x: (e.x + n.x) / 2,
      y: (e.y + n.y) / 2,
      angle: 0,
      width: n.x - e.x,
      height: n.y - e.y,
    };
  const s = n.x - e.x,
    o = n.y - e.y;
  return {
    x: (e.x + n.x) / 2,
    y: (e.y + n.y) / 2,
    angle: (Math.atan2(o, s) / Math.PI) * 180,
    width: Math.sqrt(s * s + o * o),
    height: 0,
  };
}
Le(_.Arrow, {
  sudokuPad: (t, e) => {
    for (const n of e.bulbsWithArrows) {
      const s = n.bulbCells.map((o) =>
        t.helpers.cellIds.getCellCenterFromId(o)
      );
      if (G3(s))
        t.addStandardLines(
          [n.bulbCells],
          e.style.bulb.stroke.color,
          e.style.bulb.size + e.style.bulb.stroke.thickness
        ),
          t.addStandardLines(
            [n.bulbCells],
            Wn(e.style.bulb.fill) ? "#ffffff" : e.style.bulb.fill,
            e.style.bulb.size - e.style.bulb.stroke.thickness
          );
      else {
        const { x: o, y: r, angle: l, width: i, height: a } = q3(s);
        t.addShape(
          { x: o, y: r },
          {
            layer: Xe.AboveLine,
            width: e.style.bulb.size + i,
            height: e.style.bulb.size + a,
            rounded: !0,
            angle: l,
            color: e.style.bulb.fill,
            outlineThickness: e.style.bulb.stroke.thickness,
            outlineColor: e.style.bulb.stroke.color,
          }
        );
      }
      for (const o of n.arrows) {
        const r = o.map((l) => t.helpers.cellIds.getCellCenterFromId(l));
        (r[0] = Ud(
          o[0],
          o[1],
          e.style.bulb.size / 2,
          e.style.arrow.thickness,
          t.helpers
        )),
          t.addArrow(
            r,
            e.style.arrow.color,
            e.style.arrow.thickness,
            e.style.arrow.headSize
          );
      }
    }
  },
});
Le(_.Clone, {
  sudokuPad: (t, e) => {
    for (const n of e.groups.flat())
      t.addCellShape(n, {
        layer: Xe.Cell,
        width: 1,
        height: 1,
        color: e.style.color,
      });
  },
});
Le(_.ColumnIndexer, {
  sudokuPad: (t, e) => {
    for (const n of e.cells)
      t.addCellShape(n, {
        layer: Xe.Cell,
        width: 1,
        height: 1,
        color: e.style.color,
      });
  },
});
Le(_.RowIndexer, {
  sudokuPad: (t, e) => {
    for (const n of e.cells)
      t.addCellShape(n, {
        layer: Xe.Cell,
        width: 1,
        height: 1,
        color: e.style.color,
      });
  },
});
Le(_.BetweenLines, {
  sudokuPad: (t, e) => {
    t.addStandardLines(e.lines, e.style.lines.color, e.style.lines.thickness);
    const n = e.style.endPoints;
    for (const s of Zi(e.lines))
      t.addCellShape(s, {
        layer: Xe.AboveLine,
        color: n.fill,
        outlineThickness: n.stroke.thickness,
        outlineColor: n.stroke.color,
        width: n.size,
        height: n.size,
        rounded: !0,
      });
  },
});
Le(_.CosmeticCage, {
  sudokuPad: (t, e) => {
    for (const n of e.cages)
      t.addCage(n, {
        cageColor: e.style.cage.color,
        textColor: e.style.text.color,
      });
  },
});
Le(_.CosmeticSymbol, {
  sudokuPad: (t, e) => {
    for (const n of e.symbols) {
      const s = n.layer === oe.Foreground ? Xe.AboveGrid : Xe.BelowLine;
      switch (n.params.type) {
        case pe.Ellipse:
          t.addShape(n.position, {
            layer: s,
            rounded: !0,
            width: n.params.rx * 2,
            height: n.params.ry * 2,
            color: n.params.fill,
            outlineColor: n.params.strokeWidth ? n.params.stroke : void 0,
            outlineThickness: n.params.strokeWidth,
            angle: n.params.angle,
          });
          break;
        case pe.Text:
          t.addShape(n.position, {
            layer: s,
            rounded: !0,
            text: n.params.text,
            fontSize: n.params.size * 60,
            textColor: n.params.fill,
            textOutlineColor: n.params.strokeWidth ? n.params.stroke : void 0,
            angle: n.params.angle,
          });
          break;
        case pe.Rectangle:
          t.addShape(n.position, {
            layer: s,
            width: n.params.width,
            height: n.params.height,
            color: n.params.fill,
            outlineColor: n.params.strokeWidth ? n.params.stroke : void 0,
            outlineThickness: n.params.strokeWidth,
            angle: n.params.angle,
          });
          break;
        case pe.Arrow: {
          const o = en({ x: n.params.length / 2, y: 0 }, wi(n.params.angle));
          t.addArrow(
            [Qn(n.position, o, -1), ft(n.position, o)],
            n.params.stroke,
            n.params.strokeWidth,
            n.params.headSize
          );
        }
      }
    }
  },
});
Le(_.DiagonalMinus, {
  sudokuPad: (t, e) => {
    const n = t.projectData.spec.size.width,
      s = e.style.thickness / 2;
    t.addShapeLine(
      [
        { x: s, y: s },
        { x: n - s, y: n - s },
      ],
      e.style.color,
      e.style.thickness
    );
    const o = Array.from({ length: n }, (r, l) =>
      t.helpers.cellIds.getIdFromCoords({ x: l, y: l })
    );
    t.addCage({ cells: o, value: "" }, { unique: !0, hidden: !0 });
  },
});
Le(_.DiagonalPlus, {
  sudokuPad: (t, e) => {
    const n = t.projectData.spec.size.width,
      s = e.style.thickness / 2;
    t.addShapeLine(
      [
        { x: s, y: n - s },
        { x: n - s, y: s },
      ],
      e.style.color,
      e.style.thickness
    );
    const o = Array.from({ length: n }, (r, l) =>
      t.helpers.cellIds.getIdFromCoords({ x: l, y: n - 1 - l })
    );
    t.addCage({ cells: o, value: "" }, { unique: !0, hidden: !0 });
  },
});
const $u = Xe.Shape;
Le(_.DifferentValues, {
  sudokuPad: (t, e) => {
    const n = t.helpers.cellIds;
    if (e.cells.length !== 0) {
      t.addCage({ cells: e.cells, value: "" }, { unique: !0, hidden: !0 });
      for (const s of e.cells)
        if (e.style.offset > 0) {
          const { x: o, y: r } = n.getCoordsFromId(s),
            l = e.cells.includes(n.getIdFromCoordsSafe({ x: o - 1, y: r })),
            i = e.cells.includes(n.getIdFromCoordsSafe({ x: o + 1, y: r })),
            a = e.cells.includes(n.getIdFromCoordsSafe({ x: o, y: r - 1 })),
            u = e.cells.includes(n.getIdFromCoordsSafe({ x: o, y: r + 1 })),
            p = e.cells.includes(n.getIdFromCoordsSafe({ x: o - 1, y: r - 1 })),
            m = e.cells.includes(n.getIdFromCoordsSafe({ x: o + 1, y: r - 1 })),
            g = e.cells.includes(n.getIdFromCoordsSafe({ x: o - 1, y: r + 1 })),
            v = e.cells.includes(n.getIdFromCoordsSafe({ x: o + 1, y: r + 1 })),
            $ = [
              l && a && p,
              a,
              i && a && m,
              l,
              !0,
              i,
              l && u && g,
              u,
              i && u && v,
            ],
            k = e.style.offset,
            M = 1 - 2 * k,
            P = 1 - k,
            x = [
              { x: 0, y: 0, width: k, height: k },
              { x: k, y: 0, width: M, height: k },
              { x: P, y: 0, width: k, height: k },
              { x: 0, y: k, width: k, height: M },
              { x: k, y: k, width: M, height: M },
              { x: P, y: k, width: k, height: M },
              { x: 0, y: P, width: k, height: k },
              { x: k, y: P, width: M, height: k },
              { x: P, y: P, width: k, height: k },
            ];
          for (let A = 0; A < 9; A++)
            $[A] &&
              t.addShape(
                {
                  x: o + x[A].x + x[A].width / 2,
                  y: r + x[A].y + x[A].height / 2,
                },
                {
                  layer: $u,
                  width: x[A].width,
                  height: x[A].height,
                  color: e.style.color,
                }
              );
        } else
          t.addCellShape(s, {
            layer: $u,
            width: 1,
            height: 1,
            color: e.style.color,
          });
    }
  },
});
Le(_.DoubleArrow, {
  sudokuPad: (t, e) => {
    t.addStandardLines(e.lines, e.style.lines.color, e.style.lines.thickness);
    const n = e.style.endPoints;
    for (const s of Zi(e.lines))
      t.addCellShape(s, {
        layer: Xe.AboveLine,
        color: n.fill,
        outlineThickness: n.stroke.thickness,
        outlineColor: n.stroke.color,
        width: n.size,
        height: n.size,
        rounded: !0,
      });
  },
});
Le(_.Difference, {
  sudokuPad: (t, e) => {
    const n = e.clues.some((s) => s.value !== 1);
    for (const s of e.clues)
      t.addEdgeShape(s.edge, {
        layer: Xe.AboveGrid,
        width: 0.32,
        height: 0.32,
        rounded: !0,
        outlineThickness: 0.02,
        outlineColor: "#000000",
        color: "#FFFFFF",
        textColor: "#000000",
        text: n ? s.value : "",
      });
  },
});
Le(_.Ratio, {
  sudokuPad: (t, e) => {
    const n = e.clues.some((s) => s.value !== 2);
    for (const s of e.clues)
      t.addEdgeShape(s.edge, {
        layer: Xe.AboveGrid,
        width: 0.33,
        height: 0.33,
        rounded: !0,
        color: "#000000",
        textColor: "#FFFFFF",
        text: n ? s.value : "",
      });
  },
});
Le(_.XV, {
  sudokuPad: (t, e) => {
    for (const n of e.clues)
      (n.value !== 5 && n.value !== 10) ||
        t.addEdgeShape(n.edge, {
          layer: Xe.AboveGrid,
          width: 0.35,
          height: 0.35,
          rounded: !0,
          color: "#FFFFFF",
          text: n.value === 5 ? "V" : "X",
          textOutlineColor: "#000000",
          fontSize: 14,
        });
  },
});
Le(_.Even, {
  sudokuPad: (t, e) => {
    for (const n of e.cells)
      t.addCellShape(n, {
        layer: Xe.Shape,
        width: e.style.size,
        height: e.style.size,
        color: e.style.color,
      });
  },
});
Le(_.Odd, {
  sudokuPad: (t, e) => {
    for (const n of e.cells)
      t.addCellShape(n, {
        layer: Xe.Shape,
        width: e.style.size,
        height: e.style.size,
        rounded: !0,
        color: e.style.color,
      });
  },
});
const K3 = [
  {
    type: _.FogTriggers,
    triggers: [],
    effects: [],
    overrides: [],
    patterns: [Be.Self, Be.OrthogonalNeighbors, Be.DiagonalNeighbors],
    editor: { defaultDisabling: !1 },
  },
];
function Hd(t, e) {
  t.length === 0 && (t = K3);
  const n = [],
    s = new Set(e.cellIds.getAllCellIds());
  for (const r of t) n.push(...X3(r)), He.deleteAll(s, r.overrides);
  const o = Y3(t);
  for (const r of s) {
    const l = J3(r, o, e);
    l.size > 0 && n.push({ triggerCells: new Set([r]), effectCells: l });
  }
  return n;
}
function X3(t) {
  const e = new Map();
  for (const n of t.triggers)
    e.set(n.label, { triggerCells: new Set(n.cells), effectCells: new Set() });
  for (const n of t.effects)
    e.has(n.label) && He.addAll(e.get(n.label).effectCells, n.cells);
  return e.values();
}
function Y3(t) {
  const e = new Set();
  for (const n of t) He.addAll(e, n.patterns);
  return e;
}
function J3(t, e, n) {
  const s = new Set();
  return (
    e.has(Be.Self) && s.add(t),
    e.has(Be.OrthogonalNeighbors) &&
      He.addAll(s, n.geometry.getOrthogonallyAdjacentCells(t)),
    e.has(Be.DiagonalNeighbors) &&
      He.addAll(s, n.geometry.getDiagonallyAdjacentCells(t)),
    e.has(Be.Row) && He.addAll(s, n.geometry.getCellsInRowOfCell(t)),
    e.has(Be.Column) && He.addAll(s, n.geometry.getCellsInColumnOfCell(t)),
    e.has(Be.KnightsMoves) &&
      He.addAll(s, n.geometry.getCellsKnightsMoveAwayFromCell(t)),
    s
  );
}
function Wd(t) {
  return t.getCustomData(_.FogLights, () => ({
    lightConfigs: [],
    triggerConfigs: [],
    convertedTriggers: !1,
  }));
}
function Zd(t) {
  const e = t.getCustomData(_.FogLights);
  if (e.convertedTriggers) return;
  const n = Hd(e.triggerConfigs, t.helpers);
  if (!Q3(n, t)) {
    const s = e.lightConfigs.flatMap((o) => o.lightCells);
    for (const o of n) {
      const r = Lt.withoutAll([...o.effectCells], s);
      t.addRevealTrigger(o.triggerCells, r);
    }
  }
  e.convertedTriggers = !0;
}
Le(_.FogLights, {
  sudokuPadPre: (t, e) => {
    Wd(t).lightConfigs.push(e), t.enableFog();
    for (const s of e.lightCells) t.addFogLight(s);
  },
  sudokuPad: Zd,
});
Le(_.FogTriggers, {
  sudokuPadPre: (t, e) => {
    Wd(t).triggerConfigs.push(e);
  },
  sudokuPad: Zd,
});
function Q3(t, e) {
  const n = e.helpers;
  for (const { triggerCells: s, effectCells: o } of t) {
    if (s.size > 1) return !1;
    const r = Si.getOne(s);
    if (o.size === 1 && e.getGiven(r) !== void 0 && [...o][0] === r) continue;
    const l = new Set([r, ...n.geometry.getAdjacentCells(r, !0)]);
    if (!Ce(l, o)) return !1;
  }
  return !0;
}
const Gd = [
    { x: -0.44, y: -0.12 },
    { x: -0.39, y: 0 },
    { x: -0.44, y: 0.12 },
  ],
  qd = [
    { x: -0.39, y: -0.12 },
    { x: -0.44, y: 0 },
    { x: -0.39, y: 0.12 },
  ];
function Kd(t, e, n, s) {
  const { width: o, height: r } = t.projectData.spec.size,
    l = s.map((p) => en(p, Math.PI / 2)),
    i = s.map((p) => en(p, Math.PI)),
    a = s.map((p) => en(p, -Math.PI / 2));
  function u(p, m, g) {
    const { x: v, y: $ } = t.helpers.cellIds.getCoordsFromId(p);
    if (
      !(m < 0 && v === 0) &&
      !(g < 0 && $ === 0) &&
      !(m > 0 && v === o - 1) &&
      !(g > 0 && $ === r - 1)
    )
      return t.helpers.cellIds.getIdFromCoordsSafe({ x: v + m, y: $ + g });
  }
  for (const p of e) {
    t.addCellShape(p, { layer: Xe.Cell, width: 1, height: 1, color: n });
    const m = u(p, -1, 0),
      g = u(p, 1, 0),
      v = u(p, 0, -1),
      $ = u(p, 0, 1),
      k = [];
    m !== void 0 && !e.includes(m) && k.push(s),
      g !== void 0 && !e.includes(g) && k.push(i),
      v !== void 0 && !e.includes(v) && k.push(l),
      $ !== void 0 && !e.includes($) && k.push(a);
    for (const M of k)
      t.addShapeLine(
        M.map((P) => ft(t.helpers.cellIds.getCellCenterFromId(p), P)),
        "#000000",
        0.03
      );
  }
}
Le(_.Minimum, {
  sudokuPad: (t, e) => {
    Kd(t, e.cells, e.style.color, Gd);
  },
});
Le(_.Maximum, {
  sudokuPad: (t, e) => {
    Kd(t, e.cells, e.style.color, qd);
  },
});
Le(_.Antiking, {
  sudokuPad: (t) => {
    t.setMetaData("antiking", !0);
  },
});
Le(_.Antiknight, {
  sudokuPad: (t) => {
    t.setMetaData("antiknight", !0);
  },
});
Le(_.DisjointGroups, {
  sudokuPad: (t) => {
    const e = t.projectData.constraints.find(
      (o) => o.config.type === _.Regions
    );
    if (!e) return;
    const n = D0(e.config.regions),
      s = n[0].length;
    if (n.every((o) => o.length === s))
      for (let o = 0; o < s; o++)
        t.addGlobalUniqueDigitsGroup(n.map((r) => r[o]));
  },
});
Le(_.KillerCages, {
  sudokuPad: (t, e) => {
    for (const n of e.cages)
      t.addCage(
        { cells: n.cells, value: n.value || "" },
        {
          cageColor: e.style.cage.color,
          textColor: e.style.text.color,
          unique: !0,
        }
      );
  },
});
function Gi(t) {
  const e = (s) => s.x % 1 === 0 || s.y % 1 === 0,
    n = (s) => {
      for (let o = 0; o < s.length - 1; o++)
        if (
          e(s[o]) &&
          e(s[o + 1]) &&
          (s[o].x === s[o + 1].x || s[o].y === s[o + 1].y)
        )
          return !0;
      return !1;
    };
  return t.some(n) ? oe.Foreground : oe.Default;
}
function Xd(t, e, n) {
  const { width: s, height: o } = n.size,
    r = t.flat(),
    l = e.thickness / 2,
    i = r.reduce((m, g) => Math.min(m, g.x - l), 0),
    a = r.reduce((m, g) => Math.min(m, g.y - l), 0),
    u = r.reduce((m, g) => Math.max(m, g.x + l), s),
    p = r.reduce((m, g) => Math.max(m, g.y + l), o);
  return { left: -i, right: u - s, top: -a, bottom: p - o };
}
function eC(t, e) {
  t.addStandardLines(e.lines, e.style.color, e.style.thickness);
}
const tC = [
  _.EntropyLines,
  _.Palindrome,
  _.RegionSumLine,
  _.Renban,
  _.Sequence,
  _.Whisper,
];
for (const t of tC) Le(t, { sudokuPad: eC });
Le(_.CosmeticLine, {
  sudokuPad: (t, e) => {
    const n = e.style.layer || Gi(e.lines);
    t.addShapeLines(
      e.lines,
      e.style.color,
      e.style.thickness,
      n === oe.Default ? si.Main : si.Foreground
    );
  },
});
const Yd = 0.18;
function Jd(t, e, n) {
  return t.y < 0
    ? e === Se.PositiveDiagonal
      ? _n.BottomLeft
      : _n.BottomRight
    : t.y >= n.height
    ? e === Se.PositiveDiagonal
      ? _n.TopRight
      : _n.TopLeft
    : t.x < 0
    ? e === Se.PositiveDiagonal
      ? _n.TopRight
      : _n.BottomRight
    : e === Se.PositiveDiagonal
    ? _n.BottomLeft
    : _n.TopLeft;
}
function Qd(t) {
  return [
    { x: -0.234, y: -0.234 },
    { x: -0.432, y: -0.432 },
  ].map((n) => en(n, (t * Math.PI) / 2));
}
Le(_.LittleKillers, {
  sudokuPad: (t, e) => {
    for (const n of e.clues) {
      if (n.value === void 0) continue;
      const s = t.helpers.outerCellIds.getCellCenterFromId(n.outerCell),
        o = Jd(s, n.diagonal, t.projectData.spec.size),
        r = Qd(o);
      t.addArrow(
        r.map((l) => ft(l, s)),
        e.style.arrow.color,
        0.05,
        Yd
      ),
        t.addOuterShape(n.outerCell, {
          layer: Xe.AboveGrid,
          textColor: e.style.text.color,
          text: n.value,
          fontSize: 32,
          rounded: !0,
          width: 1,
          height: 1,
        });
    }
  },
});
Le(_.LockoutLines, {
  sudokuPad: (t, e) => {
    t.addStandardLines(e.lines, e.style.lines.color, e.style.lines.thickness);
    const n = e.style.endPoints;
    for (const s of Zi(e.lines))
      t.addCellShape(s, {
        layer: Xe.AboveLine,
        color: n.fill,
        outlineThickness: n.stroke.thickness,
        outlineColor: n.stroke.color,
        width: Math.SQRT1_2 * n.size,
        height: Math.SQRT1_2 * n.size,
        angle: 45,
      });
  },
});
Le(_.LookAndSayCages, {
  sudokuPad: (t, e) => {
    for (const n of e.cages)
      t.addCage(n, {
        cageColor: e.style.cage.color,
        textColor: e.style.text.color,
      });
  },
});
const nC = [_.SandwichSums, _.NumberedRooms, _.Skyscrapers, _.XSums];
nC.forEach((t) => {
  Le(t, {
    sudokuPad: (e, n) => {
      for (const s of n.clues)
        s.value !== void 0 &&
          e.addOuterShape(s.outerCell, {
            layer: Xe.AboveGrid,
            textColor: n.style.color,
            text: s.value,
            fontSize: 32,
            rounded: !0,
            width: 1,
            height: 1,
          });
    },
  });
});
const ep = {
  1: [{ x: 0, y: 0 }],
  2: [
    { x: -0.085, y: 0 },
    { x: 0.085, y: 0 },
  ],
  3: [
    { x: -0.085, y: -0.12 },
    { x: 0.085, y: -0.12 },
    { x: 0, y: 0.12 },
  ],
  4: [
    { x: -0.085, y: -0.12 },
    { x: 0.085, y: -0.12 },
    { x: -0.085, y: 0.12 },
    { x: 0.085, y: 0.12 },
  ],
};
Le(_.Quadruple, {
  sudokuPad: (t, e) => {
    for (const n of e.clues) {
      const s = n.digits.length;
      if (
        (t.addCornerShape(n.corner, {
          layer: Xe.AboveGrid,
          color: "#FFFFFF",
          outlineColor: "#000000",
          outlineThickness: 0.02,
          width: 0.6,
          height: 0.6,
          rounded: !0,
          text: e.style.singleLine ? n.digits.slice().sort().join("") : "",
        }),
        s > 0 && !e.style.singleLine)
      ) {
        const o = ep[s] || [],
          r = t.helpers.cornerIds.getCoordsFromId(n.corner);
        for (let l = 0; l < s; l++)
          t.addShape(ft(r, o[l]), {
            layer: Xe.AboveGrid,
            width: 0.1,
            height: 0.1,
            text: n.digits[l],
          });
      }
    }
  },
});
Le(_.Regions, {
  sudokuPad: (t, e) => {
    t.setRegions(e.regions);
  },
});
class Do {
  constructor(e = []) {
    L(this, "points", new Set());
    L(this, "pointsAfter", new Map());
    L(this, "pointsBefore", new Map());
    for (const n of e) this.addLine(n);
  }
  addLine(e) {
    for (let n = 0; n < e.length - 1; n++) this.addEdge(e[n], e[n + 1]);
    return this;
  }
  addEdge(e, n) {
    return (
      (e = Ue(e)),
      (n = Ue(n)),
      this.pointsAfter.has(e) || this.pointsAfter.set(e, new Set()),
      this.pointsBefore.has(n) || this.pointsBefore.set(n, new Set()),
      this.pointsAfter.get(e).add(n),
      this.pointsBefore.get(n).add(e),
      this.points.add(e),
      this.points.add(n),
      this
    );
  }
  removeEdge(e, n) {
    var s, o, r, l, i, a, u, p;
    return (
      (e = Ue(e)),
      (n = Ue(n)),
      (s = this.pointsAfter.get(e)) == null || s.delete(n),
      ((o = this.pointsAfter.get(e)) == null ? void 0 : o.size) === 0 &&
        this.pointsAfter.delete(e),
      (r = this.pointsBefore.get(n)) == null || r.delete(e),
      ((l = this.pointsBefore.get(n)) == null ? void 0 : l.size) === 0 &&
        this.pointsBefore.delete(n),
      !((i = this.pointsAfter.get(e)) != null && i.size) &&
        !((a = this.pointsBefore.get(e)) != null && a.size) &&
        this.points.delete(e),
      !((u = this.pointsAfter.get(n)) != null && u.size) &&
        !((p = this.pointsBefore.get(n)) != null && p.size) &&
        this.points.delete(n),
      this
    );
  }
  removePoint(e) {
    if (((e = Ue(e)), !this.points.has(e))) return this;
    if (this.pointsAfter.has(e))
      for (const n of this.pointsAfter.get(e)) this.removeEdge(e, n);
    if (this.pointsBefore.has(e))
      for (const n of this.pointsBefore.get(e)) this.removeEdge(n, e);
    return this;
  }
  hasEdge(e, n) {
    var s;
    return (
      (e = Ue(e)),
      (n = Ue(n)),
      !!((s = this.pointsAfter.get(e)) != null && s.has(n))
    );
  }
  hasPoint(e) {
    return (e = Ue(e)), this.points.has(e);
  }
  getPoints() {
    return [...this.points];
  }
  getPointCount() {
    return this.points.size;
  }
  isEmpty() {
    return this.points.size === 0;
  }
  *getEdges() {
    for (const [e, n] of this.pointsAfter) for (const s of n) yield [e, s];
  }
  hasMergePoints() {
    for (const e of this.pointsBefore.values()) if (e.size > 1) return !0;
    return !1;
  }
  hasBranchPoints() {
    for (const e of this.pointsAfter.values()) if (e.size > 1) return !0;
    return !1;
  }
  hasCycles() {
    const e = new Set(),
      n = new Set(),
      s = (o) => {
        if (!e.has(o)) {
          e.add(o), n.add(o);
          const r = this.pointsAfter.get(o);
          if (r) {
            for (const l of r) if ((!e.has(l) && s(l)) || n.has(l)) return !0;
          }
        }
        return n.delete(o), !1;
      };
    for (const o of this.getPoints()) if (!e.has(o) && s(o)) return !0;
    return !1;
  }
  getComponentsContainingPoints(e) {
    e = [...e].map((r) => Ue(r));
    const n = new Set(e),
      s = [];
    for (; n.size > 0; ) {
      const r = Mn(n),
        l = [...this.getPointsConnectedTo(r)];
      Ur(n, l), s.push(l);
    }
    const o = new Do();
    for (const r of s)
      for (const l of r)
        if (this.pointsAfter.has(l))
          for (const i of this.pointsAfter.get(l)) o.addEdge(l, i);
    return o;
  }
  getPointsConnectedTo(e) {
    e = Ue(e);
    const n = new Set(),
      s = () => {
        const r = new Set([e]);
        for (; r.size > 0; ) {
          const l = Mn(r);
          if (!n.has(l) && (n.add(l), this.pointsBefore.has(l)))
            for (const i of this.pointsBefore.get(l)) r.add(i);
        }
      },
      o = () => {
        const r = new Set([e]);
        for (; r.size > 0; ) {
          const l = Mn(r);
          if (!n.has(l) && (n.add(l), this.pointsAfter.has(l)))
            for (const i of this.pointsAfter.get(l)) r.add(i);
        }
      };
    return s(), o(), n;
  }
  toArrays() {
    const e = this.clone(),
      n = () => {
        for (const l of e.pointsAfter.keys())
          if (!e.pointsBefore.get(l) || e.pointsBefore.get(l)) return l;
        return wo(e.pointsAfter.keys());
      };
    let s = 0;
    function o() {
      const l = new Set(),
        i = [];
      let a = n();
      for (;;) {
        if ((s++, s > 1e3)) throw new Error("This should never happen");
        if ((i.push(a), l.has(a))) return i;
        l.add(a);
        const u = e.pointsAfter.get(a),
          p = u ? wo(u) : void 0;
        if (p === void 0) return i;
        e.removeEdge(a, p), (a = p);
      }
    }
    const r = [];
    for (; e.getPointCount() > 0; ) r.push(o());
    return r;
  }
  clone() {
    return new Do(this.getEdges());
  }
}
class tp extends Do {
  isValid(e) {
    return !(
      this.hasCycles() ||
      !this.checkUniqueThermoPaths() ||
      (e && !this.checkThermoPathLengths(e))
    );
  }
  getMinimalThermos() {
    const e = (l) => this.pointsAfter.get(l),
      n = new Set(),
      s = function* (l, i = 0) {
        if (n.has(l)) {
          yield [l];
          return;
        }
        n.add(l);
        const a = e(l);
        if (!a) {
          yield [l];
          return;
        }
        for (const u of a) for (const p of s(u, i + 1)) yield [l, ...p];
      },
      o = [];
    for (const l of this.pointsAfter.keys())
      this.pointsBefore.has(l) || o.push(l);
    const r = [];
    for (const l of o) r.push(...s(l));
    return r;
  }
  checkThermoPathLengths(e) {
    const n = new Map(),
      s = (o) => {
        if (n.has(o)) return n.get(o);
        const r = this.pointsAfter.get(o);
        if (!r) return 0;
        let l = 0;
        for (const i of r) l = Math.max(l, 1 + s(i));
        return n.set(o, l), l;
      };
    for (const o of this.pointsAfter.keys())
      if (!this.pointsBefore.has(o) && s(o) > e) return !1;
    return !0;
  }
  checkUniqueThermoPaths() {
    const e = new Set(),
      n = new Set();
    for (const l of this.pointsAfter.keys())
      (!this.pointsBefore.get(l) || this.pointsBefore.get(l).size === 0) &&
        e.add(l);
    for (const [l, i] of this.pointsBefore)
      if (!this.pointsAfter.get(l) || this.pointsAfter.get(l).size === 0) {
        if (i.size > 1 && !_i(e, i)) return !1;
        n.add(l);
      }
    const s = new Ut(this.toArrays());
    function* o(l, i, a = [l]) {
      for (const u of s.getPointsAdjacentTo(l))
        a.includes(u) || (u === i ? yield a : yield* o(u, i, a.concat([u])));
    }
    const r = new Set();
    for (const l of e)
      for (const i of n)
        for (const a of o(l, i))
          if (!uc(a.slice(1), e))
            for (let u = 0; u < a.length - 1; u++) {
              const p = `${a[u]}_${a[u + 1]}`,
                m = `${a[u + 1]}_${a[u]}`;
              if (r.has(m)) return !1;
              r.add(p);
            }
    return !0;
  }
}
Le(_.Thermometer, {
  sudokuPad: (t, e) => {
    const n = [],
      s = new tp(e.thermometers),
      o = new Set();
    for (const r of s.getMinimalThermos()) n.push(r), o.add(r[0]);
    for (const r of o)
      t.addCellShape(r, {
        layer: Xe.BelowLine,
        width: e.style.bulbRadius * 2,
        height: e.style.bulbRadius * 2,
        rounded: !0,
        color: e.style.color,
      });
    for (const r of n)
      t.addStandardLines([r], e.style.color, e.style.thickness);
  },
});
function np(t, e) {
  const n = new U3(t, e);
  for (const s of t.constraints) {
    const o = ni.get(s.config.type);
    o != null && o.sudokuPadPre && o.sudokuPadPre(n, s.config);
  }
  for (const s of t.constraints) {
    const o = ni.get(s.config.type);
    o != null && o.sudokuPad && o.sudokuPad(n, s.config);
  }
  return n.getPuzzle();
}
async function oi(t) {
  const e = new Li().compressToBase64(JSON.stringify(t)),
    n = {
      method: "post",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ puzzle: `scl${e}` }),
      signal: AbortSignal.timeout(3e4),
    };
  try {
    const o = await (
      await fetch("https://sudokupad.app/admin/createlink", n)
    ).json();
    return o.result !== "success" || !o.shortid
      ? Su(t)
      : `https://sudokupad.app/${o.shortid}`;
  } catch {
    return Su(t);
  }
}
function Su(t) {
  const e = new W3(t).zip();
  return `https://sudokupad.app/scl${new Li().compressToBase64(e)}`;
}
function sC(...t) {
  const e = j(Date.now());
  return (
    ae(
      () => t,
      () => {
        e.value = Date.now();
      },
      { deep: !0 }
    ),
    e
  );
}
const oC = { components: { Icon: he } };
function rC(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "Wrench", viewBox: "-1 -1 22 22" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "m7.541 9.447 7.677-8.53a2.77 2.77 0 0 1 2.935-.775l.001.001a2.693 2.693 0 0 1 1.703 1.703l.001.001a2.77 2.77 0 0 1-.775 2.935l-8.53 7.677a5.481 5.481 0 0 1-6.035 7.457.299.299 0 0 1-.157-.505L7.15 16.62l-.797-2.973-2.973-.797-2.79 2.79a.3.3 0 0 1-.507-.158 5.481 5.481 0 0 1 7.458-6.035Zm9.89-7.878a1 1 0 1 1 0 2 1 1 0 0 1 0-2Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Mo = B(oC, [["render", rC]]),
  lC = /("(?:[^\\"]|\\.)*")|[:,]/g;
class qi {
  constructor(e = 80) {
    L(this, "indent", "  ");
    this.maxLength = e;
  }
  stringify(e) {
    return this.stringifyImpl(e);
  }
  stringifyImpl(e, n = "", s = 0) {
    const o = JSON.stringify(e);
    if (o === void 0) throw new Error(`Unable to stringify ${e}`);
    const r = this.maxLength - n.length - s;
    if (o.length <= r) {
      const l = o.replace(lC, (i, a) => a || `${i} `);
      if (l.length <= r) return l;
    }
    if (typeof e == "object" && e !== null) {
      const l = n + this.indent;
      let i, a, u;
      if (Array.isArray(e))
        (a = "["),
          (u = "]"),
          (i = e.map((p, m) =>
            e[m] === void 0
              ? "null"
              : this.stringifyImpl(e[m], l, m === e.length - 1 ? 0 : 1)
          ));
      else {
        (a = "{"), (u = "}");
        const p = Object.entries(e).filter(([m, g]) => g !== void 0);
        i = p.map(([m, g], v) => {
          const $ = `${JSON.stringify(m)}: `;
          return (
            $ +
            this.stringifyImpl(g, l, $.length + (v === p.length - 1 ? 0 : 1))
          );
        });
      }
      if (i.length > 0)
        return [a, this.indent + i.join("\n".join([`,`, `${l}`])), u].join(
          "\n".join([``, `${n}`])
        );
    }
    return o;
  }
}
const iC = { class: "SudokuPadForm" },
  aC = { key: 1, class: "solutionInfoBlock" },
  uC = { key: 2, class: "jsonOverrideInput" },
  cC = { key: 0, class: "error" },
  dC = S({
    __name: "SudokuPadForm",
    props: { project: {} },
    setup(t) {
      const e = t,
        { hasCandidateMarkings: n, hasColorMarkings: s } = Hi(e.project),
        o = j(""),
        r = j(),
        l = b(() => {
          if (!r.value) return "";
          try {
            return JSON.parse(r.value), "";
          } catch (x) {
            return x.message;
          }
        }),
        i = sC(r, Ye),
        a = b(() =>
          e.project.cells.some((x) => x.value !== void 0 && !x.given)
        ),
        u = b(() => e.project.cells.every((x) => x.value !== void 0)),
        p = b(() => {
          switch (e.project.exportSettings.sudokuPad.solution.type) {
            case "none":
              return;
            case "grid":
              return !u.value &&
                !e.project.exportSettings.sudokuPad.useIncompleteGridAsSolution
                ? void 0
                : e.project.cells.map((x) => x.value);
            case "string":
              return e.project.exportSettings.sudokuPad.solution.value;
            default:
              return;
          }
        }),
        m = b(() => {
          const x = e.project.exportSettings.sudokuPad.showColorMarks,
            A = e.project.exportSettings.sudokuPad.showDigits;
          return {
            ...e.project.toPlayablePuzzleData(),
            cells: e.project.cells.map((O) => {
              const V = new rs(O.id, O.x, O.y);
              return (
                O.given
                  ? ((V.given = !0), (V.value = O.value))
                  : A &&
                    ((V.candidates =
                      O.value !== void 0 ? 1 << O.value : O.candidates),
                    (V.cornerPencilMarks = O.cornerPencilMarks)),
                x && (V.colors = O.colors),
                V
              );
            }),
          };
        }),
        g = b(() => np(m.value, p.value)),
        v = b(() => r.value !== void 0);
      async function $() {
        const x = r.value ? JSON.parse(r.value) : g.value;
        return await oi(x);
      }
      function k() {
        if (r.value === void 0) {
          const x = g.value;
          (r.value = new qi(54).stringify(x)), (o.value = r.value);
        } else {
          const x = () => {
            r.value = void 0;
          };
          r.value === o.value
            ? x()
            : ws({
                header: "Dismiss JSON changes?",
                body: "Are you sure you want to dismiss the modifications you have applied to the SudokuPad JSON?",
                callback: x,
              });
        }
      }
      function M(x) {
        (e.project.exportSettings.sudokuPad.solution = {
          type: x ? "grid" : "none",
        }),
          x &&
            (e.project.exportSettings.sudokuPad.useIncompleteGridAsSolution =
              Co.sudokuPad.useIncompleteGridAsSolution);
      }
      function P(x) {
        (e.project.exportSettings.sudokuPad.useIncompleteGridAsSolution = x),
          x &&
            (e.project.exportSettings.sudokuPad.solution = ue(
              Co.sudokuPad.solution
            ));
      }
      return (x, A) => (
        d(),
        C("div", iC, [
          c(
            be,
            { class: "wrapper", vertical: "", gap: "" },
            {
              default: f(() => [
                h("div", null, [
                  y(n)
                    ? (d(),
                      w(
                        ut,
                        { key: 0 },
                        {
                          default: f(() => [
                            c(
                              at,
                              {
                                checked:
                                  x.project.exportSettings.sudokuPad.showDigits,
                                "onUpdate:checked":
                                  A[0] ||
                                  (A[0] = (O) =>
                                    (x.project.exportSettings.sudokuPad.showDigits =
                                      O)),
                              },
                              null,
                              8,
                              ["checked"]
                            ),
                            A[4] ||
                              (A[4] = F(
                                " Show digits, candidate & corner markings "
                              )),
                          ]),
                          _: 1,
                        }
                      ))
                    : z("", !0),
                  y(s)
                    ? (d(),
                      w(
                        ut,
                        { key: 1 },
                        {
                          default: f(() => [
                            c(
                              at,
                              {
                                checked:
                                  x.project.exportSettings.sudokuPad
                                    .showColorMarks,
                                "onUpdate:checked":
                                  A[1] ||
                                  (A[1] = (O) =>
                                    (x.project.exportSettings.sudokuPad.showColorMarks =
                                      O)),
                              },
                              null,
                              8,
                              ["checked"]
                            ),
                            A[5] ||
                              (A[5] = F(
                                " Render color markings as cosmetics "
                              )),
                          ]),
                          _: 1,
                        }
                      ))
                    : z("", !0),
                ]),
                c(lt, null, {
                  default: f(
                    () =>
                      A[6] ||
                      (A[6] = [
                        h(
                          "p",
                          null,
                          " Note: Some constraints might be rendered slightly differently in SudokuPad. ",
                          -1
                        ),
                      ])
                  ),
                  _: 1,
                }),
                c(ji, { puzzle: m.value }, null, 8, ["puzzle"]),
                a.value && u.value
                  ? (d(),
                    w(
                      ut,
                      { key: 0 },
                      {
                        default: f(() => [
                          c(
                            at,
                            {
                              checked:
                                x.project.exportSettings.sudokuPad.solution
                                  .type === "grid",
                              "onUpdate:checked": M,
                            },
                            null,
                            8,
                            ["checked"]
                          ),
                          A[7] ||
                            (A[7] = F(
                              " Use currently filled-in values as the solution. "
                            )),
                        ]),
                        _: 1,
                      }
                    ))
                  : a.value && !u.value
                  ? (d(),
                    C("div", aC, [
                      c(lt, null, {
                        default: f(
                          () =>
                            A[8] ||
                            (A[8] = [
                              F(
                                " Not all cells are filled in and therefore no solution will be embedded by default in the exported puzzle. "
                              ),
                            ])
                        ),
                        _: 1,
                      }),
                      c(ut, null, {
                        default: f(() => [
                          c(
                            at,
                            {
                              checked:
                                x.project.exportSettings.sudokuPad
                                  .useIncompleteGridAsSolution,
                              "onUpdate:checked": [
                                A[2] ||
                                  (A[2] = (O) =>
                                    (x.project.exportSettings.sudokuPad.useIncompleteGridAsSolution =
                                      O)),
                                P,
                              ],
                            },
                            null,
                            8,
                            ["checked"]
                          ),
                          A[9] ||
                            (A[9] = h(
                              "span",
                              null,
                              "Use currently filled-in values as the solution anyway.",
                              -1
                            )),
                        ]),
                        _: 1,
                      }),
                    ]))
                  : z("", !0),
                c(V3, { project: x.project }, null, 8, ["project"]),
                v.value
                  ? (d(),
                    C("div", uC, [
                      c(
                        Ho,
                        {
                          modelValue: r.value,
                          "onUpdate:modelValue":
                            A[3] || (A[3] = (O) => (r.value = O)),
                          language: "json",
                        },
                        null,
                        8,
                        ["modelValue"]
                      ),
                      l.value ? (d(), C("div", cC, X(l.value), 1)) : z("", !0),
                    ]))
                  : z("", !0),
              ]),
              _: 1,
            }
          ),
          c(Ft, null, {
            default: f(() => [
              c(
                te,
                { icon: "", active: r.value !== void 0, onClick: k },
                {
                  default: f(() => [
                    c(Mo),
                    c(Te, null, {
                      default: f(() => [
                        F(X(v.value ? "Cancel editing" : "Edit JSON"), 1),
                      ]),
                      _: 1,
                    }),
                  ]),
                  _: 1,
                },
                8,
                ["active"]
              ),
              (d(),
              w(
                Ar,
                {
                  key: y(i),
                  disabled: !!l.value,
                  "get-data": $,
                  type: "url",
                  name: x.project.name,
                },
                null,
                8,
                ["disabled", "name"]
              )),
            ]),
            _: 1,
          }),
        ])
      );
    },
  }),
  pC = B(dC, [["__scopeId", "data-v-99410a6b"]]),
  fC = { components: { Icon: he } };
function hC(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "CaretLeft", viewBox: "0 0 7 10" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h("path", { d: "m5 0 2 2 -3 3 3 3-2 2-5-5 5-5Z" }, null, -1),
            ])
        ),
        _: 1,
      }
    )
  );
}
const sp = B(fC, [["render", hC]]),
  mC = { components: { Icon: he } };
function gC(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "CaretRight", viewBox: "0 0 7 10" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h("path", { d: "m2 0-2 2 3 3-3 3 2 2 5-5-5-5Z" }, null, -1),
            ])
        ),
        _: 1,
      }
    )
  );
}
const op = B(mC, [["render", gC]]);
function vC(t, e, n) {
  const s = (n == null ? void 0 : n.margin) ?? 0;
  t.offsetLeft - s < e.scrollLeft
    ? (e.scrollLeft = t.offsetLeft - s)
    : t.offsetLeft + t.offsetWidth + s > e.scrollLeft + e.clientWidth &&
      (e.scrollLeft = t.offsetLeft + t.offsetWidth + s - e.clientWidth);
}
const yC = { class: "TabStrip" },
  CC = ["onClick"],
  wC = { class: "label" },
  bC = S({
    __name: "TabStrip",
    props: { tabs: {}, activeTab: {}, compact: { type: Boolean } },
    emits: ["update:activeTab", "remove"],
    setup(t, { expose: e }) {
      const n = t,
        s = j(),
        o = j(),
        r = j({});
      ae(
        () => n.activeTab,
        (v) => {
          i(v);
        }
      );
      const l = Qr();
      function i(v) {
        if (r.value[v]) {
          const $ = 2.5 * l.rem;
          vC(r.value[v], s.value, { margin: $ });
        }
      }
      const a = j(!1),
        u = j(!1);
      function p() {
        const v = s.value;
        v &&
          (v.clientWidth < v.scrollWidth
            ? ((a.value = v.scrollLeft + v.clientWidth < v.scrollWidth - 10),
              (u.value = v.scrollLeft > 10))
            : ((a.value = !1), (u.value = !1)));
      }
      js(s, p), js(o, p), Dt(s, "scroll", p);
      function m() {
        const v = s.value;
        v.scrollTo({
          left: Math.max(0, v.scrollLeft - (v.clientWidth - 100)),
          behavior: "smooth",
        });
      }
      function g() {
        const v = s.value;
        v.scrollTo({
          left: Math.min(
            v.scrollWidth - v.clientWidth,
            v.scrollLeft + (v.clientWidth - 100)
          ),
          behavior: "smooth",
        });
      }
      return (
        e({ scrollIntoView: i }),
        (v, $) => (
          d(),
          C("div", yC, [
            h(
              "div",
              { ref_key: "scroller", ref: s, class: "scroller" },
              [
                h(
                  "div",
                  { ref_key: "content", ref: o, class: "content" },
                  [
                    (d(!0),
                    C(
                      Z,
                      null,
                      se(
                        v.tabs,
                        (k) => (
                          d(),
                          C(
                            "div",
                            {
                              key: k.id,
                              ref_for: !0,
                              ref: (M) => {
                                r.value[k.id] = M;
                              },
                              class: Ae([
                                "tab",
                                {
                                  active: v.activeTab === k.id,
                                  removable: k.removable,
                                },
                              ]),
                              onClick: (M) => v.$emit("update:activeTab", k.id),
                            },
                            [
                              h("div", wC, [
                                G(
                                  v.$slots,
                                  "default",
                                  { id: k.id, label: k.label },
                                  () => [F(X(k.label), 1)],
                                  !0
                                ),
                              ]),
                              k.removable
                                ? (d(),
                                  w(
                                    te,
                                    {
                                      key: 0,
                                      class: "removeButton",
                                      icon: "",
                                      onClick: st(
                                        (M) => v.$emit("remove", k.id),
                                        ["stop"]
                                      ),
                                    },
                                    { default: f(() => [c(Ks)]), _: 2 },
                                    1032,
                                    ["onClick"]
                                  ))
                                : z("", !0),
                            ],
                            10,
                            CC
                          )
                        )
                      ),
                      128
                    )),
                  ],
                  512
                ),
              ],
              512
            ),
            Ln(
              c(
                te,
                { class: "toLeft", icon: "", onClick: m },
                { default: f(() => [c(sp)]), _: 1 },
                512
              ),
              [[bs, u.value]]
            ),
            Ln(
              c(
                te,
                { class: "toRight", icon: "", onClick: g },
                { default: f(() => [c(op)]), _: 1 },
                512
              ),
              [[bs, a.value]]
            ),
          ])
        )
      );
    },
  }),
  ts = B(bC, [["__scopeId", "data-v-da63ce32"]]),
  kC = { key: 0 },
  _C = S({
    __name: "ExportForm",
    props: { project: {} },
    setup(t) {
      const e = [
        { id: Zn.Project, label: "Project" },
        { id: Zn.Image, label: "Image" },
        { id: Zn.SudokuPad, label: "SudokuPad" },
      ];
      return (n, s) => (
        d(),
        w(
          be,
          { class: "ExportForm", vertical: "" },
          {
            default: f(() => [
              c(
                ts,
                {
                  "active-tab": y(Ye).activeTab,
                  "onUpdate:activeTab":
                    s[0] || (s[0] = (o) => (y(Ye).activeTab = o)),
                  tabs: e,
                },
                {
                  default: f((o) => [
                    o.id === y(Zn).SudokuPad
                      ? (d(),
                        C("span", kC, [
                          s[1] ||
                            (s[1] = h(
                              "img",
                              { class: "sudokuPadLogo", src: Pd, alt: "" },
                              null,
                              -1
                            )),
                          F(" " + X(o.label), 1),
                        ]))
                      : z("", !0),
                  ]),
                  _: 1,
                },
                8,
                ["active-tab"]
              ),
              y(Ye).activeTab === y(Zn).Project
                ? (d(),
                  w(
                    B3,
                    { key: 0, project: n.project, style: { flex: "1" } },
                    null,
                    8,
                    ["project"]
                  ))
                : y(Ye).activeTab === y(Zn).Image
                ? (d(),
                  w(
                    N3,
                    { key: 1, project: n.project, style: { flex: "1" } },
                    null,
                    8,
                    ["project"]
                  ))
                : y(Ye).activeTab === y(Zn).SudokuPad
                ? (d(),
                  w(
                    pC,
                    { key: 2, project: n.project, style: { flex: "1" } },
                    null,
                    8,
                    ["project"]
                  ))
                : z("", !0),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  $C = B(_C, [["__scopeId", "data-v-48e301be"]]),
  SC = {},
  IC = { class: "QuotedSpan" };
function xC(t, e) {
  return d(), C("span", IC, [G(t.$slots, "default", {}, void 0, !0)]);
}
const DC = B(SC, [
    ["render", xC],
    ["__scopeId", "data-v-a4534b75"],
  ]),
  MC = { key: 1 },
  rl = S({
    __name: "PuzzleName",
    props: { name: {}, asWord: { type: Boolean } },
    setup(t) {
      const e = t,
        n = b(() => (e.asWord ? wr.toLowerCase() : wr));
      return (s, o) =>
        s.name
          ? (d(),
            w(DC, { key: 0 }, { default: f(() => [F(X(s.name), 1)]), _: 1 }))
          : (d(), C("span", MC, X(n.value), 1));
    },
  }),
  AC = { class: "author" },
  PC = S({
    __name: "ExportModal",
    setup(t) {
      const { project: e } = ke();
      return (n, s) => (
        d(),
        w(
          Bt,
          { class: "ExportModal", variant: "minFullscreen" },
          {
            default: f(() => [
              c(un, null, {
                default: f(() => [
                  s[0] || (s[0] = F(" Share ")),
                  c(rl, { name: y(e).name, "as-word": "" }, null, 8, ["name"]),
                  h("span", AC, "by " + X(y(e).author || "???"), 1),
                ]),
                _: 1,
              }),
              c($C, { project: y(e) }, null, 8, ["project"]),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  LC = B(PC, [["__scopeId", "data-v-5df88666"]]);
function EC(t) {
  return t.replaceAll(/,\s*([\])}])/g, (e, n) => n);
}
const FC = S({
    components: {
      CodeEditor: Ho,
      InfoBlock: lt,
      UiSpacer: Je,
      FormFooter: Ft,
      FormButton: te,
    },
    props: {
      modelValue: { type: Object, required: !0 },
      validator: { type: Function, default: () => !0 },
    },
    emits: { cancel: () => !0, "update:model-value": (t) => !0 },
    data() {
      return { dirty: "" };
    },
    computed: {
      parsedInfo() {
        const t = { value: void 0, error: "" };
        try {
          const e = JSON.parse(EC(this.dirty));
          (t.error = this.validator(e)), t.error || (t.value = e);
        } catch {
          t.error = "invalid JSON or format";
        }
        return t;
      },
    },
    watch: {
      modelValue: {
        immediate: !0,
        handler(t) {
          Ce(t, this.parsedInfo.value) ||
            (this.dirty = new qi(40).stringify(t));
        },
      },
    },
    methods: {
      cancel() {
        this.$emit("cancel");
      },
      save() {
        this.$emit("update:model-value", this.parsedInfo.value);
      },
    },
  }),
  BC = { class: "JsonEditor" };
function zC(t, e, n, s, o, r) {
  const l = H("CodeEditor"),
    i = H("InfoBlock"),
    a = H("FormButton"),
    u = H("UiSpacer"),
    p = H("FormFooter");
  return (
    d(),
    C("div", BC, [
      c(
        l,
        {
          modelValue: t.dirty,
          "onUpdate:modelValue": e[0] || (e[0] = (m) => (t.dirty = m)),
          language: "json",
        },
        null,
        8,
        ["modelValue"]
      ),
      t.parsedInfo.error
        ? (d(),
          w(
            i,
            { key: 0, type: "error" },
            {
              default: f(() => [
                F(" Invalid data: " + X(t.parsedInfo.error), 1),
              ]),
              _: 1,
            }
          ))
        : z("", !0),
      c(p, null, {
        default: f(() => [
          c(
            a,
            { onClick: t.cancel },
            { default: f(() => e[1] || (e[1] = [F(" Cancel ")])), _: 1 },
            8,
            ["onClick"]
          ),
          c(u),
          c(
            a,
            { disabled: !!t.parsedInfo.error, onClick: t.save },
            { default: f(() => e[2] || (e[2] = [F(" Save ")])), _: 1 },
            8,
            ["disabled", "onClick"]
          ),
        ]),
        _: 1,
      }),
    ])
  );
}
const RC = B(FC, [
    ["render", zC],
    ["__scopeId", "data-v-3deaa0da"],
  ]),
  OC = ["max", "min", "value"],
  NC = S({
    __name: "NumberInput",
    props: {
      value: { default: 0 },
      autofocus: { type: Boolean, default: !1 },
      max: { default: void 0 },
      min: { default: void 0 },
      compact: { type: Boolean, default: !1 },
    },
    emits: ["update:value", "change"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = j(),
        r = j("");
      ae(
        () => n.value,
        (u) => {
          r.value = u.toString();
        },
        { immediate: !0 }
      ),
        Xt(() => {
          n.autofocus && o.value.focus();
        });
      function l(u) {
        return !(
          Number.isNaN(u) ||
          !Number.isInteger(u) ||
          (n.max !== void 0 && u > n.max) ||
          (n.min !== void 0 && u < n.min)
        );
      }
      function i(u) {
        r.value = u.target.value;
        const p = Number(r.value);
        r.value === "" || !l(p) || s("update:value", p, u);
      }
      function a(u) {
        const p = u.target.value,
          m = Number(p);
        if (p === "" || !l(m)) {
          r.value = n.value.toString();
          return;
        }
        s("change", m, u);
      }
      return (u, p) => (
        d(),
        C(
          "input",
          {
            ref_key: "el",
            ref: o,
            class: Ae(["NumberInput", { compact: u.compact }]),
            type: "number",
            max: u.max,
            min: u.min,
            value: r.value,
            inputmode: "numeric",
            onInput: i,
            onChange: a,
          },
          null,
          42,
          OC
        )
      );
    },
  }),
  Ht = B(NC, [["__scopeId", "data-v-3f226985"]]),
  TC = S({
    __name: "MouseWheelScaleControls",
    props: { modelValue: {} },
    emits: ["update:model-value"],
    setup(t, { emit: e }) {
      const n = t,
        s = e;
      function o(r, l) {
        s("update:model-value", { ...n.modelValue, [r]: l });
      }
      return (r, l) => (
        d(),
        w(
          be,
          { align: "center", gap: "" },
          {
            default: f(() => [
              l[3] || (l[3] = h("span", null, "Horizontal", -1)),
              c(
                Ht,
                {
                  value: r.modelValue.x * 100,
                  style: { "min-width": "0" },
                  "onUpdate:value": l[0] || (l[0] = (i) => o("x", i / 100)),
                },
                null,
                8,
                ["value"]
              ),
              l[4] || (l[4] = h("span", null, "Vertical", -1)),
              c(
                Ht,
                {
                  value: r.modelValue.y * 100,
                  "onUpdate:value": l[1] || (l[1] = (i) => o("y", i / 100)),
                },
                null,
                8,
                ["value"]
              ),
              l[5] || (l[5] = h("span", null, "Zoom", -1)),
              c(
                Ht,
                {
                  value: r.modelValue.z * 100,
                  "onUpdate:value": l[2] || (l[2] = (i) => o("z", i / 100)),
                },
                null,
                8,
                ["value"]
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  });
function rp({ getExportPayload: t, exportName: e, onImportCallback: n }) {
  function s() {
    const o = JSON.stringify(t()),
      r = new Blob([o], { type: "application/json" });
    $d(r, e);
  }
  return () => {
    const { open: o, addEventListener: r } = Oi();
    return (
      r((l) => {
        if (l === null || l.length === 0) return;
        const i = new FileReader();
        i.readAsText(l[0]),
          i.addEventListener("load", () => {
            const a = i.result;
            let u;
            try {
              u = JSON.parse(a);
            } catch {
              Rs("Importing data failed: it is not valid JSON.");
              return;
            }
            const p = n(u);
            p !== !0 && Rs(p);
          });
      }),
      { exportData: s, importData: o }
    );
  };
}
const VC = rp({
    exportName: "Sudoku Maker - Data.json",
    getExportPayload: () => ({
      warning: "Do not edit this file!",
      localStorage,
    }),
    onImportCallback: (t) => {
      try {
        const e = t.localStorage;
        for (const [n, s] of Object.entries(e))
          n === dc
            ? En.merge(JSON.parse(s).entries)
            : localStorage.setItem(n, s);
        return Th(), !0;
      } catch {
        return "Invalid data.";
      }
    },
  }),
  jC = ["id", "checked"],
  UC = { class: "base" },
  HC = S({
    __name: "BooleanSwitch",
    props: { id: {}, checked: { type: Boolean }, disabled: { type: Boolean } },
    emits: ["update:checked"],
    setup(t, { emit: e }) {
      const n = e,
        s = j();
      function o(r) {
        n("update:checked", r.target.checked);
      }
      return (r, l) => (
        d(),
        C(
          "span",
          { class: Ae(["BooleanSwitch", { checked: r.checked }]) },
          [
            h(
              "input",
              {
                id: r.id,
                ref_key: "checkbox",
                ref: s,
                type: "checkbox",
                checked: r.checked,
                onChange: o,
              },
              null,
              40,
              jC
            ),
            h("span", UC, [c(Dd)]),
            l[0] || (l[0] = h("span", { class: "thumb" }, null, -1)),
          ],
          2
        )
      );
    },
  }),
  Ao = B(HC, [["__scopeId", "data-v-ad7c65d0"]]);
function WC(t) {
  const e = window.matchMedia(t),
    n = j(e.matches);
  function s(o) {
    n.value = o.matches;
  }
  return (
    e.addEventListener("change", s, { passive: !0 }),
    zo(() => {
      e.removeEventListener("change", s);
    }, !0),
    b(() => n.value)
  );
}
function lp() {
  return WC("(display-mode: standalone)");
}
const ZC = { components: { Icon: he } };
function GC(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "Debug", viewBox: "0 0 16 16" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "m1.5 4.5 2.94 1.85M1 9h3m-2.5 4.51 2.68-1.94M14.5 4.5l-2.94 1.85M15 9h-3m2.5 4.5-2.69-1.93M5.75 5.08A2.51 2.51 0 0 1 8.03 1.5a2.51 2.51 0 0 1 2.25 3.62",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M8 4.89c2.48 0 3.78 1.68 4 4.44.22 2.75-1.52 5.17-4 5.17s-4.14-2.41-4-5.17C4.14 6.52 5.52 4.9 8 4.9Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const ip = B(ZC, [
    ["render", GC],
    ["__scopeId", "data-v-d1b8d73f"],
  ]),
  qC = { class: "AdvancedPanel" },
  KC = { style: { display: "flex", "align-items": "center", gap: "0.5rem" } },
  XC = S({
    __name: "AdvancedPanel",
    setup(t) {
      const e = lp(),
        n = j(!1),
        s = j(!1),
        o = b(() => Ce(ee, qn));
      function r() {
        s.value ? (l(), (s.value = !1)) : (s.value = !0);
      }
      function l() {
        Object.assign(ee, ue(qn));
      }
      function i(m) {
        Object.assign(ee, ue(m)), (n.value = !1);
      }
      function a(m) {
        if (!m || typeof m != "object") return "invalid format";
        for (const g in qn) {
          if (!(g in m)) return `missing property ${g}`;
          const v = qn[g],
            $ = m[g];
          if (typeof v != typeof $ || Array.isArray(v) !== Array.isArray($))
            return `unsupported value for ${g}`;
        }
        return "";
      }
      const { importData: u, exportData: p } = VC();
      return (m, g) => (
        d(),
        C("div", qC, [
          c(
            be,
            { vertical: "", gap: "" },
            {
              default: f(() => [
                c(
                  ve,
                  { vertical: "" },
                  {
                    label: f(() => [
                      g[5] || (g[5] = F(" Scroll wheel and touchpad scaling ")),
                      c(dt, null, {
                        default: f(
                          () =>
                            g[4] ||
                            (g[4] = [
                              F(
                                " If you are using a scroll wheel or a touchpad to zoom and/or pan the puzzle, and the movement feels not right, try changing these values. Larger values mean faster panning and/or zooming. "
                              ),
                              h("br", null, null, -1),
                              h("br", null, null, -1),
                              F(
                                " You can also turn off these controls by setting the value to 0, and flip the directions by making the values negative. "
                              ),
                            ])
                        ),
                        _: 1,
                      }),
                    ]),
                    default: f(() => [
                      c(
                        TC,
                        {
                          modelValue: y(ee).mouseWheelScale,
                          "onUpdate:modelValue":
                            g[0] || (g[0] = (v) => (y(ee).mouseWheelScale = v)),
                        },
                        null,
                        8,
                        ["modelValue"]
                      ),
                    ]),
                    _: 1,
                  }
                ),
                c(
                  ve,
                  { clickable: "" },
                  {
                    label: f(() => [
                      h("div", KC, [
                        c(ip, { style: { height: "1em" } }),
                        g[6] ||
                          (g[6] = h("span", null, "Enable advanced tools", -1)),
                      ]),
                    ]),
                    default: f(({ controlId: v }) => [
                      c(
                        Ao,
                        {
                          id: v,
                          checked: y(ee).debug,
                          "onUpdate:checked":
                            g[1] || (g[1] = ($) => (y(ee).debug = $)),
                        },
                        null,
                        8,
                        ["id", "checked"]
                      ),
                    ]),
                    _: 1,
                  }
                ),
                g[12] ||
                  (g[12] = h(
                    "div",
                    null,
                    [
                      F(" Advanced tools include: "),
                      h("ul", null, [
                        h(
                          "li",
                          null,
                          "constraint component visualizer (desktop only)"
                        ),
                        h("li", null, "puzzle element data editing"),
                      ]),
                    ],
                    -1
                  )),
                g[13] || (g[13] = h("hr", null, null, -1)),
                c(
                  te,
                  {
                    class: "resetButton",
                    onClick: g[2] || (g[2] = (v) => (n.value = !0)),
                  },
                  {
                    default: f(
                      () => g[7] || (g[7] = [F(" Edit preferences as JSON ")])
                    ),
                    _: 1,
                  }
                ),
                c(
                  te,
                  {
                    class: "resetButton",
                    disabled: o.value,
                    variant: s.value ? "danger" : "default",
                    onClick: r,
                  },
                  {
                    default: f(() => [
                      F(
                        X(
                          s.value
                            ? "Are you sure? Click to confirm"
                            : "Reset all preferences to defaults"
                        ),
                        1
                      ),
                    ]),
                    _: 1,
                  },
                  8,
                  ["disabled", "variant"]
                ),
                g[14] || (g[14] = h("hr", null, null, -1)),
                g[15] ||
                  (g[15] = h(
                    "p",
                    null,
                    "Moving from one device/app/browser to another?",
                    -1
                  )),
                c(Yt, null, {
                  default: f(() => [
                    c(
                      te,
                      { class: "resetButton", onClick: y(p) },
                      {
                        default: f(
                          () => g[8] || (g[8] = [F(" Export local data ")])
                        ),
                        _: 1,
                      },
                      8,
                      ["onClick"]
                    ),
                    c(
                      te,
                      { class: "resetButton", onClick: y(u) },
                      {
                        default: f(
                          () => g[9] || (g[9] = [F(" Import local data* ")])
                        ),
                        _: 1,
                      },
                      8,
                      ["onClick"]
                    ),
                  ]),
                  _: 1,
                }),
                h("p", null, [
                  g[10] || (g[10] = F(" * ")),
                  y(e)
                    ? z("", !0)
                    : (d(),
                      C(
                        Z,
                        { key: 0 },
                        [
                          F(
                            " It is also highly recommended to only have a single tab open when you do this. "
                          ),
                        ],
                        64
                      )),
                  g[11] ||
                    (g[11] = F(" After importing, the app will be reloaded. ")),
                ]),
              ]),
              _: 1,
            }
          ),
          n.value
            ? (d(),
              w(
                RC,
                {
                  key: 0,
                  "model-value": y(ee),
                  validator: a,
                  "onUpdate:modelValue": i,
                  onCancel: g[3] || (g[3] = (v) => (n.value = !1)),
                },
                null,
                8,
                ["model-value"]
              ))
            : z("", !0),
        ])
      );
    },
  }),
  YC = B(XC, [["__scopeId", "data-v-6087c93b"]]),
  JC = S({
    __name: "PaletteButton",
    props: { colors: {} },
    setup(t) {
      const e = t,
        n = b(() => bi(e.colors, 9));
      return (s, o) => (
        d(),
        w(
          te,
          { class: "PaletteButton" },
          {
            default: f(() => [
              (d(!0),
              C(
                Z,
                null,
                se(
                  n.value,
                  (r, l) => (
                    d(), w(Uc, { key: l, colors: r }, null, 8, ["colors"])
                  )
                ),
                128
              )),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  QC = B(JC, [["__scopeId", "data-v-da529adf"]]),
  Ki = S({
    props: {
      rgb: { type: Object, required: !0 },
      modelValue: { type: Number, required: !0 },
    },
    emits: { "update:modelValue": (t) => !0 },
    data() {
      return { dragging: !1 };
    },
    computed: {
      startColor() {
        return Us(this.rgb);
      },
      handlePosition() {
        return `${(1 - this.modelValue) * 100}%`;
      },
    },
    mounted() {
      document.addEventListener("pointermove", this.onPointerMove, !1),
        document.addEventListener("pointerup", this.onPointerUp, !1);
    },
    beforeUnmount() {
      document.removeEventListener("pointermove", this.onPointerMove, !1),
        document.removeEventListener("pointerup", this.onPointerUp, !1);
    },
    methods: {
      update(t) {
        const e = this.$el.getBoundingClientRect();
        this.$emit(
          "update:modelValue",
          Rt(1 - (t.clientX - e.left) / e.width, 0, 1)
        );
      },
      onPointerDown(t) {
        this.update(t), (this.dragging = !0);
      },
      onPointerMove(t) {
        this.dragging && this.update(t);
      },
      onPointerUp() {
        this.dragging = !1;
      },
    },
  }),
  Iu = () => {
    zn((t) => ({ "9b569fda": t.startColor, "108f4263": t.handlePosition }));
  },
  xu = Ki.setup;
Ki.setup = xu ? (t, e) => (Iu(), xu(t, e)) : Iu;
function e4(t, e, n, s, o, r) {
  return (
    d(),
    C(
      "div",
      {
        class: "AlphaPicker",
        onPointerdown:
          e[0] || (e[0] = (...l) => t.onPointerDown && t.onPointerDown(...l)),
      },
      e[1] ||
        (e[1] = [
          h("div", { class: "checkerBoard" }, null, -1),
          h("div", { class: "gradient" }, null, -1),
          h("div", { class: "handle" }, null, -1),
        ]),
      32
    )
  );
}
const t4 = B(Ki, [
    ["render", e4],
    ["__scopeId", "data-v-aa316620"],
  ]),
  Xi = S({
    props: { modelValue: { type: Object, required: !0 } },
    emits: { "update:modelValue": (t) => !0 },
    data() {
      return { dragging: !1 };
    },
    computed: {
      gradient() {
        return "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)";
      },
      handlePosition() {
        return `${this.modelValue.hue * 100}%`;
      },
    },
    mounted() {
      document.addEventListener("pointermove", this.onPointerMove, !1),
        document.addEventListener("pointerup", this.onPointerUp, !1);
    },
    beforeUnmount() {
      document.removeEventListener("pointermove", this.onPointerMove, !1),
        document.removeEventListener("pointerup", this.onPointerUp, !1);
    },
    methods: {
      update(t) {
        const e = this.$el.getBoundingClientRect();
        this.$emit("update:modelValue", {
          hue: Rt((t.clientX - e.left) / e.width, 0, 1),
          saturation: this.modelValue.saturation,
          lightness: this.modelValue.lightness,
          alpha: this.modelValue.alpha,
        });
      },
      onPointerDown(t) {
        this.update(t), (this.dragging = !0);
      },
      onPointerMove(t) {
        this.dragging && this.update(t);
      },
      onPointerUp() {
        this.dragging = !1;
      },
    },
  }),
  Du = () => {
    zn((t) => ({ "050cae90": t.gradient, "2b3872d1": t.handlePosition }));
  },
  Mu = Xi.setup;
Xi.setup = Mu ? (t, e) => (Du(), Mu(t, e)) : Du;
function n4(t, e, n, s, o, r) {
  return (
    d(),
    C(
      "div",
      {
        class: "HuePicker",
        onPointerdown:
          e[0] || (e[0] = (...l) => t.onPointerDown && t.onPointerDown(...l)),
      },
      e[1] ||
        (e[1] = [
          h("div", { class: "canvas" }, null, -1),
          h("div", { class: "handle" }, null, -1),
        ]),
      32
    )
  );
}
const s4 = B(Xi, [
    ["render", n4],
    ["__scopeId", "data-v-b5848696"],
  ]),
  Yi = S({
    props: { modelValue: { type: Object, required: !0 } },
    emits: { "update:modelValue": (t) => !0 },
    data() {
      return { dragging: !1 };
    },
    computed: {
      gradientColor() {
        return `hsl(${this.modelValue.hue * 360}, 100%, 50%)`;
      },
      handlePosition() {
        return {
          x: `${this.modelValue.saturation * 100}%`,
          y: `${(1 - this.modelValue.lightness) * 100}%`,
        };
      },
    },
    mounted() {
      document.addEventListener("pointermove", this.onPointerMove, !1),
        document.addEventListener("pointerup", this.onPointerUp, !1);
    },
    beforeUnmount() {
      document.removeEventListener("pointermove", this.onPointerMove, !1),
        document.removeEventListener("pointerup", this.onPointerUp, !1);
    },
    methods: {
      update(t) {
        const e = this.$el.getBoundingClientRect();
        this.$emit("update:modelValue", {
          hue: this.modelValue.hue,
          saturation: Rt((t.clientX - e.left) / e.width, 0, 1),
          lightness: Rt(1 - (t.clientY - e.top) / e.height, 0, 1),
          alpha: this.modelValue.alpha,
        });
      },
      onPointerDown(t) {
        this.update(t), (this.dragging = !0);
      },
      onPointerMove(t) {
        this.dragging && this.update(t);
      },
      onPointerUp() {
        this.dragging = !1;
      },
    },
  }),
  Au = () => {
    zn((t) => ({
      "241a13f2": t.gradientColor,
      "744322fc": t.handlePosition.x,
      "744322fd": t.handlePosition.y,
    }));
  },
  Pu = Yi.setup;
Yi.setup = Pu ? (t, e) => (Au(), Pu(t, e)) : Au;
function o4(t, e, n, s, o, r) {
  return (
    d(),
    C(
      "div",
      {
        class: "SaturationLightnessPicker",
        onPointerdown:
          e[0] || (e[0] = (...l) => t.onPointerDown && t.onPointerDown(...l)),
      },
      e[1] ||
        (e[1] = [
          h("div", { class: "gradient" }, null, -1),
          h("div", { class: "hueHandle" }, null, -1),
        ]),
      32
    )
  );
}
const r4 = B(Yi, [
    ["render", o4],
    ["__scopeId", "data-v-ee36e294"],
  ]),
  l4 = { class: "ColorPickerPopover" },
  i4 = { class: "main" },
  a4 = { key: 0, class: "alphaRow" },
  u4 = { class: "inputRow" },
  c4 = S({
    __name: "ColorPickerPopover",
    props: {
      target: {},
      modelValue: {},
      includeAlpha: { type: Boolean, default: !1 },
      removable: { type: Boolean },
    },
    emits: ["close", "update:modelValue", "remove"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = j({ hue: 0, saturation: 0, lightness: 0, alpha: 1 }),
        r = j("#000000");
      function l(u) {
        r.value = u;
        const p = Gt(u);
        if (!p) return;
        const m = Cl(p);
        Ce(m, o.value) || (o.value = m);
      }
      const i = b(() => Gr(o.value)),
        a = b(() => Hs(C0(o.value)));
      return (
        ae(
          () => n.modelValue,
          (u) => {
            if (n.includeAlpha) {
              const p = Gt(u);
              if (!p) return;
              mr(n.modelValue, r.value) || (r.value = n.modelValue),
                (o.value = Cl(p));
            } else {
              const p = Fl(u);
              if (!p) return;
              mr(n.modelValue, r.value) || (r.value = n.modelValue),
                (o.value = Cl({ ...p, alpha: 1 }));
            }
          },
          { immediate: !0 }
        ),
        ae(
          a,
          () => {
            mr(a.value, n.modelValue) || s("update:modelValue", a.value);
          },
          { immediate: !0 }
        ),
        (u, p) => (
          d(),
          w(
            el,
            {
              target: u.target,
              align: "center",
              onClose: p[4] || (p[4] = (m) => u.$emit("close")),
            },
            {
              default: f(() => [
                h("div", l4, [
                  h("div", i4, [
                    c(
                      s4,
                      {
                        modelValue: o.value,
                        "onUpdate:modelValue":
                          p[0] || (p[0] = (m) => (o.value = m)),
                        class: "slider",
                      },
                      null,
                      8,
                      ["modelValue"]
                    ),
                    c(
                      r4,
                      {
                        modelValue: o.value,
                        "onUpdate:modelValue":
                          p[1] || (p[1] = (m) => (o.value = m)),
                        class: "xySlider",
                      },
                      null,
                      8,
                      ["modelValue"]
                    ),
                    u.includeAlpha
                      ? (d(),
                        C("div", a4, [
                          p[5] || (p[5] = F(" Alpha: ")),
                          c(
                            t4,
                            {
                              modelValue: o.value.alpha,
                              "onUpdate:modelValue":
                                p[2] || (p[2] = (m) => (o.value.alpha = m)),
                              rgb: i.value,
                            },
                            null,
                            8,
                            ["modelValue", "rgb"]
                          ),
                        ]))
                      : z("", !0),
                    h("div", u4, [
                      p[6] || (p[6] = F(" Hex value: ")),
                      c(vt, { value: r.value, "onUpdate:value": l }, null, 8, [
                        "value",
                      ]),
                    ]),
                  ]),
                  u.removable
                    ? (d(),
                      w(Jr, {
                        key: 0,
                        onClick: p[3] || (p[3] = (m) => u.$emit("remove")),
                      }))
                    : z("", !0),
                ]),
              ]),
              _: 1,
            },
            8,
            ["target"]
          )
        )
      );
    },
  }),
  d4 = B(c4, [["__scopeId", "data-v-414b6b96"]]),
  p4 = { class: "ColorPicker" },
  f4 = S({
    __name: "ColorPicker",
    props: {
      modelValue: {},
      includeAlpha: { type: Boolean },
      removable: { type: Boolean },
    },
    emits: ["update:modelValue", "remove"],
    setup(t, { expose: e }) {
      zn((o) => ({ "4ed8f80c": o.modelValue }));
      const n = j(!1);
      function s() {
        n.value = !0;
      }
      return (
        e({ open: s }),
        (o, r) => (
          d(),
          C("div", p4, [
            h("div", { class: "preview", onClick: s }),
            c(
              Oe,
              {
                modal: n.value,
                onBackdropClick: r[3] || (r[3] = (l) => (n.value = !1)),
              },
              {
                default: f(({ target: l }) => [
                  n.value
                    ? (d(),
                      w(
                        d4,
                        {
                          key: 0,
                          "model-value": o.modelValue,
                          target: l,
                          "include-alpha": o.includeAlpha,
                          removable: o.removable,
                          "onUpdate:modelValue":
                            r[0] ||
                            (r[0] = (i) => o.$emit("update:modelValue", i)),
                          onRemove: r[1] || (r[1] = (i) => o.$emit("remove")),
                          onClose: r[2] || (r[2] = (i) => (n.value = !1)),
                        },
                        null,
                        8,
                        ["model-value", "target", "include-alpha", "removable"]
                      ))
                    : z("", !0),
                ]),
                _: 1,
              },
              8,
              ["modal"]
            ),
          ])
        )
      );
    },
  }),
  yo = B(f4, [["__scopeId", "data-v-569e6aa7"]]),
  h4 = S({
    __name: "PaletteEditor",
    props: { colors: {} },
    emits: ["update:colors"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = j(0),
        r = j(),
        l = b(() => bi(n.colors, 9));
      function i(p, m) {
        const g = n.colors.slice();
        (g[p] = m), s("update:colors", g);
      }
      function a(p) {
        const m = [...n.colors];
        m.splice(p, 1), s("update:colors", m), o.value++;
      }
      function u() {
        const p = Us(
            Gr({
              hue: Math.random(),
              saturation: 0.8 - Math.random() * 0.5,
              lightness: 0.5 + Math.random() * 0.2,
            })
          ),
          m = [...n.colors];
        m.push(p),
          s("update:colors", m),
          wn(() => {
            r.value && (r.value.scrollLeft = 1e3);
          });
      }
      return (p, m) => (
        d(),
        C(
          "div",
          { ref_key: "container", ref: r, class: "PaletteEditor" },
          [
            (d(!0),
            C(
              Z,
              null,
              se(
                l.value,
                (g, v) => (
                  d(),
                  C("div", { key: v, class: "grid" }, [
                    (d(!0),
                    C(
                      Z,
                      null,
                      se(
                        g,
                        ($, k) => (
                          d(),
                          w(
                            yo,
                            {
                              key: `${k}_${o.value}`,
                              "model-value": $,
                              removable: "",
                              "onUpdate:modelValue": (M) => i(v * 9 + k, M),
                              onRemove: (M) => a(v * 9 + k),
                            },
                            null,
                            8,
                            ["model-value", "onUpdate:modelValue", "onRemove"]
                          )
                        )
                      ),
                      128
                    )),
                    p.colors.length < 27 &&
                    p.colors.length % 9 !== 0 &&
                    v === l.value.length - 1
                      ? (d(),
                        w(
                          te,
                          { key: 0, class: "addButton", icon: "", onClick: u },
                          { default: f(() => [c(es)]), _: 1 }
                        ))
                      : z("", !0),
                  ])
                )
              ),
              128
            )),
            p.colors.length < 27 && p.colors.length % 9 === 0
              ? (d(),
                w(
                  te,
                  { key: 0, class: "addButton", icon: "", onClick: u },
                  { default: f(() => [c(es)]), _: 1 }
                ))
              : z("", !0),
          ],
          512
        )
      );
    },
  }),
  m4 = B(h4, [["__scopeId", "data-v-d0b30040"]]),
  ap = Symbol("theming"),
  g4 = {
    install(t) {
      const e = rn({ themeName: "" });
      function n() {
        const r = getComputedStyle(document.documentElement);
        e.themeName = r.getPropertyValue("--themeName");
      }
      window
        .matchMedia("prefers-color-scheme: dark")
        .addEventListener("change", n),
        new MutationObserver(n).observe(document.documentElement, {
          attributes: !0,
          attributeFilter: ["class"],
        }),
        n(),
        t.provide(ap, e);
    },
  };
function up() {
  const t = Qe(ap);
  if (!t) throw new Error("Theme provider is missing.");
  return { isDarkMode: b(() => t.themeName === "dark") };
}
const v4 = { class: "DisplayPanel" },
  y4 = { class: "main" },
  C4 = { class: "previewWrapper" },
  w4 = S({
    __name: "DisplayPanel",
    setup(t) {
      const e = j(!1),
        n = j([]);
      function s(i) {
        var a;
        (a = n.value[i]) == null || a.open();
      }
      const o = up(),
        r = b(() => o.isDarkMode.value && ee.invertColorsInDarkMode),
        l = b(() => {
          const i = ln.createDefault(jo());
          return (
            i.allConstraints.push(ks({ type: _.Regions, spec: i.spec })),
            (i.cells[0].value = 1),
            (i.cells[1].value = 2),
            (i.cells[2].value = 4),
            (i.cells[3].candidates = 10),
            (i.cells[4].candidates = 238),
            (i.cells[5].candidates = 1022),
            (i.cells[22].candidates = 830),
            (i.cells[23].candidates = 254),
            (i.cells[9].cornerPencilMarks = 8),
            (i.cells[9].cornerPencilMarks = 10),
            (i.cells[10].cornerPencilMarks = 510),
            (i.cells[20].cornerPencilMarks = 398),
            (i.cells[11].colors = 2),
            (i.cells[12].colors = 6),
            (i.cells[13].colors = 4),
            (i.cells[14].colors = 8),
            (i.cells[15].colors = 16),
            (i.cells[18].colors = 17),
            (i.cells[19].colors = 35),
            (i.cells[20].colors = 71),
            (i.cells[21].colors = 143),
            (i.cells[22].colors = 286),
            (i.cells[23].colors = 910),
            (i.cells[27].colors = 17408),
            (i.cells[28].colors = 35840),
            (i.cells[29].colors = 72704),
            (i.cells[30].colors = 146432),
            (i.cells[31].colors = 292864),
            (i.cells[32].colors = 522240),
            {
              sudoku: i,
              selection: new Set([0, 1, 9, 10, 11, 23]),
              highlight: [2, 11, 20, 29],
            }
          );
        });
      return (i, a) => (
        d(),
        C("div", v4, [
          h("div", y4, [
            c(
              be,
              { vertical: "", gap: "" },
              {
                default: f(() => [
                  c(
                    ve,
                    {
                      label: "Display candidates over multiple lines",
                      clickable: "",
                    },
                    {
                      default: f(({ controlId: u }) => [
                        c(
                          Ao,
                          {
                            id: u,
                            checked: y(ee).multilineCandidates,
                            "onUpdate:checked":
                              a[0] ||
                              (a[0] = (p) => (y(ee).multilineCandidates = p)),
                          },
                          null,
                          8,
                          ["id", "checked"]
                        ),
                      ]),
                      _: 1,
                    }
                  ),
                  c(
                    ve,
                    {
                      label: "Marking colors:",
                      clickable: "",
                      vertical: e.value,
                      class: "colorRow",
                      onLabelClick: a[3] || (a[3] = (u) => (e.value = !0)),
                    },
                    {
                      default: f(() => [
                        e.value
                          ? (d(),
                            w(
                              m4,
                              {
                                key: 1,
                                colors: y(ee).markColors,
                                "onUpdate:colors":
                                  a[2] ||
                                  (a[2] = (u) => (y(ee).markColors = u)),
                              },
                              null,
                              8,
                              ["colors"]
                            ))
                          : (d(),
                            w(
                              QC,
                              {
                                key: 0,
                                colors: y(ee).markColors,
                                onClick: a[1] || (a[1] = (u) => (e.value = !0)),
                              },
                              null,
                              8,
                              ["colors"]
                            )),
                      ]),
                      _: 1,
                    },
                    8,
                    ["vertical"]
                  ),
                  c(
                    ve,
                    {
                      label: "Non-given value color:",
                      clickable: "",
                      class: "colorRow",
                      onLabelClick: a[5] || (a[5] = (u) => s(0)),
                    },
                    {
                      default: f(() => [
                        c(
                          yo,
                          {
                            ref: (u) => {
                              n.value[0] = u;
                            },
                            modelValue: y(ee).nonGivenColor,
                            "onUpdate:modelValue":
                              a[4] || (a[4] = (u) => (y(ee).nonGivenColor = u)),
                          },
                          null,
                          8,
                          ["modelValue"]
                        ),
                      ]),
                      _: 1,
                    }
                  ),
                  c(
                    ve,
                    {
                      label: "Selection color:",
                      clickable: "",
                      class: "colorRow",
                      onLabelClick: a[7] || (a[7] = (u) => s(2)),
                    },
                    {
                      default: f(() => [
                        c(
                          yo,
                          {
                            ref: (u) => {
                              n.value[1] = u;
                            },
                            modelValue: y(ee).selectionColor,
                            "onUpdate:modelValue":
                              a[6] ||
                              (a[6] = (u) => (y(ee).selectionColor = u)),
                            "include-alpha": "",
                          },
                          null,
                          8,
                          ["modelValue"]
                        ),
                      ]),
                      _: 1,
                    }
                  ),
                  c(
                    ve,
                    {
                      label: "Step highlight color:",
                      clickable: "",
                      class: "colorRow",
                      onLabelClick: a[9] || (a[9] = (u) => s(3)),
                    },
                    {
                      default: f(() => [
                        c(
                          yo,
                          {
                            ref: (u) => {
                              n.value[2] = u;
                            },
                            modelValue: y(ee).highlightColor,
                            "onUpdate:modelValue":
                              a[8] ||
                              (a[8] = (u) => (y(ee).highlightColor = u)),
                            "include-alpha": "",
                          },
                          null,
                          8,
                          ["modelValue"]
                        ),
                      ]),
                      _: 1,
                    }
                  ),
                  c(
                    ve,
                    { clickable: "" },
                    {
                      label: f(() => [
                        c(Sd),
                        a[11] ||
                          (a[11] = F(" Adapt colors when using dark theme ")),
                      ]),
                      default: f(({ controlId: u }) => [
                        c(
                          Ao,
                          {
                            id: u,
                            checked: y(ee).invertColorsInDarkMode,
                            "onUpdate:checked":
                              a[10] ||
                              (a[10] = (p) =>
                                (y(ee).invertColorsInDarkMode = p)),
                          },
                          null,
                          8,
                          ["id", "checked"]
                        ),
                      ]),
                      _: 1,
                    }
                  ),
                ]),
                _: 1,
              }
            ),
          ]),
          h("div", C4, [
            c(
              Xs,
              {
                class: "preview",
                spec: l.value.sudoku.spec,
                cells: l.value.sudoku.cells,
                constraints: l.value.sudoku.allConstraints,
                highlight: l.value.highlight,
                readonly: "",
                "dark-mode-style": r.value,
              },
              {
                background: f(() => [
                  c(
                    Zo,
                    {
                      selection: l.value.selection,
                      color: y(ee).selectionColor,
                    },
                    null,
                    8,
                    ["selection", "color"]
                  ),
                ]),
                _: 1,
              },
              8,
              ["spec", "cells", "constraints", "highlight", "dark-mode-style"]
            ),
          ]),
        ])
      );
    },
  }),
  b4 = B(w4, [["__scopeId", "data-v-29ac4afd"]]),
  k4 = { class: "ExportingPanel" },
  _4 = { style: { flex: "1" } },
  $4 = { class: "fileNameInput" },
  S4 = S({
    __name: "ExportingPanel",
    setup(t) {
      const e = ["author", "name", "date", "time"]
        .map((n) => `<${n}>`)
        .join(" ");
      return (n, s) => (
        d(),
        C("div", k4, [
          c(
            be,
            { vertical: "", gap: "" },
            {
              default: f(() => [
                c(
                  ve,
                  { label: "Default author name:", vertical: "" },
                  {
                    default: f(() => [
                      c(
                        vt,
                        {
                          value: y(ee).defaultAuthorName,
                          "onUpdate:value":
                            s[0] ||
                            (s[0] = (o) => (y(ee).defaultAuthorName = o)),
                        },
                        null,
                        8,
                        ["value"]
                      ),
                    ]),
                    _: 1,
                  }
                ),
                c(
                  ve,
                  { vertical: "", clickable: "", "top-align-label": "" },
                  {
                    label: f(
                      () => s[2] || (s[2] = [F(" Download filename format: ")])
                    ),
                    default: f(({ controlId: o }) => [
                      h("div", _4, [
                        h("div", $4, [
                          c(
                            vt,
                            {
                              id: o,
                              value: y(ee).fileNameFormat,
                              "onUpdate:value":
                                s[1] ||
                                (s[1] = (r) => (y(ee).fileNameFormat = r)),
                              style: { width: "100%" },
                            },
                            null,
                            8,
                            ["id", "value"]
                          ),
                          s[3] ||
                            (s[3] = h(
                              "span",
                              { class: "extension" },
                              ".{extension}",
                              -1
                            )),
                        ]),
                        h(
                          "small",
                          null,
                          " Available placeholders: " + X(y(e)),
                          1
                        ),
                      ]),
                    ]),
                    _: 1,
                  }
                ),
              ]),
              _: 1,
            }
          ),
        ])
      );
    },
  }),
  I4 = B(S4, [["__scopeId", "data-v-54780d35"]]);
function x4(t, e, n) {
  let s;
  try {
    s = JSON.parse(n.getItem(t)) || e;
  } catch {
    s = e;
  }
  return y1((o, r) => ({
    get() {
      return o(), s;
    },
    set(l) {
      n.setItem(t, JSON.stringify(l)), (s = l), r();
    },
  }));
}
function ll(t, e) {
  return x4(t, e, localStorage);
}
const D4 = {
  undo: "Undo",
  redo: "Redo",
  selectAll: "Select all",
  delete: "Delete",
  setEnterDigits: "Set digits",
  setEnterCornerPencilMarks: "Set corner pencil marks",
  setEnterCandidates: "Set candidates",
  setEnterColorMarks: "Set color marks",
  newConstraint: "Add new constraint",
  openNextConstraint: "Open next constraint",
  openPreviousConstraint: "Open previous constraint",
  removeConstraint: "Remove selected constraint",
  exitConstraintEditor: "Stop editing constraint",
  clearGrid: "Clear all (non-given) digits and markings",
  doSingleLogicalStep: "Do a single logical step",
  doAllLogicalSteps: "Solve step-by-step, logically",
  findSolutions: "Find all solutions and valid candidates",
  checkValidity: "Check for validity and uniqueness",
  stopSolver: "Stop solving",
  toggleFog: "Toggle fog",
};
function gs(t) {
  return D4[t] || t;
}
const il = new Map([
    ["Backquote", "`"],
    ["Backslash", "\\"],
    ["BracketLeft", "["],
    ["BracketRight", "]"],
    ["Comma", ","],
    ["Digit0", "0"],
    ["Digit1", "1"],
    ["Digit2", "2"],
    ["Digit3", "3"],
    ["Digit4", "4"],
    ["Digit5", "5"],
    ["Digit6", "6"],
    ["Digit7", "7"],
    ["Digit8", "8"],
    ["Digit9", "9"],
    ["Equal", "="],
    ["IntlBackslash", "\\"],
    ["KeyA", "A"],
    ["KeyB", "B"],
    ["KeyC", "C"],
    ["KeyD", "D"],
    ["KeyE", "E"],
    ["KeyF", "F"],
    ["KeyG", "G"],
    ["KeyH", "H"],
    ["KeyI", "I"],
    ["KeyJ", "J"],
    ["KeyK", "K"],
    ["KeyL", "L"],
    ["KeyM", "M"],
    ["KeyN", "N"],
    ["KeyO", "O"],
    ["KeyP", "P"],
    ["KeyQ", "Q"],
    ["KeyR", "R"],
    ["KeyS", "S"],
    ["KeyT", "T"],
    ["KeyU", "U"],
    ["KeyV", "V"],
    ["KeyW", "W"],
    ["KeyX", "X"],
    ["KeyY", "Y"],
    ["KeyZ", "Z"],
    ["Minus", "-"],
    ["Period", "."],
    ["Quote", "'"],
    ["Semicolon", ";"],
    ["Slash", "/"],
  ]),
  M4 = [...il.keys()],
  Ko = ys(il);
var tc;
(tc = navigator.keyboard) == null ||
  tc.getLayoutMap().then((t) => {
    Ko.value = t;
  });
async function A4() {
  var t;
  Ko.value =
    (await ((t = navigator.keyboard) == null ? void 0 : t.getLayoutMap())) ||
    il;
}
function P4(t) {
  switch (t) {
    case "Escape":
      return "Esc";
    case "Delete":
      return "Del";
    case "PageDown":
      return "PgDn";
    case "PageUp":
      return "PgUp";
    default:
      return "abcdefghijklmnopqrstuvwxyz".includes(t)
        ? `“${t.toUpperCase()}”`
        : `“${t}”`;
  }
}
function L4(t) {
  const e = Ko.value.get(t);
  return e
    ? e.toUpperCase()
    : {
        Escape: "Esc",
        Delete: Ss ? "Fn+Del" : "Del",
        Backspace: Ss ? "Del" : "Backspace",
        PageDown: "PgDn",
        PageUp: "PgUp",
      }[t] || t;
}
function E4(t) {
  switch (t) {
    case " ":
      return "Space";
    default:
      return "abcdefghijklmnopqrstuvwxyz".includes(t)
        ? `“${t.toUpperCase()}”`
        : `“${t}”`;
  }
}
function F4(t) {
  const e = Ko.value.get(t);
  return e ? e.toUpperCase() : t;
}
function cp() {
  return Ko.value === il;
}
function Es(t, e) {
  const n = [];
  if (
    (Ss
      ? (t.meta && n.push("Ctrl"),
        t.alt && n.push("Option"),
        t.shift && n.push("Shift"),
        t.ctrl && n.push("Cmd"))
      : (t.ctrl && n.push("Ctrl"),
        t.alt && n.push("Alt"),
        t.shift && n.push("Shift"),
        t.meta && n.push("Meta")),
    t.key)
  ) {
    let s = "";
    e
      ? (s = t.useCode ? L4(t.key) : P4(t.key))
      : (s = t.useCode ? F4(t.key) : E4(t.key)),
      n.push(s);
  }
  return n.join("+");
}
const B4 = S({
  methods: {
    onAfterEnter(t) {
      const e = t;
      e.style.height = "auto";
    },
    onEnter(t) {
      const e = t,
        { width: n } = getComputedStyle(e);
      (e.style.width = n),
        (e.style.position = "absolute"),
        (e.style.visibility = "hidden"),
        (e.style.height = "auto");
      const { height: s } = getComputedStyle(e);
      (e.style.width = null),
        (e.style.position = null),
        (e.style.visibility = null),
        (e.style.height = "0"),
        getComputedStyle(e),
        setTimeout(() => {
          e.style.height = s;
        });
    },
    onLeave(t) {
      const e = t,
        { height: n } = getComputedStyle(e);
      (e.style.height = n),
        getComputedStyle(e),
        setTimeout(() => {
          e.style.height = "0";
        });
    },
  },
});
function z4(t, e, n, s, o, r) {
  return (
    d(),
    w(
      Tr,
      {
        name: "expandVertically",
        mode: "out-in",
        onAfterEnter: t.onAfterEnter,
        onEnter: t.onEnter,
        onLeave: t.onLeave,
      },
      { default: f(() => [G(t.$slots, "default")]), _: 3 },
      8,
      ["onAfterEnter", "onEnter", "onLeave"]
    )
  );
}
const ns = B(B4, [["render", z4]]),
  R4 = S({
    __name: "AddHotkeyModal",
    props: { action: {} },
    emits: ["submit", "close"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = j({ alt: !1, ctrl: !1, key: "", code: "", meta: !1, shift: !1 });
      function r() {
        p.clear(),
          (o.value = {
            alt: !1,
            ctrl: !1,
            key: "",
            code: "",
            meta: !1,
            shift: !1,
          });
      }
      const l = ll("usePhysicalKeyCode", !0),
        i = b(() => ({
          alt: o.value.alt,
          ctrl: o.value.ctrl,
          key: l.value ? o.value.code : o.value.key,
          meta: o.value.meta,
          shift: o.value.shift,
          useCode: l.value,
        })),
        a = b(() => i.value.key !== ""),
        u = b(() => Es(i.value, !1)),
        p = new Set();
      function m(O) {
        switch ((p.size === 0 && r(), p.add(O.code), sd(O).key)) {
          case "Control":
            o.value.ctrl = !0;
            break;
          case "Meta":
            o.value.meta = !0;
            break;
          case "Alt":
            o.value.alt = !0;
            break;
          case "Shift":
            o.value.shift = !0;
            break;
          default:
            (o.value.code = O.code), (o.value.key = O.key);
        }
      }
      function g(O) {
        p.delete(O.code), p.size === 0 && !a.value && r();
      }
      function v() {
        a.value || r();
      }
      function $(O) {
        (!(O instanceof KeyboardEvent) || O.key !== "Escape") && s("close");
      }
      function k() {
        a.value && s("submit", i.value);
      }
      const M = b(() => cp() && M4.includes(o.value.code));
      function P(O) {
        return [...O].filter((V) => !"“”".includes(V)).join("");
      }
      const x = b(() => {
          const O = P(Es(i.value));
          return ko.filter(
            (V) =>
              V !== n.action.key && kt.getHotkeys(V).some((I) => P(Es(I)) === O)
          );
        }),
        A = b(() =>
          kt.getHotkeys(n.action.key).some((O) => Es(O) === Es(i.value))
        );
      return (O, V) => (
        d(),
        w(
          Bt,
          { class: "AddHotkeyModal", variant: "content", onClose: $ },
          {
            default: f(() => [
              c(
                be,
                { vertical: "", gap: "" },
                {
                  default: f(() => [
                    c(
                      ve,
                      {
                        label: `New shortcut for “${O.action.label}”`,
                        vertical: "",
                      },
                      {
                        default: f(() => [
                          c(
                            vt,
                            {
                              autofocus: "",
                              value: u.value,
                              onBeforeinput:
                                V[0] || (V[0] = st(() => {}, ["prevent"])),
                              onKeydown: st(m, ["prevent"]),
                              onKeyup: g,
                              onFocus: r,
                              onBlur: v,
                            },
                            null,
                            8,
                            ["value"]
                          ),
                        ]),
                        _: 1,
                      },
                      8,
                      ["label"]
                    ),
                    M.value
                      ? (d(),
                        w(
                          lt,
                          { key: 0 },
                          {
                            default: f(
                              () =>
                                V[2] ||
                                (V[2] = [
                                  F(
                                    " Since your keyboard layout could not be detected, it is possible that the key displayed above might not be accurate. The keys you pressed will work as intended, though. "
                                  ),
                                ])
                            ),
                            _: 1,
                          }
                        ))
                      : z("", !0),
                    c(ns, null, {
                      default: f(() => [
                        x.value.length
                          ? (d(),
                            w(
                              lt,
                              { key: 0 },
                              {
                                default: f(() => [
                                  V[3] ||
                                    (V[3] = h(
                                      "p",
                                      null,
                                      " This shortcut is already assigned to the following actions, and therefore might overrule or be overruled in certain scenarios: ",
                                      -1
                                    )),
                                  h("ul", null, [
                                    (d(!0),
                                    C(
                                      Z,
                                      null,
                                      se(
                                        x.value,
                                        (I) => (
                                          d(),
                                          C("li", { key: I }, X(y(gs)(I)), 1)
                                        )
                                      ),
                                      128
                                    )),
                                  ]),
                                ]),
                                _: 1,
                              }
                            ))
                          : z("", !0),
                      ]),
                      _: 1,
                    }),
                    c(ns, null, {
                      default: f(() => [
                        A.value
                          ? (d(),
                            w(
                              lt,
                              { key: 0 },
                              {
                                default: f(() => [
                                  h(
                                    "p",
                                    null,
                                    " This shortcut key already exists for " +
                                      X(O.action.label),
                                    1
                                  ),
                                ]),
                                _: 1,
                              }
                            ))
                          : z("", !0),
                      ]),
                      _: 1,
                    }),
                  ]),
                  _: 1,
                }
              ),
              c(Ft, null, {
                default: f(() => [
                  c(ut, null, {
                    default: f(() => [
                      c(
                        at,
                        {
                          checked: y(l),
                          "onUpdate:checked":
                            V[1] ||
                            (V[1] = (I) => (Rn(l) ? (l.value = I) : null)),
                        },
                        null,
                        8,
                        ["checked"]
                      ),
                      V[5] || (V[5] = F(" Prefer physical keys ")),
                      c(dt, null, {
                        default: f(
                          () =>
                            V[4] ||
                            (V[4] = [
                              F(
                                " When checked, the same physical keys will work even after changing keyboard layouts. "
                              ),
                            ])
                        ),
                        _: 1,
                      }),
                    ]),
                    _: 1,
                  }),
                  c(Je),
                  c(
                    te,
                    { disabled: A.value || !a.value, onClick: k },
                    {
                      default: f(
                        () => V[6] || (V[6] = [F(" Add new shortcut ")])
                      ),
                      _: 1,
                    },
                    8,
                    ["disabled"]
                  ),
                ]),
                _: 1,
              }),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  O4 = B(R4, [["__scopeId", "data-v-f3eb150c"]]),
  Ji = j(!1);
document.addEventListener("pointermove", dp);
document.addEventListener("keydown", pp);
function dp(t) {
  t.pointerType === "mouse" && fp();
}
function pp() {
  ["INPUT", "TEXTAREA"].includes(document.activeElement.tagName) || fp();
}
function fp() {
  (Ji.value = !0),
    document.removeEventListener("pointermove", dp),
    document.removeEventListener("keydown", pp);
}
const N4 = S({
    __name: "HotkeyText",
    props: { hotkeys: {}, standalone: { type: Boolean } },
    setup(t) {
      const e = t,
        n = b(() =>
          !Ji.value || (Array.isArray(e.hotkeys) && e.hotkeys.length === 0)
            ? !1
            : !!e.hotkeys
        ),
        s = b(() => {
          const r = Et(e.hotkeys || [])
            .map((l) => Es(l, !e.standalone))
            .join(", ");
          return e.standalone ? r : `(${r})`;
        });
      return (o, r) =>
        n.value
          ? (d(),
            C(
              "span",
              {
                key: 0,
                class: Ae(["HotkeyText", { standalone: o.standalone }]),
              },
              X(s.value),
              3
            ))
          : z("", !0);
    },
  }),
  pn = B(N4, [["__scopeId", "data-v-1c834d2b"]]),
  T4 = { class: "table" },
  V4 = { class: "label" },
  j4 = { class: "keys" },
  U4 = S({
    __name: "HotkeysPanel",
    setup(t) {
      Xt(() => {
        navigator.keyboard && A4();
      });
      const e = ko.map((a) => ({ label: gs(a), key: a })),
        n = b(() =>
          e.map(({ label: a, key: u }) => ({ label: a, key: u, hotkeys: s(u) }))
        );
      function s(a) {
        return kt.getHotkeys(a);
      }
      const o = j();
      function r(a) {
        o.value = a;
      }
      function l(a, u) {
        ee.hotkeys[a].push(B0(u)), (o.value = void 0);
      }
      function i(a, u) {
        ee.hotkeys[a].splice(u, 1);
      }
      return (a, u) => (
        d(),
        w(
          be,
          { class: "HotkeysPanel", vertical: "", gap: "" },
          {
            default: f(() => [
              c(lt, null, {
                default: f(() => [
                  y(cp)()
                    ? (d(),
                      C(
                        Z,
                        { key: 0 },
                        [
                          u[3] ||
                            (u[3] = F(
                              " Could not detect your keyboard layout. Unless a key is enclosed in quotes (“ ”), all shortcut keys are assuming a "
                            )),
                          c(
                            Jn,
                            {
                              to: "https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/KB_United_States.svg/1920px-KB_United_States.svg.png",
                            },
                            {
                              default: f(
                                () => u[2] || (u[2] = [F(" QWERTY layout ")])
                              ),
                              _: 1,
                            }
                          ),
                          u[4] ||
                            (u[4] = F(
                              ". Characters enclosed in quotes represent whatever key outputs that character. "
                            )),
                        ],
                        64
                      ))
                    : (d(),
                      C(
                        Z,
                        { key: 1 },
                        [
                          F(
                            " Characters enclosed in quotes (“ ”) represent whatever key outputs that character. "
                          ),
                        ],
                        64
                      )),
                ]),
                _: 1,
              }),
              h("div", T4, [
                (d(!0),
                C(
                  Z,
                  null,
                  se(
                    n.value,
                    (p, m) => (
                      d(),
                      C("div", { key: m, class: "row" }, [
                        h("div", V4, X(p.label), 1),
                        h("div", j4, [
                          (d(!0),
                          C(
                            Z,
                            null,
                            se(
                              p.hotkeys,
                              (g, v) => (
                                d(),
                                C("div", { key: v }, [
                                  c(
                                    pn,
                                    {
                                      hotkeys: g,
                                      class: "listHotkey",
                                      standalone: "",
                                    },
                                    null,
                                    8,
                                    ["hotkeys"]
                                  ),
                                ])
                              )
                            ),
                            128
                          )),
                        ]),
                        c(
                          sl,
                          { variant: "borderless" },
                          {
                            default: f(() => [
                              c(
                                Ge,
                                { onClick: (g) => r(p.key) },
                                {
                                  default: f(() => [
                                    c(es),
                                    u[5] || (u[5] = F(" Add shortcut key ")),
                                  ]),
                                  _: 2,
                                },
                                1032,
                                ["onClick"]
                              ),
                              u[7] || (u[7] = h("hr", null, null, -1)),
                              (d(!0),
                              C(
                                Z,
                                null,
                                se(
                                  p.hotkeys,
                                  (g, v) => (
                                    d(),
                                    w(
                                      Ge,
                                      { key: v, onClick: ($) => i(p.key, v) },
                                      {
                                        default: f(() => [
                                          c(xo),
                                          h("span", null, [
                                            u[6] || (u[6] = F(" Remove ")),
                                            c(
                                              pn,
                                              {
                                                class: "listHotkey",
                                                hotkeys: g,
                                                standalone: "",
                                              },
                                              null,
                                              8,
                                              ["hotkeys"]
                                            ),
                                          ]),
                                        ]),
                                        _: 2,
                                      },
                                      1032,
                                      ["onClick"]
                                    )
                                  )
                                ),
                                128
                              )),
                            ]),
                            _: 2,
                          },
                          1024
                        ),
                      ])
                    )
                  ),
                  128
                )),
              ]),
              c(Oe, null, {
                default: f(() => [
                  o.value
                    ? (d(),
                      w(
                        O4,
                        {
                          key: 0,
                          action: n.value.find((p) => p.key === o.value),
                          onSubmit: u[0] || (u[0] = (p) => l(o.value, p)),
                          onClose: u[1] || (u[1] = (p) => (o.value = void 0)),
                        },
                        null,
                        8,
                        ["action"]
                      ))
                    : z("", !0),
                ]),
                _: 1,
              }),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  H4 = B(U4, [["__scopeId", "data-v-ef22aa4f"]]),
  W4 = S({
    __name: "LargeIconButton",
    props: {
      active: { type: Boolean },
      disabled: { type: Boolean },
      toggleable: { type: Boolean },
    },
    setup(t) {
      return (e, n) => (
        d(),
        w(
          te,
          {
            class: "LargeIconButton",
            active: e.active,
            disabled: e.disabled,
            toggleable: e.toggleable,
            outline: "",
          },
          { default: f(() => [G(e.$slots, "default", {}, void 0, !0)]), _: 3 },
          8,
          ["active", "disabled", "toggleable"]
        )
      );
    },
  }),
  pt = B(W4, [["__scopeId", "data-v-6b22ed35"]]),
  Z4 = {},
  G4 = {
    viewBox: "0 0 81 57",
    xmlns: "http://www.w3.org/2000/svg",
    "xml:space": "preserve",
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-miterlimit": "1.5",
  };
function q4(t, e) {
  return (
    d(),
    C(
      "svg",
      G4,
      e[0] ||
        (e[0] = [
          h(
            "g",
            { class: "main" },
            [
              h("path", {
                fill: "none",
                d: "M.5 4.5h49v49H.5zM33.167 4.5v49m-16.334-49v49M.5 37.167h49M.5 20.833h49",
              }),
              h("path", {
                fill: "none",
                "stroke-width": ".2",
                d: "M5.944 4.5v49m21.778-49v49m-16.333-49v49M.5 42.611h49M.5 26.278h49M.5 48.056h49M38.611 4.5v49m-16.333-49v49m21.778-49v49M.5 9.944h49M.5 31.722h49M.5 15.389h49",
              }),
            ],
            -1
          ),
          h(
            "path",
            {
              class: "secondary",
              fill: "none",
              d: "M54.5 38.5h4v4h-4zm20 0h4v4h-4zm-20 4h4v4h-4zm20 0h4v4h-4zm-20 4h4v4h-4zm20 0h4v4h-4zm-20 4h4v4h-4zm20 0h4v4h-4zm-14-12h4v4h-4zm0 4h4v4h-4zm0 4h4v4h-4zm0 4h4v4h-4zm4-12h4v4h-4zm0 4h4v4h-4zm0 4h4v4h-4zm0 4h4v4h-4zm4-12h4v4h-4zm0 4h4v4h-4zm0 4h4v4h-4zm0 4h4v4h-4zm-14-42h26v4.452h-26zm-2.5.726h2.5v3H52zm0 4.452h2.5v3H52zm2.5-.726h26V17.5h-26zM16.5.5h17v2h-17zm36 4h28v2h-28zm-.5-4h2v2h-2zm4 0h8v2h-8zm10.5 0h8v1h-8zm-50 55h17v1h-17zM64 2.5h16.5",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const K4 = B(Z4, [
    ["render", q4],
    ["__scopeId", "data-v-b812698c"],
  ]),
  X4 = {},
  Y4 = {
    viewBox: "0 0 52 88",
    xmlns: "http://www.w3.org/2000/svg",
    "xml:space": "preserve",
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-miterlimit": "1.5",
  };
function J4(t, e) {
  return (
    d(),
    C(
      "svg",
      Y4,
      e[0] ||
        (e[0] = [
          h(
            "g",
            { class: "main" },
            [
              h("path", {
                fill: "none",
                d: "M1.5 13.5h49v49h-49zM34.167 13.5v49m-16.334-49v49M1.5 46.167h49m-49-16.334h49",
              }),
              h("path", {
                fill: "none",
                "stroke-width": ".2",
                d: "M6.944 13.5v49m21.778-49v49m-16.333-49v49M39.611 13.5v49m-16.333-49v49m21.778-49v49M1.5 18.944h49m-49 21.778h49m-49-16.333h49M1.5 51.611h49m-49-16.333h49m-49 21.778h49",
              }),
            ],
            -1
          ),
          h(
            "path",
            {
              class: "secondary",
              fill: "none",
              d: "M9 65.167h5.667v5.667H9zM1.5 7.5h4v4h-4zm6 0h4v4h-4zm6 0h4v4h-4zm33 0h4v4h-4zm-9.167 57.667H43v5.667h-5.667zM9 70.833h5.667V76.5H9zm28.333 0H43V76.5h-5.667zM9 76.5h5.667v5.667H9zm28.333 0H43v5.667h-5.667zM9 82.167h5.667v5.667H9zm28.333 0H43v5.667h-5.667zm-19.833-17h5.667v5.667H17.5zM17.5 70.833h5.667V76.5H17.5zm0 5.667h5.667v5.667H17.5zm0 5.667h5.667v5.667H17.5zm5.667-17h5.667v5.667h-5.667zM23.167 70.833h5.667V76.5h-5.667zm0 5.667h5.667v5.667h-5.667zm0 5.667h5.667v5.667h-5.667zM28.833 65.167H34.5v5.667h-5.667zM28.833 70.833H34.5V76.5h-5.667zm0 5.667H34.5v5.667h-5.667zm0 5.667H34.5v5.667h-5.667zM17.5 5.5v-5h17v5h17M37.5 2h9v2h-9zm-32 0h9v2h-9zm16 0h9v2h-9zM.5 5.5h17",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const Q4 = B(X4, [
    ["render", J4],
    ["__scopeId", "data-v-dd917b66"],
  ]),
  ew = {},
  tw = {
    viewBox: "0 0 113 57",
    xmlns: "http://www.w3.org/2000/svg",
    "xml:space": "preserve",
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-miterlimit": "1.5",
  };
function nw(t, e) {
  return (
    d(),
    C(
      "svg",
      tw,
      e[0] ||
        (e[0] = [
          h(
            "g",
            { class: "main" },
            [
              h("path", {
                fill: "none",
                d: "M32 4.5h49v49H32zM64.667 4.5v49m-16.334-49v49M32 37.167h49M32 20.833h49",
              }),
              h("path", {
                fill: "none",
                "stroke-width": ".2",
                d: "M37.444 4.5v49m21.778-49v49m-16.333-49v49M32 42.611h49M32 26.278h49M32 48.056h49M70.111 4.5v49m-16.333-49v49m21.778-49v49M32 9.944h49M32 31.722h49M32 15.389h49",
              }),
            ],
            -1
          ),
          h(
            "path",
            {
              class: "secondary",
              fill: "none",
              d: "M86 38.5h4v4h-4zm-2-38h4v4h-4zm4 0h4v4h-4zm4 0h4v4h-4zm4 0h4v4h-4zm4 0h4v4h-4zm9.579 0h3v3h-3zM106 38.5h4v4h-4zm-20 4h4v4h-4zm20 0h4v4h-4zm-20 4h4v4h-4zm20 0h4v4h-4zm-20 4h4v4h-4zm20 0h4v4h-4zm-14-12h4v4h-4zm0 4h4v4h-4zm0 4h4v4h-4zm0 4h4v4h-4zm4-12h4v4h-4zm0 4h4v4h-4zm0 4h4v4h-4zm0 4h4v4h-4zm4-12h4v4h-4zm0 4h4v4h-4zm0 4h4v4h-4zm0 4h4v4h-4zm-97-35h26v4.452H3zm-2.5.726H3v3H.5zm0 4.452H3v3H.5zm2.5-.726h26V24.5H3zM1 .5h12v3H1zM48 .5h17v2H48zm-47 4h28v2H1zm0 7h28v2H1zm0-3h9v1H1zm47 47h17v1H48z",
            },
            null,
            -1
          ),
        ])
    )
  );
}
const sw = B(ew, [
    ["render", nw],
    ["__scopeId", "data-v-6336d672"],
  ]),
  ow = S({
    __name: "InterfacePanel",
    setup(t) {
      return (e, n) => (
        d(),
        w(
          be,
          { vertical: "", gap: "" },
          {
            default: f(() => [
              c(
                ve,
                { label: "Theme" },
                {
                  default: f(() => [
                    c(
                      Go,
                      {
                        value: y(ee).theme,
                        "onUpdate:value":
                          n[0] || (n[0] = (s) => (y(ee).theme = s)),
                        options: [
                          { label: "OS default", value: "auto" },
                          { label: "Light", value: "light" },
                          { label: "Dark", value: "dark" },
                        ],
                        variant: "horizontal",
                      },
                      null,
                      8,
                      ["value"]
                    ),
                  ]),
                  _: 1,
                }
              ),
              c(
                ve,
                { label: "Preferred layout:", vertical: "" },
                {
                  default: f(() => [
                    c(
                      be,
                      { gap: "", style: { "flex-wrap": "wrap" } },
                      {
                        default: f(() => [
                          c(
                            pt,
                            {
                              active: y(ee).preferredLayout === "none",
                              onClick:
                                n[1] ||
                                (n[1] = (s) =>
                                  (y(ee).preferredLayout = "none")),
                            },
                            {
                              default: f(() => n[5] || (n[5] = [F(" None ")])),
                              _: 1,
                            },
                            8,
                            ["active"]
                          ),
                          c(
                            pt,
                            {
                              active: y(ee).preferredLayout === "wide",
                              onClick:
                                n[2] ||
                                (n[2] = (s) =>
                                  (y(ee).preferredLayout = "wide")),
                            },
                            { default: f(() => [c(sw)]), _: 1 },
                            8,
                            ["active"]
                          ),
                          c(
                            pt,
                            {
                              active: y(ee).preferredLayout === "landscape",
                              onClick:
                                n[3] ||
                                (n[3] = (s) =>
                                  (y(ee).preferredLayout = "landscape")),
                            },
                            { default: f(() => [c(K4)]), _: 1 },
                            8,
                            ["active"]
                          ),
                          c(
                            pt,
                            {
                              active: y(ee).preferredLayout === "portrait",
                              onClick:
                                n[4] ||
                                (n[4] = (s) =>
                                  (y(ee).preferredLayout = "portrait")),
                            },
                            { default: f(() => [c(Q4)]), _: 1 },
                            8,
                            ["active"]
                          ),
                        ]),
                        _: 1,
                      }
                    ),
                    y(ee).preferredLayout !== "none"
                      ? (d(),
                        w(
                          lt,
                          { key: 0 },
                          {
                            default: f(
                              () =>
                                n[6] ||
                                (n[6] = [
                                  F(
                                    " A different layout will be used if the preferred layout does not fit the screen dimensions. "
                                  ),
                                ])
                            ),
                            _: 1,
                          }
                        ))
                      : z("", !0),
                  ]),
                  _: 1,
                }
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  rw = B(ow, [["__scopeId", "data-v-b8739c37"]]),
  lw = S({
    components: {
      InterfacePanel: rw,
      HotkeysPanel: H4,
      AdvancedPanel: YC,
      ExportingPanel: I4,
      DisplayPanel: b4,
      TabStrip: ts,
      ModalHeader: un,
      Modal: Bt,
    },
    emits: { close: () => !0 },
    data() {
      return { activeTab: "display" };
    },
    computed: {
      tabs() {
        const t = Ji.value ? [{ id: "hotkeys", label: "Shortcut keys" }] : [];
        return [
          { id: "display", label: "Display" },
          { id: "exporting", label: "Export/Sharing" },
          { id: "interface", label: "Interface" },
          ...t,
          { id: "advanced", label: "Advanced" },
        ];
      },
      model() {
        return ee;
      },
    },
  });
function iw(t, e, n, s, o, r) {
  const l = H("ModalHeader"),
    i = H("TabStrip"),
    a = H("DisplayPanel"),
    u = H("ExportingPanel"),
    p = H("InterfacePanel"),
    m = H("HotkeysPanel"),
    g = H("AdvancedPanel"),
    v = H("Modal");
  return (
    d(),
    w(
      v,
      {
        class: "PreferencesModal",
        variant: "responsive",
        width: 34,
        onClose: e[1] || (e[1] = ($) => t.$emit("close")),
      },
      {
        default: f(() => [
          c(l, null, {
            default: f(() => e[2] || (e[2] = [F(" Preferences ")])),
            _: 1,
          }),
          c(
            i,
            {
              "active-tab": t.activeTab,
              "onUpdate:activeTab": e[0] || (e[0] = ($) => (t.activeTab = $)),
              tabs: t.tabs,
            },
            null,
            8,
            ["active-tab", "tabs"]
          ),
          t.activeTab === "display"
            ? (d(), w(a, { key: 0, class: "panel" }))
            : t.activeTab === "exporting"
            ? (d(), w(u, { key: 1, class: "panel" }))
            : t.activeTab === "interface"
            ? (d(), w(p, { key: 2, class: "panel" }))
            : t.activeTab === "hotkeys"
            ? (d(), w(m, { key: 3, class: "panel" }))
            : t.activeTab === "advanced"
            ? (d(), w(g, { key: 4, class: "panel" }))
            : z("", !0),
        ]),
        _: 1,
      }
    )
  );
}
const aw = B(lw, [
    ["render", iw],
    ["__scopeId", "data-v-725b7123"],
  ]),
  uw = S({
    __name: "DigitsRangeInput",
    props: { minDigit: {}, maxDigit: {} },
    emits: ["update:minDigit", "update:maxDigit"],
    setup(t) {
      return (e, n) => (
        d(),
        w(
          be,
          { class: "DigitsRangeInput", gap: "", align: "center" },
          {
            default: f(() => [
              c(
                Ht,
                {
                  value: e.minDigit,
                  min: 0,
                  max: 1,
                  "onUpdate:value":
                    n[0] || (n[0] = (s) => e.$emit("update:minDigit", s)),
                },
                null,
                8,
                ["value"]
              ),
              n[2] || (n[2] = F(" – ")),
              c(
                Ht,
                {
                  value: e.maxDigit,
                  min: e.minDigit + 1,
                  max: 9,
                  "onUpdate:value":
                    n[1] || (n[1] = (s) => e.$emit("update:maxDigit", s)),
                },
                null,
                8,
                ["value", "min"]
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  hp = B(uw, [["__scopeId", "data-v-348ec94a"]]);
function cw(t) {
  const e = j(t == null ? void 0 : t.element),
    n = j(t == null ? void 0 : t.input),
    s = (t == null ? void 0 : t.styleProp) ?? "height",
    o = j(1),
    r = j(0);
  function l() {
    if (!e.value) return;
    let i = "";
    const a = getComputedStyle(e.value);
    (e.value.style[s] = "1px"),
      (o.value = Math.ceil(
        e.value.scrollHeight +
          Number.parseInt(a.borderTopWidth, 10) +
          Number.parseInt(a.borderBottomWidth, 10) +
          2
      ));
    const u = oc(t == null ? void 0 : t.styleTarget);
    u ? (u.style[s] = `${o.value}px`) : (i = `${o.value}px`),
      (e.value.style[s] = i);
  }
  return (
    ae([n, e], () => wn(l), { immediate: !0 }),
    ae(o, () => {
      var i;
      return (i = t == null ? void 0 : t.onResize) == null ? void 0 : i.call(t);
    }),
    js(e, ([{ contentRect: i }]) => {
      r.value !== i.width && ((r.value = i.width), l());
    }),
    t != null && t.watch && ae(t.watch, l, { immediate: !0, deep: !0 }),
    { textarea: e, input: n }
  );
}
const dw = ["placeholder", "value"],
  pw = S({
    __name: "TextInputMultiline",
    props: {
      value: { default: "" },
      placeholder: { default: "" },
      autofocus: { type: Boolean },
      invalid: { type: Boolean },
      isCode: { type: Boolean },
      size: { default: 2 },
      autosize: { type: Boolean },
    },
    emits: ["update:value", "change"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = j();
      ae(
        () => n.invalid,
        (l) => {
          var i;
          (i = o.value) == null || i.setCustomValidity(l ? "Invalid" : "");
        },
        { immediate: !0, flush: "post" }
      ),
        Xt(() => {
          n.autofocus && o.value.focus();
        });
      function r() {
        s("change", o.value.value);
      }
      return (
        n.autosize &&
          cw({ element: o, input: b(() => n.value), styleProp: "height" }),
        (l, i) => (
          d(),
          C(
            "textarea",
            {
              ref_key: "element",
              ref: o,
              class: Ae([
                "TextInputMultiline",
                { autosize: l.autosize, isCode: l.isCode },
              ]),
              placeholder: l.placeholder,
              value: l.value,
              rows: "2",
              onInput: i[0] || (i[0] = (a) => s("update:value", o.value.value)),
              onChange: r,
            },
            null,
            42,
            dw
          )
        )
      );
    },
  }),
  Lu = B(pw, [["__scopeId", "data-v-63d771da"]]),
  fw = { class: "authorInput" },
  hw = S({
    __name: "MetaDataForm",
    props: {
      name: {},
      author: {},
      comment: {},
      completionMessage: {},
      minDigit: {},
      maxDigit: {},
      showDigitsInput: { type: Boolean },
    },
    emits: [
      "update:name",
      "update:author",
      "update:comment",
      "update:completionMessage",
      "update:minDigit",
      "update:maxDigit",
      "submit",
    ],
    setup(t) {
      return (e, n) => (
        d(),
        w(
          be,
          { vertical: "", gap: "" },
          {
            default: f(() => [
              c(
                ve,
                { label: "Name", vertical: "" },
                {
                  default: f(() => [
                    c(
                      vt,
                      {
                        value: e.name,
                        placeholder: "Untitled",
                        "onUpdate:value":
                          n[0] || (n[0] = (s) => e.$emit("update:name", s)),
                      },
                      null,
                      8,
                      ["value"]
                    ),
                  ]),
                  _: 1,
                }
              ),
              c(
                ve,
                { label: "Author", vertical: "" },
                {
                  default: f(() => [
                    h("div", fw, [
                      c(
                        vt,
                        {
                          value: e.author,
                          "onUpdate:value":
                            n[1] || (n[1] = (s) => e.$emit("update:author", s)),
                        },
                        null,
                        8,
                        ["value"]
                      ),
                      y(ee).defaultAuthorName === ""
                        ? (d(),
                          w(
                            te,
                            {
                              key: 0,
                              disabled: e.author === "",
                              onClick:
                                n[2] ||
                                (n[2] = (s) =>
                                  (y(ee).defaultAuthorName = e.author)),
                            },
                            {
                              default: f(
                                () => n[11] || (n[11] = [F(" Set as default ")])
                              ),
                              _: 1,
                            },
                            8,
                            ["disabled"]
                          ))
                        : z("", !0),
                    ]),
                  ]),
                  _: 1,
                }
              ),
              c(
                ve,
                { label: "Rules", vertical: "" },
                {
                  default: f(() => [
                    c(
                      Lu,
                      {
                        value: e.comment,
                        class: "commentInput",
                        autosize: "",
                        "onUpdate:value":
                          n[3] || (n[3] = (s) => e.$emit("update:comment", s)),
                        onKeydown: [
                          n[4] ||
                            (n[4] = Dn(
                              st((s) => e.$emit("submit"), ["ctrl"]),
                              ["enter"]
                            )),
                          n[5] ||
                            (n[5] = Dn(
                              st((s) => e.$emit("submit"), ["meta"]),
                              ["enter"]
                            )),
                        ],
                      },
                      null,
                      8,
                      ["value"]
                    ),
                  ]),
                  _: 1,
                }
              ),
              c(
                ve,
                { vertical: "" },
                {
                  label: f(() => [
                    n[13] || (n[13] = F(" Custom completion message ")),
                    c(dt, null, {
                      default: f(
                        () =>
                          n[12] ||
                          (n[12] = [
                            F(
                              "The custom message to show in SudokuPad when the solver has completed the puzzle."
                            ),
                          ])
                      ),
                      _: 1,
                    }),
                  ]),
                  default: f(() => [
                    c(
                      Lu,
                      {
                        value: e.completionMessage,
                        placeholder: "(Optional)",
                        autosize: "",
                        "onUpdate:value":
                          n[6] ||
                          (n[6] = (s) =>
                            e.$emit("update:completionMessage", s)),
                        onKeydown: [
                          n[7] ||
                            (n[7] = Dn(
                              st((s) => e.$emit("submit"), ["ctrl"]),
                              ["enter"]
                            )),
                          n[8] ||
                            (n[8] = Dn(
                              st((s) => e.$emit("submit"), ["meta"]),
                              ["enter"]
                            )),
                        ],
                      },
                      null,
                      8,
                      ["value"]
                    ),
                  ]),
                  _: 1,
                }
              ),
              e.showDigitsInput
                ? (d(),
                  C(
                    Z,
                    { key: 0 },
                    [
                      n[14] || (n[14] = h("hr", null, null, -1)),
                      c(
                        ve,
                        { label: "Digits:" },
                        {
                          default: f(() => [
                            c(
                              hp,
                              {
                                "min-digit": e.minDigit,
                                "max-digit": e.maxDigit,
                                "onUpdate:minDigit":
                                  n[9] ||
                                  (n[9] = (s) => e.$emit("update:minDigit", s)),
                                "onUpdate:maxDigit":
                                  n[10] ||
                                  (n[10] = (s) =>
                                    e.$emit("update:maxDigit", s)),
                              },
                              null,
                              8,
                              ["min-digit", "max-digit"]
                            ),
                          ]),
                          _: 1,
                        }
                      ),
                    ],
                    64
                  ))
                : z("", !0),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  mp = B(hw, [["__scopeId", "data-v-bc1ef478"]]),
  mw = S({
    __name: "PuzzleMetaDataModal",
    props: { project: {} },
    emits: ["close"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = rn({
          name: n.project.name,
          author: n.project.author,
          comment: n.project.comment,
          originalComment: n.project.comment,
          completionMessage: n.project.messages.completion,
          originalCompletionMessage: n.project.messages.completion,
          minDigit: n.project.spec.minDigit,
          maxDigit: n.project.spec.maxDigit,
        });
      function r() {
        (n.project.name = o.name.trim()),
          (n.project.comment = o.comment.trim()),
          (n.project.messages.completion = o.completionMessage.trim()),
          (n.project.author = o.author.trim()),
          n.project.updateSpec({ minDigit: o.minDigit, maxDigit: o.maxDigit }),
          s("close");
      }
      function l() {
        const i = o.originalComment !== o.comment,
          a = o.originalCompletionMessage !== o.completionMessage;
        i || a
          ? ws({
              header: "Unsaved changes",
              body: "Are you sure you want to dismiss the changes you made to the puzzle’s rules and/or completion message?",
              callback: () => s("close"),
            })
          : s("close");
      }
      return (i, a) => (
        d(),
        w(
          Bt,
          {
            class: "PuzzleMetaDataModal",
            variant: "responsive",
            "responsive-flex": "",
            "backdrop-dismissible": !1,
            onClose: l,
          },
          {
            default: f(() => [
              h(
                "form",
                {
                  style: { display: "contents" },
                  onSubmit: st(r, ["prevent"]),
                },
                [
                  c(
                    mp,
                    {
                      author: o.author,
                      "onUpdate:author": a[0] || (a[0] = (u) => (o.author = u)),
                      name: o.name,
                      "onUpdate:name": a[1] || (a[1] = (u) => (o.name = u)),
                      comment: o.comment,
                      "onUpdate:comment":
                        a[2] || (a[2] = (u) => (o.comment = u)),
                      "completion-message": o.completionMessage,
                      "onUpdate:completionMessage":
                        a[3] || (a[3] = (u) => (o.completionMessage = u)),
                      "min-digit": o.minDigit,
                      "onUpdate:minDigit":
                        a[4] || (a[4] = (u) => (o.minDigit = u)),
                      "max-digit": o.maxDigit,
                      "onUpdate:maxDigit":
                        a[5] || (a[5] = (u) => (o.maxDigit = u)),
                      "show-digits-input": i.project.spec.type === y(Ie).Custom,
                      onSubmit: r,
                    },
                    null,
                    8,
                    [
                      "author",
                      "name",
                      "comment",
                      "completion-message",
                      "min-digit",
                      "max-digit",
                      "show-digits-input",
                    ]
                  ),
                  c(Je),
                  c(Ft, null, {
                    default: f(() => [
                      c(
                        te,
                        { onClick: l },
                        {
                          default: f(() => a[6] || (a[6] = [F(" Cancel ")])),
                          _: 1,
                        }
                      ),
                      c(Je),
                      c(
                        te,
                        { type: "submit" },
                        {
                          default: f(() => a[7] || (a[7] = [F(" Update ")])),
                          _: 1,
                        }
                      ),
                    ]),
                    _: 1,
                  }),
                ],
                32
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  { provide: gw, inject: vw } = qo("changelog");
function yw() {
  const t = "Release 2025-07-05",
    e = gw(),
    n = ll("lastSeenChangelog", "");
  return !En.isEmpty() && n.value !== t && (e.isOpen = !0), (n.value = t), e;
}
const { provide: Cw, inject: gp } = qo("customConstraint"),
  { provide: ww, inject: Qi } = qo("export"),
  { provide: bw, inject: vp } = qo("preferences");
class yp extends Error {
  constructor() {
    super("User modified the puzzle");
  }
}
const Eu = ys(new Set()),
  Po = j(new Set());
function kw() {
  Cp([]);
}
function Cp(t) {
  (Eu.value = new Set(t)), Po.value.clear();
  for (const e of Eu.value) wp(e);
}
function wp(t, e = !0) {
  e ? Po.value.add(fr(t)) : Po.value.delete(t);
}
function Fu(t) {
  return Po.value.has(t);
}
function _w() {
  return Po.value;
}
const $w = { class: "ConstraintComponentsRenderer", opacity: "0.6" },
  Sw = ["points"],
  Iw = ["points", "stroke"],
  xw = ["cx", "cy", "fill"],
  cn = 5,
  Dw = S({
    __name: "ConstraintComponentsRenderer",
    setup(t) {
      const { spec: e, helpers: n } = Qe(et).value,
        s = Math.floor((cn * cn) / 2);
      function o(m, g) {
        g = (g + s) % (cn * cn);
        const v = (g % cn) / cn,
          $ = Math.floor(g / cn) / cn;
        (m.x += v + 1 / (2 * cn) + Math.random() * 0.001 - 5e-4),
          (m.y += $ + 1 / (2 * cn) + Math.random() * 0.001 - 5e-4);
      }
      const r = ys([]),
        l = ys([]),
        i = ys([]),
        a = b(() => _w()),
        u = b(() => {
          const m = r.value;
          return i.value.map((g) => {
            const v = m[g.point1].position,
              $ = m[g.point2].position;
            return {
              polygonString: `${v.x} ${v.y} ${$.x} ${$.y}`,
              color: g.color,
            };
          });
        });
      ae(
        a,
        () => {
          const { width: m, height: g } = e.size,
            v = [],
            $ = [],
            k = Array.from({ length: m * g }, () => []),
            M = new Map();
          for (let x = 0; x < m * g; x++) M.set(x, 0);
          const P = (x) => {
            const A = M.get(x);
            M.set(x, A + 1);
            const O = mt.from(n.cellIds.getCoordsFromId(x));
            return o(O, A), O;
          };
          for (const x of a.value) {
            const A = Us(
              Gr({
                hue: Math.random(),
                saturation: 1 - Math.random() * 0.5,
                lightness: 0.4 + Math.random() * 0.2,
              })
            );
            for (let O = 0; O < x.cells.length; O++) {
              const V = P(x.cells[O]),
                I = {
                  index: v.length,
                  homeBase: mt
                    .from(n.cellIds.getCoordsFromId(x.cells[O]))
                    .add({ x: 0.5, y: 0.5 }),
                  position: V,
                  velocity: new mt(),
                  force: new mt(),
                  color: A,
                };
              if ((v.push(I), k[p(I)].push(I), O > 0)) {
                const U = v[v.length - 2];
                $.push({ point1: U.index, point2: I.index, color: A });
              }
            }
          }
          (r.value = v), (i.value = $), (l.value = k);
        },
        { immediate: !0, deep: !0 }
      ),
        zi(() => {
          const g = r.value;
          for (const v of g) (v.force.x = 0), (v.force.y = 0);
          for (const v of i.value) {
            const $ = g[v.point1],
              k = g[v.point2],
              M = mt.from(Ze($.position, k.position));
            M.scale(0.5 * 0.1),
              k.force.copy(k.force).add(M),
              $.force.copy($.force).addScaled(M, -1);
          }
          for (const v of l.value)
            for (let $ = 0; $ < v.length; $++)
              for (let k = $ + 1; k < v.length; k++) {
                const M = v[$],
                  P = v[k],
                  x = mt.from(Ze(P.position, M.position)),
                  A = x.magnitude;
                if (A < 1e-5) {
                  M.position.x += 1e-4;
                  continue;
                }
                const O = 0.1 / A;
                x.normalize().scale(O * 0.1),
                  P.force.add(x),
                  M.force.addScaled(x, -1);
              }
          for (const v of r.value) {
            const $ = mt.from(Ze(v.homeBase, v.position));
            $.scale(10 * 0.1),
              v.force.add($),
              v.force.addScaled(v.velocity, -0.1);
          }
          for (const v of r.value)
            v.velocity.addScaled(v.force, 0.1),
              v.position.addScaled(v.velocity, 0.1),
              v.position.x < v.homeBase.x - 0.35 &&
                (v.position.x = v.homeBase.x - 0.35),
              v.position.x > v.homeBase.x + 0.35 &&
                (v.position.x = v.homeBase.x + 0.35),
              v.position.y < v.homeBase.y - 0.35 &&
                (v.position.y = v.homeBase.y - 0.35),
              v.position.y > v.homeBase.y + 0.35 &&
                (v.position.y = v.homeBase.y + 0.35);
          C1(r);
        });
      function p(m) {
        return n.cellIds.getIdFromCoords({
          x: Math.floor(m.position.x),
          y: Math.floor(m.position.y),
        });
      }
      return (m, g) => (
        d(),
        C("g", $w, [
          (d(!0),
          C(
            Z,
            null,
            se(
              u.value,
              ({ polygonString: v, color: $ }, k) => (
                d(),
                C("g", { key: k }, [
                  h(
                    "polygon",
                    {
                      points: v,
                      stroke: "#000",
                      "stroke-width": "0.075",
                      fill: "none",
                    },
                    null,
                    8,
                    Sw
                  ),
                  h(
                    "polygon",
                    {
                      points: v,
                      stroke: $,
                      "stroke-width": "0.025",
                      fill: "none",
                    },
                    null,
                    8,
                    Iw
                  ),
                ])
              )
            ),
            128
          )),
          (d(!0),
          C(
            Z,
            null,
            se(
              r.value,
              ({ position: v, color: $ }, k) => (
                d(),
                C("g", { key: k }, [
                  h(
                    "circle",
                    {
                      cx: v.x,
                      cy: v.y,
                      r: 0.05,
                      stroke: "#000",
                      "stroke-width": "0.025",
                      fill: $,
                    },
                    null,
                    8,
                    xw
                  ),
                ])
              )
            ),
            128
          )),
        ])
      );
    },
  });
function ot(t, e, n) {
  n
    ? ae(
        n,
        (s) => {
          s ? ye.addEventListener(t, e) : ye.removeEventListener(t, e);
        },
        { immediate: !0 }
      )
    : ye.addEventListener(t, e),
    Nr(() => {
      ye.removeEventListener(t, e);
    });
}
function Mw({ offsetX: t, offsetY: e }) {
  return (t < 0.3 || t > 0.7) && (e < 0.3 || e > 0.7);
}
function al({ offsetX: t, offsetY: e }) {
  return t < 0.5 ? Math.abs(e - 0.5) < t : Math.abs(e - 0.5) < 1 - t;
}
function* ea(t, e) {
  const n = Math.abs(e.x - t.x),
    s = Math.abs(e.y - t.y),
    o = Math.sign(e.x - t.x),
    r = Math.sign(e.y - t.y);
  let l = n - s,
    { x: i, y: a } = t;
  for (; yield { x: i, y: a }, !(i === e.x && a === e.y); ) {
    const u = 2 * l;
    u > -s && ((l -= s), (i += o)), u < n && ((l += n), (a += r));
  }
}
const bp = S({
  __name: "CellSelection",
  props: { spec: {}, model: {} },
  emits: ["hold"],
  setup(t, { emit: e }) {
    const n = t,
      s = e,
      o = new jr(n.spec),
      r = b(() => n.model.getCellIds()),
      l = j(!1),
      i = j(!1),
      a = j(),
      u = j(),
      p = j(new Set());
    function m(x) {
      (p.value = n.model.getCellIds()), (u.value = x), k(x);
    }
    function g(x) {
      l.value && M(x);
    }
    function v(x) {
      x.cellId !== void 0 && s("hold", x.cellId);
    }
    function $(x) {
      var A, O;
      !x.outside &&
        Hr(p.value, n.model.getCellIds()) &&
        ((A = u.value) == null ? void 0 : A.pointerX) === x.pointerX &&
        ((O = u.value) == null ? void 0 : O.pointerY) === x.pointerY &&
        n.model.clear(),
        (l.value = !1);
    }
    Pt(nt, "pointerDown", m),
      Pt(nt, "pointerMove", g),
      Pt(nt, "pointerHold", v),
      Pt(nt, "pointerUp", $);
    function k(x) {
      const { cellId: A } = x;
      ye.isSelecting() || n.model.clear(),
        A !== void 0 &&
          (n.model.has(A)
            ? ((i.value = !0), n.model.delete(A))
            : ((i.value = !1), n.model.add(A)),
          (l.value = !0),
          (a.value = x));
    }
    function M(x) {
      const { offsetX: A, offsetY: O, cellId: V } = x;
      if (Mw({ offsetX: A, offsetY: O }) || V === void 0) return;
      const I = new Set([V]),
        U = a.value.cell,
        D = x.cell;
      if (Math.abs(U.x - D.x) > 1 || Math.abs(U.y - D.y) > 1)
        for (const N of ea(U, D)) I.add(o.getIdFromCoords(N));
      for (const N of I) i.value ? n.model.delete(N) : n.model.add(N);
      a.value = x;
    }
    function P(x) {
      const A = n.model.getLastSelected();
      if (A === void 0) return;
      ye.isSelecting() || n.model.clear();
      const { width: O, height: V } = n.spec.size,
        I = o.getCoordsFromId(A);
      let U;
      switch (x.direction) {
        case An.Left:
          U = { x: -1, y: 0 };
          break;
        case An.Right:
          U = { x: 1, y: 0 };
          break;
        case An.Up:
          U = { x: 0, y: -1 };
          break;
        case An.Down:
          U = { x: 0, y: 1 };
          break;
      }
      const D = ft(I, U);
      (D.x = xt(D.x, O)), (D.y = xt(D.y, V)), n.model.add(o.getIdFromCoords(D));
    }
    return (
      ot("selectAll", () => n.model.addMultiple(o.getAllCellIds())),
      ot("arrow", P),
      (x, A) => (
        d(),
        w(Zo, { selection: r.value, color: y(ee).selectionColor }, null, 8, [
          "selection",
          "color",
        ])
      )
    );
  },
});
class kp {
  constructor() {
    L(this, "state", { cells: new Set() });
  }
  add(e) {
    this.state.cells.add(e), (this.state.lastCell = e);
  }
  addMultiple(e) {
    hc(this.state.cells, e);
  }
  delete(e) {
    this.state.cells.delete(e), delete this.state.lastCell;
  }
  has(e) {
    return this.state.cells.has(e);
  }
  clear() {
    this.state.cells.clear(), delete this.state.lastCell;
  }
  replace(e) {
    this.state.cells.clear(), this.addMultiple(e);
  }
  getCellIds() {
    return new Set(this.state.cells);
  }
  getLastSelected() {
    return this.state.lastCell;
  }
}
var In = ((t) => (
  (t[(t.Valid = 0)] = "Valid"),
  (t[(t.Error = 1)] = "Error"),
  (t[(t.Warning = 2)] = "Warning"),
  (t[(t.Info = 3)] = "Info"),
  t
))(In || {});
function Lo(t) {
  return new Worker("/assets/puzzleQueries-MeLx_r0v.js", {
    name: t == null ? void 0 : t.name,
  });
}
function ta({ getDefault: t, createWorker: e, execute: n }) {
  return function () {
    const s = ys(t());
    let o = e(),
      r = Cr(o);
    const l = j(!1);
    let i = 0;
    async function a(p) {
      l.value && u(), (l.value = !0);
      const m = ++i,
        g = await n(r, p);
      m === i && ((s.value = g), (l.value = !1));
    }
    function u() {
      o.terminate(), (o = e()), (r = Cr(o));
    }
    return (
      zo(() => {
        o.terminate();
      }, !0),
      {
        result: s,
        busy: l,
        update: (p) => {
          a(p);
        },
      }
    );
  };
}
const Aw = ta({
  getDefault: () => new Map(),
  createWorker: () => new Lo(),
  execute: (t, e) => t.validateConstraints(ue(e)),
});
function Pw(t, e) {
  return e(t.value)
    ? Promise.resolve()
    : new Promise((n) => {
        const s = ae(t, () => {
          e(t.value) && (n(), s());
        });
      });
}
function Lw() {
  const t = ke(),
    e = Aw(),
    n = b(() => e.result.value),
    s = b(() =>
      t.project.value
        .getConstraintsForSolver()
        .map((u) => Al(u))
        .filter((u) => {
          const p = n.value.get(u.id);
          return p ? p.type !== In.Error : !0;
        })
    ),
    o = b((a) => {
      const u = t.project.value,
        p = ue({ spec: u.spec, constraints: s.value, cells: u.cells });
      return Ce(a, p) ? a : p;
    }),
    r = b(() => e.busy.value),
    l = b(() => {
      const a = t.project.value;
      return ue({
        spec: a.spec,
        constraints: a.getConstraintsForSolver(),
        cells: a.cells,
      });
    });
  ae(l, async (a, u) => {
    Ce(a, u) || e.update(a);
  });
  async function i() {
    return await Pw(r, (a) => !a), o.value;
  }
  return () => ({
    getSolverInputData: i,
    solverInputData: o,
    constraintValidations: n,
    updating: r,
  });
}
const as = Lw();
var Fs = ((t) => (
  (t.Color = "color"),
  (t.Candidate = "candidate"),
  (t.Given = "given"),
  (t.Value = "value"),
  (t.Corner = "corner"),
  t
))(Fs || {});
const Ew = {
  [ie.CellCandidate]: ["candidate", "value", "corner", "color", "given"],
  [ie.CellColor]: ["color", "value", "candidate", "corner", "given"],
  [ie.CellCornerPencilMark]: ["corner", "value", "candidate", "color", "given"],
  [ie.CellDigit]: ["value", "candidate", "corner", "given", "color"],
};
function Fw(t, e, n = !1) {
  const s = Ew[e];
  let o = 4;
  return (
    t.forEach((r) => {
      r.value !== void 0
        ? r.given && n
          ? (o = Math.min(o, s.indexOf("given")))
          : r.given || (o = Math.min(o, s.indexOf("value")))
        : (r.candidates && (o = Math.min(o, s.indexOf("candidate"))),
          r.cornerPencilMarks && (o = Math.min(o, s.indexOf("corner")))),
        r.colors && (o = Math.min(o, s.indexOf("color")));
    }),
    s[o]
  );
}
const Bw = {
  [ie.CellDigit]: [
    ie.CellDigit,
    ie.CellColor,
    ie.CellCandidate,
    ie.CellCornerPencilMark,
  ],
  [ie.CellColor]: [
    ie.CellColor,
    ie.CellDigit,
    ie.CellCandidate,
    ie.CellCornerPencilMark,
  ],
  [ie.CellCandidate]: [
    ie.CellDigit,
    ie.CellCandidate,
    ie.CellCornerPencilMark,
    ie.CellColor,
  ],
  [ie.CellCornerPencilMark]: [
    ie.CellDigit,
    ie.CellCornerPencilMark,
    ie.CellCandidate,
    ie.CellColor,
  ],
};
function zw(t, e, n, s = !1) {
  let o = () => !1;
  const r = s ? (i, a) => (i & a) !== 0 : (i, a) => (i & a) === a;
  let l = Bw[n].find(
    (i) =>
      (i === ie.CellDigit && t.value !== void 0) ||
      (i === ie.CellColor && t.colors & -2) ||
      (i === ie.CellCandidate && t.candidates) ||
      (i === ie.CellCornerPencilMark && t.cornerPencilMarks)
  );
  switch (
    ((l === ie.CellCandidate || l === ie.CellCornerPencilMark) &&
      t.value !== void 0 &&
      (l = ie.CellDigit),
    l)
  ) {
    case ie.CellDigit: {
      o = (i) => i.value === t.value;
      break;
    }
    case ie.CellColor: {
      o = (i) => r(i.colors & -2, t.colors & -2);
      break;
    }
    case ie.CellCornerPencilMark: {
      o = (i) => !i.value && r(i.cornerPencilMarks, t.cornerPencilMarks);
      break;
    }
    case ie.CellCandidate: {
      o = (i) => !i.value && r(i.candidates, t.candidates);
      break;
    }
  }
  return e.filter(o).map((i) => i.id);
}
const Rw = 3;
function _l() {
  return {
    highlightConflicts: !0,
    enterDigitsAsGivens: !1,
    useCornerMarksAutomatically: !1,
    dismissUserDataForSolutions: !1,
    dismissUserDataForCheck: !1,
    showFog: !0,
  };
}
const Ne = xs({
  name: "toolsSettings",
  version: Rw,
  getDefault: _l,
  migrate(t, e) {
    return e === 1 || e === 2 ? { ..._l(), ...t } : _l();
  },
});
function Ow(t = 1e3) {
  let e = new Lo(),
    n = Cr(e);
  Nr(() => {
    e == null || e.terminate(), (e = void 0);
  });
  async function s(o, r) {
    let l = new Set();
    return (
      await Promise.race([
        (async () => {
          try {
            l = await n.getCellsSeenByCells(o, r);
          } catch {}
        })(),
        (async () => {
          await new Promise((i) => setTimeout(i, t)),
            !l && e && (e.terminate(), (e = new Lo()), (n = Cr(e)));
        })(),
      ]),
      l
    );
  }
  return { getCellsSeenByCells: s };
}
const Nw = S({
    __name: "SudokuCellEditor",
    emits: ["update:selection"],
    setup(t, { emit: e }) {
      const n = e,
        {
          project: s,
          updateSudokuCells: o,
          selectedConstraint: r,
          editMode: l,
          colorMarkingsPage: i,
          setCellEditMode: a,
        } = ke(),
        { getSolverInputData: u } = as(),
        p = b(() => {
          var I;
          return ((I = r.value) == null ? void 0 : I.config.type) === _.Givens;
        }),
        m = b(() => Ne.enterDigitsAsGivens || p.value),
        g = j(l.value.type),
        v = new Set(),
        $ = b(() =>
          l.value.type === ie.Constraint ? ie.CellDigit : l.value.type
        );
      function k() {
        const I = v.has("Control") || v.has("Meta");
        I && v.has("Shift")
          ? (a(ie.CellColor),
            kt.allowModifiersForDelete({ ctrl: !0, shift: !0 }))
          : I
          ? (a(ie.CellCandidate), kt.allowModifiersForDelete({ ctrl: !0 }))
          : v.has("Shift")
          ? (a(ie.CellCornerPencilMark),
            kt.allowModifiersForDelete({ shift: !0 }))
          : (kt.disallowModifiersForDelete(),
            g.value === ie.Constraint ? a(ie.CellDigit) : a(g.value));
      }
      ot("modifierDown", (I) => {
        if (p.value) {
          v.clear();
          return;
        }
        (I.key !== "Control" && I.key !== "Meta" && I.key !== "Shift") ||
          (v.size === 0 && (g.value = l.value.type), v.add(I.key), k());
      }),
        ot("modifierUp", (I) => {
          if (p.value) {
            v.clear();
            return;
          }
          (I.key !== "Control" && I.key !== "Meta" && I.key !== "Shift") ||
            (v.delete(I.key), k());
        });
      const M = [fe(), fe(), fe(), fe()];
      nc(
        () => {
          switch ($.value) {
            case ie.CellDigit:
              ye.setInputMode(bh(s.value.spec), M[0]);
              break;
            case ie.CellCornerPencilMark:
              ye.setInputMode(kh(s.value.spec), M[1]);
              break;
            case ie.CellCandidate:
              ye.setInputMode(_h(s.value.spec), M[2]);
              break;
            case ie.CellColor:
              ye.setInputMode($h(), M[3]), ye.setPage(i.value);
              break;
          }
        },
        { flush: "post" }
      );
      const P = j(new kp());
      function x(I) {
        P.value.addMultiple(
          zw(s.value.cells[I], s.value.cells, $.value, ye.isAltEnabled())
        );
      }
      ae(
        P,
        () => {
          n("update:selection", P.value.getCellIds());
        },
        { immediate: !0, deep: !0 }
      ),
        ot("input", A),
        ot("delete", V);
      async function A(I) {
        const { spec: U, cells: D } = s.value,
          N = $.value,
          E = Number(I.string);
        if (
          Number.isNaN(E) ||
          ((E < U.minDigit || E > U.maxDigit) && N !== ie.CellColor)
        )
          return;
        const R = E;
        let W = [...P.value.getCellIds()];
        !m.value && N !== ie.CellColor && (W = W.filter((J) => !D[J].given)),
          (N === ie.CellCandidate || N === ie.CellCornerPencilMark) &&
            (W = W.filter((J) => D[J].value === void 0));
        let T;
        switch (N) {
          case ie.CellDigit:
            T = W.every((J) =>
              D[J].value !== R ? !1 : !m.value || D[J].given
            );
            break;
          case ie.CellCandidate:
            T = W.every((J) => !!(D[J].candidates & (1 << R)));
            break;
          case ie.CellCornerPencilMark:
            T = W.every((J) => !!(D[J].cornerPencilMarks & (1 << R)));
            break;
          case ie.CellColor:
            T = W.every((J) => !!(D[J].colors & (1 << R)));
            break;
        }
        const Y = [];
        if (
          !T &&
          Ne.useCornerMarksAutomatically &&
          W.length > 1 &&
          N === ie.CellCornerPencilMark
        ) {
          const J = await u();
          Y.push(...(await O(J, W)));
        }
        o((J) => {
          W.forEach((re) => {
            const ce = J.cells[re];
            switch (N) {
              case ie.CellDigit:
                T
                  ? ((ce.value = void 0), (ce.given = !1))
                  : ((ce.value = R), (ce.given = m.value));
                break;
              case ie.CellCandidate:
                T ? ce.removeCandidate(R) : ce.addCandidate(R);
                break;
              case ie.CellCornerPencilMark:
                T ? ce.removeCornerPencilMark(R) : ce.addCornerPencilMark(R);
                break;
              case ie.CellColor:
                T ? ce.removeColor(R) : ce.addColor(R);
                break;
            }
            for (const ge of Y) J.cells[ge].removeCandidate(R);
          });
        }, "Enter digit");
      }
      const { getCellsSeenByCells: O } = Ow();
      function V() {
        const I = m.value,
          U = [...P.value.getCellIds()];
        o((D) => {
          const N = Fw(
            U.map((E) => D.cells[E]),
            $.value,
            I
          );
          U.forEach((E) => {
            const R = D.cells[E];
            switch (N) {
              case Fs.Candidate:
                R.candidates = 0;
                break;
              case Fs.Corner:
                R.cornerPencilMarks = 0;
                break;
              case Fs.Color:
                R.colors = 0;
                break;
              case Fs.Given:
                if (!I) break;
                (R.given = !1), R.clearValue();
                break;
              case Fs.Value:
                (!R.given || I) && (R.clearValue(), (R.given = !1));
                break;
            }
          });
        }, "Clear cell");
      }
      return (I, U) => (
        d(),
        w(bp, { spec: y(s).spec, model: P.value, onHold: x }, null, 8, [
          "spec",
          "model",
        ])
      );
    },
  }),
  Tw = { opacity: "0.75" },
  Vw = ["transform"],
  jw = S({
    __name: "EditorFogLayer",
    props: {
      cells: {},
      fogCells: {},
      selection: {},
      triggers: {},
      regions: {},
      transparent: { type: Boolean },
    },
    setup(t) {
      const e = t;
      function n(r) {
        for (const l of r) {
          const i = e.cells[l];
          if (i.given || i.value === void 0) return !1;
        }
        return !0;
      }
      const s = b(() => {
          const r = new Set(e.fogCells);
          for (const l of e.triggers)
            n(l.triggerCells) && He.deleteAll(r, l.effectCells);
          return r;
        }),
        o = b(() => e.cells.filter((r) => r.colors && s.value.has(r.id)));
      return (r, l) => (
        d(),
        w(
          ol,
          {
            "fog-cells": s.value,
            regions: r.regions,
            transparent: r.transparent,
          },
          {
            default: f(() => [
              h("g", Tw, [
                (d(!0),
                C(
                  Z,
                  null,
                  se(
                    o.value,
                    (i) => (
                      d(), w(Nd, { key: i.id, cell: i }, null, 8, ["cell"])
                    )
                  ),
                  128
                )),
              ]),
              c(
                Zo,
                { selection: r.selection, color: y(ee).selectionColor },
                null,
                8,
                ["selection", "color"]
              ),
              h(
                "g",
                { transform: `scale(${1 / y(tt)})` },
                [
                  (d(!0),
                  C(
                    Z,
                    null,
                    se(
                      r.cells,
                      (i) => (
                        d(), w(Ed, { key: i.id, cell: i }, null, 8, ["cell"])
                      )
                    ),
                    128
                  )),
                ],
                8,
                Vw
              ),
            ]),
            _: 1,
          },
          8,
          ["fog-cells", "regions", "transparent"]
        )
      );
    },
  });
function Bu(t, e) {
  let n;
  return (
    t.width / t.height < e.width / e.height
      ? (n = t.width / e.width)
      : (n = t.height / e.height),
    { scale: n, target: { x: e.x + e.width / 2, y: e.y + e.height / 2 } }
  );
}
const _p = j(1);
function $p(t) {
  return t / (tt * _p.value);
}
const on = b(() => $p(5)),
  Sp = b(() => $p(1));
function $l(t, e) {
  switch (t.deltaMode) {
    case t.DOM_DELTA_LINE:
      return 8 * t[e];
    case t.DOM_DELTA_PAGE:
      return 24 * t[e];
    default:
      return t[e];
  }
}
const Uw = 1.0068;
function Hw(t, e, n, s) {
  const o = j(!1);
  Dt(t, "wheel", (u) => {
    u.ctrlKey
      ? s.value.mouseWheelScale.z !== 0 && (u.preventDefault(), r(u))
      : (u.deltaX * s.value.mouseWheelScale.x !== 0 ||
          u.deltaY * s.value.mouseWheelScale.y !== 0) &&
        (u.preventDefault(), l(u));
  });
  function r(u) {
    const p = e.value.scale;
    let m = p * Uw ** (-s.value.mouseWheelScale.z * $l(u, "deltaY"));
    m = Rt(m, s.value.minScale, s.value.maxScale);
    const {
        left: g,
        top: v,
        width: $,
        height: k,
      } = t.value.getBoundingClientRect(),
      M = g + $ / 2,
      P = v + k / 2,
      x = { x: (u.clientX - M) / p, y: (u.clientY - P) / p },
      A = { x: (u.clientX - M) / m, y: (u.clientY - P) / m };
    n({
      scale: m,
      target: {
        x: e.value.target.x - A.x + x.x,
        y: e.value.target.y - A.y + x.y,
      },
    });
  }
  function l(u) {
    const p = e.value.scale;
    n({
      scale: p,
      target: {
        x: e.value.target.x + ($l(u, "deltaX") * s.value.mouseWheelScale.x) / p,
        y: e.value.target.y + ($l(u, "deltaY") * s.value.mouseWheelScale.y) / p,
      },
    });
  }
  const i = 1;
  let a;
  return (
    Dt(t, "mousedown", (u) => {
      u.button === i && ((o.value = !0), (a = u));
    }),
    Dt(document, "mousemove", (u) => {
      if (!o.value) return;
      const p = u.clientX - a.clientX,
        m = u.clientY - a.clientY;
      n({
        scale: e.value.scale,
        target: {
          x: e.value.target.x - p / e.value.scale,
          y: e.value.target.y - m / e.value.scale,
        },
      }),
        (a = u);
    }),
    Dt(document, "mouseup", (u) => {
      !o.value || u.button !== i || ((o.value = !1), (a = void 0));
    }),
    { changing: o }
  );
}
function Ww(t, e, n, s) {
  const o = { zoom: { target: { x: 0, y: 0 }, scale: 1 }, touches: new Map() },
    r = j(!1);
  Dt(t, "touchstart", i),
    Dt(document, "touchmove", a),
    Dt(document, "touchend", u),
    Dt(t, "gesturestart", m),
    Dt(document, "gesturechange", g),
    Dt(document, "gestureend", v);
  let l = !1;
  function i(k) {
    l ||
      (k.touches.length >= 2 &&
        ((r.value = !0),
        k.preventDefault(),
        (o.zoom = ue(e.value)),
        (o.touches = new Map([...k.touches].map((M) => [M.identifier, M])))));
  }
  function a(k) {
    l || (r.value && p(k));
  }
  function u(k) {
    l || (k.touches.length === 0 && (r.value = !1));
  }
  function p(k) {
    const M = [...k.touches].map((N) => N.identifier);
    if (M.length < 2) return;
    k.preventDefault();
    const P = new Map([...k.touches].map((N) => [N.identifier, N])),
      x = o.touches.get(M[0]),
      A = o.touches.get(M[1]),
      O = P.get(M[0]),
      V = P.get(M[1]),
      I = Math.hypot(x.screenX - A.screenX, x.screenY - A.screenY),
      U = Math.hypot(O.screenX - V.screenX, O.screenY - V.screenY),
      D = I === U ? 1 : U / I;
    $(
      { x: (x.screenX + A.screenX) / 2, y: (x.screenY + A.screenY) / 2 },
      { x: (O.screenX + V.screenX) / 2, y: (O.screenY + V.screenY) / 2 },
      D
    );
  }
  function m(k) {
    k.preventDefault(),
      (l = !0),
      (r.value = !0),
      (o.zoom = ue(e.value)),
      o.touches.clear(),
      o.touches.set(0, k);
  }
  function g(k) {
    if (!r.value) return;
    k.preventDefault();
    const M = o.touches.get(0);
    $({ x: M.screenX, y: M.screenY }, { x: k.screenX, y: k.screenY }, k.scale);
  }
  function v() {
    r.value = !1;
  }
  function $(k, M, P) {
    const x = o.zoom.scale,
      A = Rt(o.zoom.scale * P, s.value.minScale, s.value.maxScale),
      {
        left: O,
        top: V,
        width: I,
        height: U,
      } = t.value.getBoundingClientRect(),
      D = { x: O + I / 2, y: V + U / 2 },
      N = mt.from(
        Ze(mt.from(Ze(k, D)).scale(1 / x), mt.from(Ze(M, D)).scale(1 / A))
      );
    n({ scale: A, target: N.add(o.zoom.target) });
  }
  return { changing: r };
}
function Zw(t, e) {
  const n = j({ target: { x: 0, y: 0 }, scale: 1 });
  function s(i) {
    n.value = e.value.restrict(i);
  }
  const { changing: o } = Hw(t, n, s, e),
    { changing: r } = Ww(t, n, s, e),
    l = b(() => r.value || o.value);
  return { zoom: n, setZoom: s, changing: l };
}
function Gw({
  element: t,
  project: e,
  sudokuEventBus: n,
  selectedConstraint: s,
}) {
  const o = j({
      canvasSize: { width: 100, height: 100 },
      boundingBox: { x: 0, y: 0, width: 10, height: 10 },
    }),
    r = b(() => Bu(o.value.canvasSize, o.value.boundingBox)),
    l = j(!1),
    i = b(() => r.value.scale * 0.5),
    a = b(() => r.value.scale * 8);
  function u(P) {
    if (!l.value) return P;
    const x = r.value.scale * 0.5,
      A = r.value.scale * 8,
      O = Rt(P.scale, x, A),
      V = s.value && je.getIsUnbound(s.value.config.type);
    let I = o.value.boundingBox;
    V &&
      (I = {
        x: -10 * tt,
        y: -10 * tt,
        width: (20 + e.value.spec.size.width) * tt,
        height: (20 + e.value.spec.size.height) * tt,
      });
    const U = {
        width: o.value.canvasSize.width / O,
        height: o.value.canvasSize.height / O,
      },
      D = {
        x: I.x + 0.5 * U.width,
        y: I.y + 0.5 * U.height,
        width: I.width - U.width,
        height: I.height - U.height,
      },
      E =
        V || ($.value && O > r.value.scale) ? wc(P.target, D) : r.value.target;
    return (
      D.width < 0 && (E.x = I.x + 0.5 * I.width),
      D.height < 0 && (E.y = I.y + 0.5 * I.height),
      { scale: O, target: E }
    );
  }
  const p = b(() => ({
      restrict: u,
      minScale: i.value,
      maxScale: a.value,
      mouseWheelScale: ee.mouseWheelScale,
    })),
    { zoom: m, changing: g, setZoom: v } = Zw(t, p),
    $ = b(
      () =>
        !Jt(r.value.scale, m.value.scale) ||
        !Jt(r.value.target.x, m.value.target.x) ||
        !Jt(r.value.target.y, m.value.target.y)
    );
  function k(P) {
    if (!l.value || !$.value) {
      const x = Bu(P.canvasSize, P.boundingBox);
      m.value = ue(x);
    }
    (o.value = P), (l.value = !0), (m.value = u(m.value));
  }
  function M() {
    v(r.value);
  }
  return (
    ae(g, (P) => {
      P && n.emit("zoomPan");
    }),
    ae(m, () => {
      _p.value = m.value.scale;
    }),
    {
      zoom: m,
      changingZoom: g,
      zoomIsDirty: $,
      resetZoom: M,
      handleCanvasPropsUpdate: k,
      sudokuEventBus: n,
    }
  );
}
function qw({
  constraintsToRender: t,
  cellsToRender: e,
  editingCells: n,
  selection: s,
}) {
  const { project: o, selectedConstraint: r } = ke(),
    l = b(() =>
      o.value
        .getEnabledConstraints()
        .filter((g) => g.config.type === _.FogLights)
    ),
    i = b(() =>
      o.value
        .getEnabledConstraints()
        .filter((g) => g.config.type === _.FogTriggers)
    ),
    a = b(() => t.value.find((g) => g.config.type === _.Regions)),
    u = b(() => {
      const g = new Set(o.value.helpers.cellIds.getAllCellIds());
      for (const v of l.value) He.deleteAll(g, v.config.lightCells);
      return g;
    }),
    p = b(() => l.value.flatMap((g) => g.config.lightCells));
  return {
    fogLayerData: b(() => {
      var g, v;
      if (
        !(
          l.value.length + i.value.length === 0 ||
          !Ne.showFog ||
          ((g = r.value) == null ? void 0 : g.config.type) === _.FogLights ||
          ((v = r.value) == null ? void 0 : v.config.type) === _.FogTriggers
        )
      )
        return {
          cells: e.value,
          fogCells: u.value,
          transparent: !!r.value,
          selection: n.value ? s.value : [],
          regions: a.value ? a.value.config.regions : void 0,
          triggers: Hd(
            i.value.map(($) => $.config),
            o.value.helpers
          ),
        };
    }),
    bulbCells: p,
  };
}
const Ip = S({
    __name: "FogLightsLayer",
    props: { lightBulbCells: {} },
    setup(t) {
      const e = t,
        n = b(() => new Set(e.lightBulbCells));
      return (s, o) => (
        d(),
        w(
          is,
          { cells: n.value },
          { default: f(() => [c(Bd, { opacity: "0.5" })]), _: 1 },
          8,
          ["cells"]
        )
      );
    },
  }),
  na = new Uo();
window.errorBus = na;
const Kw = ta({
    getDefault: () => {},
    createWorker: () => new Lo(),
    execute: async (t, e) => {
      const { invalidCells: n, thrownErrors: s } = await t.validateGrid(e);
      for (const o of s) na.emit("error", o);
      return n;
    },
  }),
  Xw = S({
    __name: "MagnifyingGlass",
    setup(t) {
      return (e, n) => (
        d(),
        w(
          he,
          {
            class: "MagnifyingGlass",
            viewBox: "0 0 16 16",
            stroke: "currentColor",
            "stroke-width": "2",
          },
          {
            default: f(
              () =>
                n[0] ||
                (n[0] = [
                  h(
                    "circle",
                    { cx: "7", cy: "7", r: "5", fill: "none" },
                    null,
                    -1
                  ),
                  h("path", { d: "m11 11 3 3" }, null, -1),
                ])
            ),
            _: 1,
          }
        )
      );
    },
  }),
  Yw = { class: "SudokuEditor" },
  Jw = S({
    __name: "SudokuEditor",
    setup(t) {
      const {
          project: e,
          selectedConstraint: n,
          lastCue: s,
          debuggingComponents: o,
          editMode: r,
          colorMarkingsPage: l,
          setCellEditMode: i,
        } = ke(),
        { solverInputData: a } = as(),
        u = up(),
        p = b(() => u.isDarkMode.value && ee.invertColorsInDarkMode),
        m = b(() => !n.value || n.value.config.type === _.Givens);
      ot("setEditor", (de) => {
        de.type !== ie.Constraint &&
          (de.type === r.value.type && de.type === ie.CellColor
            ? (l.value = ye.openNextPage())
            : i(de.type));
      });
      const g = b(() => (s.value ? s.value.affected.flat() : [])),
        { result: v, update: $ } = Kw();
      ae(
        () => [a.value, rt.value, Ne.highlightConflicts],
        async () => {
          !rt.value && Ne.highlightConflicts ? $(a.value) : (v.value = void 0);
        },
        { deep: !0, immediate: !0 }
      );
      const k = b(() =>
          v.value && v.value.size > 0
            ? e.value.cells.map((de) => {
                const ze = de.clone();
                return (ze.valid = !v.value.has(de.id)), ze;
              })
            : e.value.cells
        ),
        M = b(() =>
          e.value.allConstraints.filter((de) => {
            var ze;
            return (
              de.enabled &&
              de.id !== ((ze = n.value) == null ? void 0 : ze.id) &&
              de.config.type !== _.FogLights
            );
          })
        ),
        P = b(() => {
          if (!n.value) return Bn(0);
          const de = sh(n.value.id, "margins");
          return de ? de.value : je.getMargins(n.value.config, e.value.spec);
        }),
        x = j(),
        A = b(() => {
          var de;
          return (de = x.value) == null ? void 0 : de.$el;
        }),
        O = j(!1),
        {
          zoom: V,
          changingZoom: I,
          zoomIsDirty: U,
          resetZoom: D,
          handleCanvasPropsUpdate: N,
        } = Gw({
          element: A,
          project: e,
          sudokuEventBus: nt,
          selectedConstraint: n,
        });
      function E(de) {
        N({
          canvasSize: {
            width: de.canvasSize.width,
            height: de.canvasSize.height,
          },
          boundingBox: de.boundingBox,
        });
      }
      ae(I, () => {
        I.value
          ? ((O.value = !0), nt.emit("pointerCancel"))
          : requestAnimationFrame(() => {
              O.value = !1;
            });
      });
      function R(de) {
        O.value || nt.emit("pointerDown", de);
      }
      function W(de) {
        O.value || nt.emit("pointerMove", de);
      }
      function T(de) {
        O.value || nt.emit("pointerUp", de);
      }
      function Y(de) {
        I.value || nt.emit("pointerHold", de);
      }
      function J() {
        nt.emit("blur");
      }
      const re = j(new Set()),
        { fogLayerData: ce, bulbCells: ge } = qw({
          constraintsToRender: M,
          cellsToRender: k,
          editingCells: m,
          selection: re,
        });
      return (de, ze) => (
        d(),
        C("div", Yw, [
          c(
            Xs,
            {
              ref_key: "root",
              ref: x,
              cells: k.value,
              constraints: M.value,
              spec: y(e).spec,
              highlight: g.value,
              "minimum-margins": P.value,
              "include-editor-containers": "",
              tabindex: "0",
              zoom: y(V),
              "dark-mode-style": p.value,
              onPointerdown: R,
              onPointermove: W,
              onPointerup: T,
              onPointerhold: Y,
              onBlur: J,
              "onUpdate:canvasProps": E,
            },
            {
              grid: f(() => [
                m.value
                  ? (d(),
                    w(Nw, {
                      key: 0,
                      "onUpdate:selection":
                        ze[0] || (ze[0] = (Qs) => (re.value = Qs)),
                    }))
                  : z("", !0),
              ]),
              foreground: f(() => [
                y(ge)
                  ? (d(),
                    w(Ip, { key: 0, "light-bulb-cells": y(ge) }, null, 8, [
                      "light-bulb-cells",
                    ]))
                  : z("", !0),
              ]),
              aboveDigits: f(() => [
                y(ce)
                  ? (d(), w(jw, Vr(St({ key: 0 }, y(ce))), null, 16))
                  : z("", !0),
                y(o) ? (d(), w(Dw, { key: 1 })) : z("", !0),
              ]),
              _: 1,
            },
            8,
            [
              "cells",
              "constraints",
              "spec",
              "highlight",
              "minimum-margins",
              "zoom",
              "dark-mode-style",
            ]
          ),
          y(U)
            ? (d(),
              w(
                te,
                { key: 0, class: "resetZoom", "with-icon": "", onClick: y(D) },
                {
                  default: f(() => [
                    c(Xw),
                    ze[1] || (ze[1] = h("span", null, " Reset ", -1)),
                  ]),
                  _: 1,
                },
                8,
                ["onClick"]
              ))
            : z("", !0),
        ])
      );
    },
  }),
  Qw = B(Jw, [["__scopeId", "data-v-2d291ca2"]]),
  eb = { class: "AppTitle" },
  tb = { class: "wrapper" },
  nb = { class: "name" },
  sb = S({
    __name: "AppTitle",
    setup(t) {
      const e = "Sudoku Maker",
        n = "beta",
        s = "";
      return (o, r) => (
        d(),
        C("h1", eb, [
          h("span", tb, [
            r[0] || (r[0] = h("span", { class: "creator" }, "sirxemic’s", -1)),
            h("span", nb, X(y(e)), 1),
            y(n)
              ? (d(),
                C("small", { key: 0, class: Ae(y(s)) }, "(" + X(y(n)) + ")", 3))
              : z("", !0),
          ]),
        ])
      );
    },
  }),
  xp = B(sb, [["__scopeId", "data-v-31f370ed"]]),
  ob = S({
    __name: "ChangelogLink",
    setup(t) {
      const e = "2025.07.05-57cd531",
        n = vw();
      return (s, o) => (
        d(),
        C(
          "span",
          {
            class: "ChangelogLink",
            onClick: o[0] || (o[0] = st((r) => y(n).open(), ["prevent"])),
          },
          [G(s.$slots, "default", {}, () => [F("v" + X(y(e)), 1)], !0)]
        )
      );
    },
  }),
  sa = B(ob, [["__scopeId", "data-v-d984b6b6"]]),
  rb = S({
    __name: "KoFiLogo",
    setup(t) {
      return (e, n) => (
        d(),
        w(
          he,
          { class: "KoFiLogo", viewBox: "0 0 20 13.12", fill: "none" },
          {
            default: f(
              () =>
                n[0] ||
                (n[0] = [
                  h(
                    "path",
                    {
                      d: "M15.54 7.29a5.87 5.87 0 0 1-1.33 0V2.82h.9a2 2 0 0 1 2.06 2.09 2.21 2.21 0 0 1-1.63 2.38m3.87-3.15a4.34 4.34 0 0 0-1.78-2.8A4.8 4.8 0 0 0 14.91.5H1.17a.72.72 0 0 0-.67.71s0 .15 0 .15v9.33a2 2 0 0 0 2.08 1.91h9.28a3 3 0 0 0 .42-.05 2.65 2.65 0 0 0 1.87-2.91c3.44.19 5.87-2.24 5.26-5.47",
                      fill: "#fff",
                      stroke: "#323a47",
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                    },
                    null,
                    -1
                  ),
                  h(
                    "path",
                    {
                      d: "M7.24 10.08a.19.19 0 0 0 .24 0s2.19-2 3.17-3.14a2.1 2.1 0 0 0-.57-3.41 2.57 2.57 0 0 0-2.74.76A2.41 2.41 0 0 0 3.89 4 2.43 2.43 0 0 0 4 6.88c.49.72 2.8 2.78 3.15 3.12l.09.07",
                      fill: "#ff5e5b",
                    },
                    null,
                    -1
                  ),
                ])
            ),
            _: 1,
          }
        )
      );
    },
  }),
  lb = S({
    __name: "CoffeeLink",
    setup(t) {
      return (e, n) => (
        d(),
        w(
          Jn,
          { to: "https://www.ko-fi.com/sirxemic", variant: "simple" },
          {
            default: f(() => [
              c(rb),
              G(
                e.$slots,
                "default",
                {},
                () => [n[0] || (n[0] = F("Support me"))],
                !0
              ),
            ]),
            _: 3,
          }
        )
      );
    },
  }),
  Dp = B(lb, [["__scopeId", "data-v-650d33bb"]]),
  ib = { class: "header" },
  ab = { class: "version" },
  ub = S({
    __name: "AboutModal",
    emits: ["close"],
    setup(t) {
      const e = "Sudoku Maker",
        n = "2025.07.05-57cd531";
      return (s, o) => (
        d(),
        w(
          Bt,
          {
            class: "AboutModal",
            variant: "content",
            onClose: o[0] || (o[0] = (r) => s.$emit("close")),
          },
          {
            default: f(() => [
              h("div", ib, [c(xp), h("span", ab, "v" + X(y(n)), 1)]),
              o[13] || (o[13] = h("h3", null, "About", -1)),
              h("p", null, [
                F(
                  " Thanks for checking out " +
                    X(y(e)) +
                    "! This sudoku setting tool was made after discovering the joy and wonder that Sudoku variants can bring, by watching the Youtube channel ",
                  1
                ),
                c(
                  Jn,
                  { to: "https://www.youtube.com/c/CrackingTheCryptic" },
                  {
                    default: f(
                      () => o[1] || (o[1] = [F("Cracking the Cryptic")])
                    ),
                    _: 1,
                  }
                ),
                o[2] || (o[2] = F(". ")),
              ]),
              o[14] || (o[14] = h("h3", null, "Special thanks", -1)),
              h("p", null, [
                o[5] || (o[5] = F(" Much inspiration was taken from ")),
                c(
                  Jn,
                  { to: "https://f-puzzles.com/" },
                  {
                    default: f(() => o[3] || (o[3] = [F("F-puzzles.com")])),
                    _: 1,
                  }
                ),
                o[6] || (o[6] = F(" by Eric Fox and ")),
                c(
                  Jn,
                  { to: "https://sudokupad.app/" },
                  { default: f(() => o[4] || (o[4] = [F("SudokuPad")])), _: 1 }
                ),
                o[7] || (o[7] = F(" by Sven Neumann. ")),
              ]),
              o[15] ||
                (o[15] = h(
                  "p",
                  null,
                  " Also big thanks to the Sudoku Skunkworks community for their support and feedback in the closed alpha phase. ",
                  -1
                )),
              o[16] || (o[16] = h("h3", null, "Support", -1)),
              h("p", null, [
                o[9] ||
                  (o[9] = F(
                    " Like what you see and want to show your thanks? You could consider "
                  )),
                c(Dp, null, {
                  default: f(
                    () => o[8] || (o[8] = [F("supporting me on Ko-Fi.")])
                  ),
                  _: 1,
                }),
              ]),
              o[17] || (o[17] = h("h3", null, "Changelog", -1)),
              h("p", null, [
                o[11] || (o[11] = F(" Click ")),
                c(sa, null, {
                  default: f(() => o[10] || (o[10] = [F("here")])),
                  _: 1,
                }),
                o[12] || (o[12] = F(" to see the changelog. ")),
              ]),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  Mp = B(ub, [["__scopeId", "data-v-8f3aba34"]]),
  cb = S({
    __name: "About",
    props: { asLink: { type: Boolean } },
    setup(t) {
      const e = j(!1),
        n = "Sudoku Maker";
      return (s, o) => (
        d(),
        C(
          Z,
          null,
          [
            h(
              "button",
              {
                class: Ae(["AboutButton", { asLink: s.asLink }]),
                onClick: o[0] || (o[0] = (r) => (e.value = !0)),
              },
              [
                G(
                  s.$slots,
                  "default",
                  {},
                  () => [
                    c(_s),
                    c(Te, null, {
                      default: f(() => [F(" About " + X(y(n)), 1)]),
                      _: 1,
                    }),
                  ],
                  !0
                ),
              ],
              2
            ),
            c(Oe, null, {
              default: f(() => [
                e.value
                  ? (d(),
                    w(Mp, {
                      key: 0,
                      onClose: o[1] || (o[1] = (r) => (e.value = !1)),
                    }))
                  : z("", !0),
              ]),
              _: 1,
            }),
          ],
          64
        )
      );
    },
  }),
  Ap = B(cb, [["__scopeId", "data-v-d6ef926f"]]),
  db = { class: "AppFooter" },
  pb = S({
    __name: "AppFooter",
    props: { includeVersion: { type: Boolean } },
    setup(t) {
      const e = "Sudoku Maker";
      return (n, s) => (
        d(),
        C("div", db, [
          n.includeVersion
            ? (d(),
              C(
                Z,
                { key: 0 },
                [
                  h("span", null, [F(X(y(e)) + " ", 1), c(sa)]),
                  s[0] || (s[0] = h("span", { class: "dot" }, null, -1)),
                ],
                64
              ))
            : z("", !0),
          h("span", null, [
            s[2] || (s[2] = F(" by ")),
            c(
              Jn,
              { to: "//sirxemic.com/", variant: "simple" },
              { default: f(() => s[1] || (s[1] = [F(" sirxemic ")])), _: 1 }
            ),
          ]),
          s[3] || (s[3] = h("span", { class: "dot" }, null, -1)),
          c(Dp),
        ])
      );
    },
  }),
  oa = B(pb, [["__scopeId", "data-v-e6c254ea"]]),
  fb = ta({
    getDefault: () => [],
    createWorker: () => new Lo(),
    execute: (t, e) => t.getComponents(ue(e)),
  }),
  hb = { class: "ConstraintComponentList" },
  mb = { key: 0 },
  gb = S({
    __name: "ConstraintComponentList",
    props: { solverModel: {} },
    setup(t) {
      const e = t,
        { result: n, update: s } = fb();
      ae(
        () => e.solverModel,
        (l, i) => {
          Ce(l, i) || s(l);
        },
        { immediate: !0 }
      ),
        ae(
          n,
          () => {
            Cp(n.value);
          },
          { immediate: !0 }
        );
      const o = b(() => {
        const l = Fn(e.solverModel.spec),
          i = {};
        for (const a of n.value) {
          const u = a.type;
          (i[u] = i[u] || []),
            i[u].push({
              name: a.name,
              indices: a.cells.map((p) => l.naming.getCellName(p)).join(","),
              active: Fu(a),
              descriptor: a,
            });
        }
        return i;
      });
      function r(l) {
        wp(l, !Fu(l));
      }
      return (l, i) => (
        d(),
        C("div", hb, [
          y(n).length === 0 ? (d(), C("strong", mb, "Loading...")) : z("", !0),
          (d(!0),
          C(
            Z,
            null,
            se(
              o.value,
              (a, u) => (
                d(),
                C("div", { key: u, class: "group" }, [
                  h("h4", null, X(u), 1),
                  (d(!0),
                  C(
                    Z,
                    null,
                    se(
                      a,
                      (p) => (
                        d(),
                        C("div", { key: p.name, class: "item" }, [
                          c(
                            te,
                            {
                              active: p.active,
                              onClick: (m) => r(p.descriptor),
                            },
                            {
                              default: f(() => [
                                h("span", null, X(p.name), 1),
                                h("small", null, X(p.indices), 1),
                              ]),
                              _: 2,
                            },
                            1032,
                            ["active", "onClick"]
                          ),
                        ])
                      )
                    ),
                    128
                  )),
                ])
              )
            ),
            128
          )),
        ])
      );
    },
  }),
  vb = B(gb, [["__scopeId", "data-v-325c9851"]]),
  yb = S({
    __name: "AltToggledComponent",
    setup(t) {
      const e = j(!0);
      return (
        Dt(document, "keydown", (n) => {
          (n.key === "Alt" || n.key === "Control" || n.key === "Meta") &&
            (e.value = !1);
        }),
        Dt(document, "keyup", (n) => {
          (n.key === "Alt" || n.key === "Control" || n.key === "Meta") &&
            (e.value = !0);
        }),
        Dt(window, "blur", () => {
          e.value = !0;
        }),
        (n, s) =>
          e.value
            ? G(n.$slots, "default", { key: 0 })
            : G(n.$slots, "alt", { key: 1 })
      );
    },
  }),
  Cb = { components: { Icon: he } };
function wb(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "Brain", viewBox: "0 0 16 16" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M4.88 11.92c-.17.04-.35.07-.54.08-1.26.06-4.11-.36-4.15-3.43-.01-1.66.53-2.53 1.04-3 .28-.25.56-.4.77-.47.34-2.3 2.51-2.54 3.24-2.56a3.23 3.23 0 0 1 2.24-.98c.9 0 1.63.42 1.98.66a4.1 4.1 0 0 1 4.72 2.16c.43.25 1.52 1.03 1.52 2.4 0 .9-.29 1.39-.55 1.67l-.17.15a2.83 2.83 0 0 1-.96 3c-.3.8-1.42 2.74-3.8 2.74-2 0-2.88-1.01-3.2-1.51a5.63 5.63 0 0 1-2.14-.9Zm3.44-9.2a2.37 2.37 0 0 0-.84-.16c-.51 0-1.09.22-1.68.83a.5.5 0 0 1-.4.15s-2.3-.18-2.43 1.98v.02c0 .07-.03.53.26.81.12.13.32.2.6.2H5c.05 0 .2-.02.34-.07.08-.03.19-.08.18-.2a.5.5 0 0 1 1-.02c.02.5-.24.83-.57 1.03.23.3.4.68.37 1.05a.5.5 0 0 1-1-.06c.01-.14-.08-.27-.17-.39-.1-.13-.23-.26-.32-.34h-1c-.61 0-1.02-.21-1.3-.48a1.9 1.9 0 0 1-.48-.87c-.1.08-.23.19-.34.33-.3.4-.52 1.03-.5 2.03.02 2.25 2.16 2.48 3.09 2.44a2.1 2.1 0 0 0 1.78-1.19.5.5 0 0 1 .9.44 3.1 3.1 0 0 1-1 1.18c.18.1.38.19.6.27.43.15.93.23 1.4.04.82-.32 1.3-1 1.82-1.58.67-.72 1.4-1.34 2.65-1.37a.5.5 0 0 1 .03 1c-.93.02-1.45.51-1.94 1.05-.63.68-1.22 1.44-2.2 1.83l-.08.04c.36.3.97.63 1.96.63 1.94 0 2.78-1.7 2.9-2.17a.5.5 0 0 1 .23-.31s.75-.47.75-1.52c0-.54-.3-1.05-.7-1.44a2.22 2.22 0 0 0-1.54-.67H10.5c-.09 0-.3 0-.52.07-.17.04-.37.1-.39.3a.5.5 0 0 1-1-.1c.06-.56.43-.9.86-1.08a3 3 0 0 1 1.06-.18h.82c-.06-.2-.09-.44-.09-.78a.5.5 0 0 1 1 0c0 .23 0 .38.06.5.05.12.13.22.25.36a3.5 3.5 0 0 1 1.94 1.32c.12-.17.22-.44.22-.85 0-1.1-1.11-1.6-1.11-1.6a.5.5 0 0 1-.26-.26s-.75-1.84-2.8-1.84c-2.06 0-2.8 1.79-2.8 1.79a.5.5 0 0 1-.92-.38s.42-1.06 1.51-1.77Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const bb = B(Cb, [["render", wb]]),
  kb = { components: { Icon: he } };
function _b(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "BrainSlash", viewBox: "0 0 16 16" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "m13.9 11.9.6.6a.7.7 0 0 1-1 1l-11-11a.7.7 0 0 1 1-1l1.1 1.1c.26-.04.48-.06.64-.06a3.23 3.23 0 0 1 2.24-.98c.9 0 1.63.42 1.98.66a4.1 4.1 0 0 1 4.72 2.16c.43.25 1.52 1.03 1.52 2.4 0 .9-.29 1.39-.55 1.67l-.17.15a2.83 2.83 0 0 1-.96 3c-.03.09-.07.19-.13.3ZM5.53 3.53l1.25 1.25a.5.5 0 0 1 .03-.28s.42-1.06 1.51-1.77c-.24-.1-.52-.17-.84-.17-.51 0-1.09.22-1.68.83a.5.5 0 0 1-.27.14Zm1.65 1.65 1.67 1.67c.15-.2.36-.34.6-.43.4-.17.89-.19 1.05-.18h.82c-.06-.2-.09-.44-.09-.78a.5.5 0 0 1 1 0c0 .23 0 .38.06.5.05.12.13.22.25.36a3.5 3.5 0 0 1 1.95 1.31c.1-.16.21-.43.21-.84 0-1.1-1.11-1.6-1.11-1.6a.5.5 0 0 1-.26-.26s-.75-1.84-2.8-1.84c-2.06 0-2.8 1.79-2.8 1.79a.5.5 0 0 1-.55.3Zm2.4 2.4L11.1 9.1c.38-.18.81-.3 1.34-.31a.5.5 0 0 1 .03 1c-.22 0-.42.04-.6.09l1.25 1.24a.5.5 0 0 1 .22-.26s.75-.47.75-1.52c0-.54-.3-1.05-.7-1.44a2.22 2.22 0 0 0-1.54-.67H10.5c-.09 0-.3 0-.52.07-.16.04-.35.1-.39.29Zm2.74 6.15a3.8 3.8 0 0 1-2.1.6c-2 0-2.88-1-3.2-1.5a5.63 5.63 0 0 1-2.14-.9c-.17.03-.35.06-.54.07-1.26.06-4.11-.36-4.15-3.43-.01-1.66.53-2.53 1.04-3 .28-.25.56-.4.77-.47.07-.5.24-.9.45-1.23l.74.74c-.12.24-.2.54-.23.9v.03c0 .07-.03.53.26.81.13.13.32.2.6.2H5c.03 0 .07 0 .13-.02l.96.97c.16.26.25.55.23.84a.5.5 0 0 1-1-.06c.01-.14-.08-.27-.17-.39-.1-.13-.23-.26-.32-.34h-1c-.61 0-1.02-.21-1.3-.48a1.9 1.9 0 0 1-.48-.87c-.1.08-.23.19-.34.33-.3.4-.52 1.03-.5 2.03.02 2.25 2.17 2.48 3.09 2.44a2.1 2.1 0 0 0 1.78-1.19.5.5 0 0 1 .9.44 3.1 3.1 0 0 1-1 1.18c.18.1.39.19.6.27.44.15.93.23 1.4.04.57-.22.97-.61 1.33-1.02l.7.7c-.45.5-.96.97-1.66 1.25l-.1.04a3 3 0 0 0 1.97.63c.55 0 1-.13 1.38-.34l.73.73Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Pp = B(kb, [["render", _b]]),
  $b = { components: { Icon: he } };
function Sb(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      {
        class: "Eye",
        viewBox: "0 0 16 16",
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        "stroke-linejoin": "round",
        "stroke-miterlimit": "2",
      },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M.041 8.782C-.014 8.598 0 8 0 8s1.229-6 8-6c6.665 0 7.96 5.814 7.999 5.996L16 8s.012.6-.043.784l.002-.002S14.491 14 8 14 .041 8.782.041 8.782ZM4.05 4.936A5.002 5.002 0 0 0 8 13h-.062c-4.83-.03-6.425-3.543-6.837-4.778A6.735 6.735 0 0 1 4.05 4.936Zm7.9 0a6.735 6.735 0 0 1 2.949 3.286C14.487 9.457 12.893 12.97 8.062 13H8a5.002 5.002 0 0 0 3.95-8.064ZM8 6a2 2 0 1 1-.001 4.001A2 2 0 0 1 8 6Zm0-3h-.062H8Zm0 0h.062H8Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Lp = B($b, [["render", Sb]]),
  Ib = { components: { Icon: he } };
function xb(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      {
        class: "EyeSlash",
        viewBox: "0 0 16 16",
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        "stroke-linejoin": "round",
        "stroke-miterlimit": "2",
      },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M4.608 2.608C5.545 2.233 6.665 2 8 2c6.665 0 7.96 5.814 7.999 5.996L16 8s.012.6-.043.784l.002-.002s-.47 1.671-2.055 3.122l.596.596a.707.707 0 0 1-1 1l-11-11a.707.707 0 0 1 1-1l1.108 1.108ZM10 8a2 2 0 0 0-2-2l2 2Zm3.1 3.1a7.302 7.302 0 0 0 1.799-2.878 6.735 6.735 0 0 0-2.949-3.286A4.975 4.975 0 0 1 13 8c0 .866-.221 1.681-.609 2.392l.709.708Zm-1.264 2.151C10.811 13.703 9.548 14 8 14 1.509 14 .041 8.782.041 8.782-.014 8.598 0 8 0 8s.479-2.34 2.488-4.097l1.229 1.229a6.739 6.739 0 0 0-2.616 3.09C1.513 9.457 3.108 12.97 7.938 13a5.003 5.003 0 0 1-4.109-7.756l2.239 2.238a2 2 0 0 0 2.45 2.45l2.239 2.239c-.775.513-1.7.817-2.695.829 1.17-.007 2.15-.219 2.97-.553l.804.804Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Ep = B(Ib, [["render", xb]]),
  Db = S({
    __name: "ConstraintActions",
    props: { constraint: {} },
    emits: [
      "rename",
      "edit",
      "duplicate",
      "toggle",
      "toggleSolver",
      "remove",
      "editRaw",
    ],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        { project: o, updateConstraint: r } = ke(),
        l = b(() => je.getActions(n.constraint.config, o.value.spec)),
        i = b(() => je.getLabel(n.constraint.config, o.value.spec)),
        a = b(() => !je.getIsUnique(n.constraint.config.type)),
        u = b(() => n.constraint.config.type !== _.Givens),
        p = b(() => !je.getIsIgnoredBySolver(n.constraint.config.type)),
        m = b(() => ee.debug && je.getIsOpenable(n.constraint.config.type)),
        g = j(!1),
        v = j(n.constraint.name || i.value);
      ae(n, () => {
        v.value = n.constraint.name || i.value;
      });
      function $() {
        v.value !== "" &&
          ((g.value = !1),
          v.value === i.value ? s("rename", void 0) : s("rename", v.value));
      }
      function k() {
        (g.value = !1), (v.value = n.constraint.name || i.value);
      }
      function M() {
        v.value = i.value;
      }
      function P(x) {
        const A = x.callback(n.constraint.config, o.value.spec);
        r(
          n.constraint,
          (O) => {
            O.config = A;
          },
          x.label
        );
      }
      return (x, A) => (
        d(),
        C(
          Z,
          null,
          [
            c(yb, null, {
              alt: f(() => [
                c(
                  te,
                  {
                    class: "ConstraintActions",
                    icon: "",
                    variant: "borderless",
                    size: "small",
                    onClick: A[7] || (A[7] = (O) => x.$emit("remove")),
                  },
                  { default: f(() => [c(xo)]), _: 1 }
                ),
              ]),
              default: f(() => [
                c(
                  sl,
                  { class: "ConstraintActions", variant: "borderless" },
                  {
                    default: f(() => [
                      c(
                        Ge,
                        { onClick: A[0] || (A[0] = (O) => (g.value = !0)) },
                        {
                          default: f(() => [
                            c(ls),
                            A[9] || (A[9] = F(" Rename ")),
                          ]),
                          _: 1,
                        }
                      ),
                      x.constraint.config.type === y(_).Custom
                        ? (d(),
                          w(
                            Ge,
                            {
                              key: 0,
                              onClick: A[1] || (A[1] = (O) => x.$emit("edit")),
                            },
                            {
                              default: f(() => [
                                c(Mo),
                                A[10] || (A[10] = F(" Modify ")),
                              ]),
                              _: 1,
                            }
                          ))
                        : z("", !0),
                      a.value
                        ? (d(),
                          w(
                            Ge,
                            {
                              key: 1,
                              onClick:
                                A[2] || (A[2] = (O) => x.$emit("duplicate")),
                            },
                            {
                              default: f(() => [
                                c(Ni),
                                A[11] || (A[11] = F(" Duplicate ")),
                              ]),
                              _: 1,
                            }
                          ))
                        : z("", !0),
                      u.value
                        ? (d(),
                          w(
                            Ge,
                            {
                              key: 2,
                              onClick:
                                A[3] || (A[3] = (O) => x.$emit("toggle")),
                            },
                            {
                              default: f(() => [
                                x.constraint.enabled
                                  ? (d(), w(Ep, { key: 0 }))
                                  : (d(), w(Lp, { key: 1 })),
                                F(
                                  " " +
                                    X(
                                      x.constraint.enabled
                                        ? "Disable"
                                        : "Enable"
                                    ),
                                  1
                                ),
                              ]),
                              _: 1,
                            }
                          ))
                        : z("", !0),
                      p.value
                        ? (d(),
                          w(
                            Ge,
                            {
                              key: 3,
                              onClick:
                                A[4] || (A[4] = (O) => x.$emit("toggleSolver")),
                            },
                            {
                              default: f(() => [
                                x.constraint.solverIgnored
                                  ? (d(), w(bb, { key: 1 }))
                                  : (d(), w(Pp, { key: 0 })),
                                F(
                                  " " +
                                    X(
                                      x.constraint.solverIgnored
                                        ? "Enable for solver"
                                        : "Disable for solver"
                                    ),
                                  1
                                ),
                              ]),
                              _: 1,
                            }
                          ))
                        : z("", !0),
                      l.value.length > 0
                        ? (d(),
                          C(
                            Z,
                            { key: 4 },
                            [
                              A[12] || (A[12] = h("hr", null, null, -1)),
                              (d(!0),
                              C(
                                Z,
                                null,
                                se(
                                  l.value,
                                  (O, V) => (
                                    d(),
                                    w(
                                      Ge,
                                      {
                                        key: V,
                                        disabled: O.disabled,
                                        onClick: (I) => P(O),
                                      },
                                      {
                                        default: f(() => [
                                          (d(), w(qe(O.icon))),
                                          F(" " + X(O.label), 1),
                                        ]),
                                        _: 2,
                                      },
                                      1032,
                                      ["disabled", "onClick"]
                                    )
                                  )
                                ),
                                128
                              )),
                            ],
                            64
                          ))
                        : z("", !0),
                      m.value
                        ? (d(),
                          C(
                            Z,
                            { key: 5 },
                            [
                              A[14] || (A[14] = h("hr", null, null, -1)),
                              c(
                                Ge,
                                {
                                  onClick:
                                    A[5] || (A[5] = (O) => x.$emit("editRaw")),
                                },
                                {
                                  default: f(() => [
                                    c(Mo),
                                    A[13] || (A[13] = F(" Edit data as JSON ")),
                                  ]),
                                  _: 1,
                                }
                              ),
                            ],
                            64
                          ))
                        : z("", !0),
                      A[16] || (A[16] = h("hr", null, null, -1)),
                      c(
                        Ge,
                        { onClick: A[6] || (A[6] = (O) => x.$emit("remove")) },
                        {
                          default: f(() => [
                            c(xo),
                            A[15] || (A[15] = F(" Delete ")),
                          ]),
                          _: 1,
                        }
                      ),
                    ]),
                    _: 1,
                  }
                ),
              ]),
              _: 1,
            }),
            c(Oe, null, {
              default: f(() => [
                g.value
                  ? (d(),
                    w(
                      Bt,
                      { key: 0, variant: "content", onClose: k },
                      {
                        default: f(() => [
                          h(
                            "form",
                            { onSubmit: st($, ["prevent"]) },
                            [
                              c(
                                ve,
                                { label: "New name", vertical: "" },
                                {
                                  default: f(() => [
                                    c(
                                      vt,
                                      {
                                        value: v.value,
                                        "onUpdate:value":
                                          A[8] || (A[8] = (O) => (v.value = O)),
                                        autofocus: "",
                                      },
                                      null,
                                      8,
                                      ["value"]
                                    ),
                                  ]),
                                  _: 1,
                                }
                              ),
                              c(Ft, null, {
                                default: f(() => [
                                  c(
                                    te,
                                    { onClick: k },
                                    {
                                      default: f(
                                        () => A[17] || (A[17] = [F(" Cancel ")])
                                      ),
                                      _: 1,
                                    }
                                  ),
                                  c(Je),
                                  c(Yt, null, {
                                    default: f(() => [
                                      v.value !== i.value
                                        ? (d(),
                                          w(
                                            te,
                                            { key: 0, onClick: M },
                                            {
                                              default: f(
                                                () =>
                                                  A[18] ||
                                                  (A[18] = [F(" Reset ")])
                                              ),
                                              _: 1,
                                            }
                                          ))
                                        : z("", !0),
                                      c(
                                        te,
                                        { disabled: !v.value, type: "submit" },
                                        {
                                          default: f(
                                            () =>
                                              A[19] || (A[19] = [F(" Update ")])
                                          ),
                                          _: 1,
                                        },
                                        8,
                                        ["disabled"]
                                      ),
                                    ]),
                                    _: 1,
                                  }),
                                ]),
                                _: 1,
                              }),
                            ],
                            32
                          ),
                        ]),
                        _: 1,
                      }
                    ))
                  : z("", !0),
              ]),
              _: 1,
            }),
          ],
          64
        )
      );
    },
  }),
  Fp = B(Db, [["__scopeId", "data-v-f5b453ce"]]),
  Mb = { class: "tooltipMessage" },
  Ab = S({
    __name: "ConstraintValidationIcon",
    props: { constraint: {}, showWarnings: { type: Boolean } },
    setup(t) {
      const e = t,
        { constraintValidations: n } = as(),
        s = b(() => n.value.get(e.constraint.id) ?? { type: In.Valid }),
        o = b(() =>
          e.constraint.solverIgnored && e.constraint.enabled
            ? "solver"
            : s.value.type === In.Error
            ? "error"
            : s.value.type === In.Warning
            ? "warning"
            : "info"
        ),
        r = b(() =>
          e.constraint.solverIgnored && e.constraint.enabled
            ? !0
            : s.value.type === In.Valid
            ? !1
            : s.value.type === In.Error
            ? !0
            : e.showWarnings
        ),
        l = b(() =>
          e.constraint.solverIgnored && e.constraint.enabled
            ? {
                prefix: "\n".join([
                  `The solver will ignore this constraint.`,
                  ``,
                ]),
                message: "\n".join([
                  `This constraint was manually set to be ignored by the solver.`,
                  ``,
                ]),
              }
            : s.value.type === In.Error
            ? {
                prefix: "\n".join([
                  `The solver will ignore this constraint.`,
                  ``,
                ]),
                message: `Reason: ${s.value.message}`,
              }
            : s.value.type === In.Warning
            ? { prefix: "Warning:", message: s.value.message }
            : { prefix: "Note:", message: s.value.message }
        );
      return (i, a) =>
        r.value
          ? (d(),
            C(
              "div",
              {
                key: 0,
                class: "ConstraintValidationIcon",
                onTouchstart: a[0] || (a[0] = st(() => {}, ["prevent"])),
              },
              [
                o.value === "solver"
                  ? (d(), w(Pp, { key: 0 }))
                  : o.value === "warning"
                  ? (d(), w(xd, { key: 1 }))
                  : o.value === "error"
                  ? (d(), w(Vo, { key: 2 }))
                  : o.value === "info"
                  ? (d(), w(_s, { key: 3 }))
                  : z("", !0),
                c(
                  Te,
                  { "trigger-on-touch": "" },
                  {
                    default: f(() => [
                      h("span", Mb, [
                        h("strong", null, X(l.value.prefix), 1),
                        F(" " + X(l.value.message), 1),
                      ]),
                    ]),
                    _: 1,
                  }
                ),
              ],
              32
            ))
          : z("", !0);
    },
  }),
  Bp = B(Ab, [["__scopeId", "data-v-bac459e4"]]),
  Pb = { class: "name" },
  Lb = { class: "background" },
  Eb = { key: 0, class: "editor" },
  Fb = { class: "wrapper" },
  Bb = S({
    __name: "ConstraintEditorUI",
    props: {
      constraint: {},
      selected: { type: Boolean },
      open: { type: Boolean },
      editorInitParams: {},
    },
    emits: [
      "edit",
      "rename",
      "duplicate",
      "toggle",
      "toggleSolver",
      "remove",
      "editRaw",
    ],
    setup(t) {
      const e = t,
        { project: n } = ke(),
        { open: s } = gp(),
        o = b(() => !e.constraint.enabled),
        r = b(
          () =>
            e.constraint.name || je.getLabel(e.constraint.config, n.value.spec)
        ),
        l = b(() => je.getPreview(e.constraint.config.type)),
        i = b(() => je.getEditor(e.constraint.config.type)),
        a = b(() => i.value && e.constraint.config.type !== _.Givens),
        u = b(
          () =>
            e.constraint.enabled &&
            (i.value !== void 0 || je.getIsSelectable(e.constraint.config.type))
        );
      return (p, m) => (
        d(),
        C(
          "div",
          {
            class: Ae([
              "ConstraintEditorUI",
              { selected: p.selected, clickable: u.value, disabled: o.value },
            ]),
          },
          [
            h(
              "div",
              {
                class: "main",
                onClick: m[7] || (m[7] = (g) => u.value && p.$emit("edit")),
              },
              [
                (d(),
                w(
                  qe(l.value),
                  {
                    constraint: p.constraint.config,
                    context: y(n),
                    class: "image",
                  },
                  null,
                  8,
                  ["constraint", "context"]
                )),
                h("h4", Pb, [
                  h("span", Lb, [h("span", null, X(r.value), 1)]),
                  c(
                    Bp,
                    { constraint: p.constraint, "show-warnings": !p.selected },
                    null,
                    8,
                    ["constraint", "show-warnings"]
                  ),
                ]),
                c(
                  Fp,
                  {
                    constraint: p.constraint,
                    onRename: m[0] || (m[0] = (g) => p.$emit("rename", g)),
                    onEdit: m[1] || (m[1] = (g) => y(s)(p.constraint)),
                    onDuplicate: m[2] || (m[2] = (g) => p.$emit("duplicate")),
                    onToggle: m[3] || (m[3] = (g) => p.$emit("toggle")),
                    onToggleSolver:
                      m[4] || (m[4] = (g) => p.$emit("toggleSolver")),
                    onRemove: m[5] || (m[5] = (g) => p.$emit("remove")),
                    onEditRaw: m[6] || (m[6] = (g) => p.$emit("editRaw")),
                  },
                  null,
                  8,
                  ["constraint"]
                ),
              ]
            ),
            a.value
              ? (d(),
                w(
                  ns,
                  { key: 0 },
                  {
                    default: f(() => [
                      p.constraint.enabled && p.open
                        ? (d(),
                          C("div", Eb, [
                            h("div", Fb, [
                              (d(),
                              w(
                                qe(i.value),
                                {
                                  constraint: p.constraint,
                                  "init-params": p.editorInitParams,
                                  onOpenCustomConstraintEditor:
                                    m[8] || (m[8] = (g) => y(s)(p.constraint)),
                                },
                                null,
                                40,
                                ["constraint", "init-params"]
                              )),
                            ]),
                          ]))
                        : z("", !0),
                    ]),
                    _: 1,
                  }
                ))
              : z("", !0),
          ],
          2
        )
      );
    },
  }),
  zb = B(Bb, [["__scopeId", "data-v-6ecc11d7"]]),
  Rb = S({
    components: { Cross: Ks },
    props: {
      option: { type: Object, required: !0 },
      project: { type: Object, required: !0 },
    },
  }),
  Ob = { class: "ConstraintRow" },
  Nb = { class: "content" };
function Tb(t, e, n, s, o, r) {
  return (
    d(),
    C("div", Ob, [
      (d(),
      w(
        qe(t.option.preview),
        { constraint: t.option.config, context: t.project, class: "image" },
        null,
        8,
        ["constraint", "context"]
      )),
      h("div", Nb, [
        h("h4", null, X(t.option.name), 1),
        h("p", null, X(t.option.description), 1),
      ]),
    ])
  );
}
const Vb = B(Rb, [
    ["render", Tb],
    ["__scopeId", "data-v-4cc0c8c9"],
  ]),
  jb = S({
    components: { TabStrip: ts, Popover: el, TextInput: vt, ConstraintRow: Vb },
    props: {
      target: { type: HTMLElement, required: !0 },
      options: { type: Array, required: !0 },
      project: { type: Object, required: !0 },
    },
    emits: { close: () => !0, select: (t) => !0 },
    data() {
      return { search: "", activeIndex: 0 };
    },
    computed: {
      filteredOptions() {
        var o;
        const t = [...this.search.matchAll(/[a-z]/gi)],
          e = new RegExp(t.join("(.*?)"), "i"),
          n = new RegExp(t.join(""), "i"),
          s = [];
        for (const r of this.options) {
          const l = r.tags ? ` ${r.tags.join(" ")}` : "",
            i = (r.name + l).match(e);
          if (!i) continue;
          const a = i.slice(1).join("").length,
            u = r.name.split(/\s+/g);
          let p = 1e4;
          for (let m = 0; m < u.length; m++) {
            const g = (o = u[m].match(n)) == null ? void 0 : o.index;
            if (g !== void 0) {
              p = m * 20 + g;
              break;
            }
          }
          s.push({ ...r, substringPosition: p, fuzzyAmount: a });
        }
        return s.sort((r, l) => {
          let i = r.fuzzyAmount - l.fuzzyAmount;
          return i !== 0 ||
            ((i = r.substringPosition - l.substringPosition), i !== 0)
            ? i
            : r.key - l.key;
        });
      },
    },
    watch: {
      filteredOptions() {
        this.activeIndex = 0;
      },
    },
    methods: {
      navigate(t) {
        this.activeIndex =
          (this.activeIndex + this.filteredOptions.length + t) %
          this.filteredOptions.length;
        const e = this.$refs.container.scrollTop,
          n = this.$refs.container.offsetHeight;
        this.$nextTick(() => {
          const s =
            this.$el.querySelectorAll(".ConstraintRow")[this.activeIndex];
          s.offsetTop + s.offsetHeight > e + n
            ? s.scrollIntoView(!1)
            : s.offsetTop < e && s.scrollIntoView(!0);
        });
      },
      select() {
        this.filteredOptions[this.activeIndex] &&
          this.$emit("select", this.filteredOptions[this.activeIndex].key);
      },
    },
  }),
  Ub = { class: "searchWrapper" },
  Hb = { ref: "container", class: "container" },
  Wb = { key: 0, class: "noResults" };
function Zb(t, e, n, s, o, r) {
  const l = H("TextInput"),
    i = H("TabStrip"),
    a = H("ConstraintRow"),
    u = H("Popover");
  return (
    d(),
    w(
      u,
      {
        class: "ConstraintPicker",
        target: t.target,
        align: "stretch",
        overlay: "",
        tabindex: "0",
        onClose: e[3] || (e[3] = (p) => t.$emit("close")),
        onKeydown: e[4] || (e[4] = Dn((p) => t.$emit("close"), ["esc"])),
      },
      {
        default: f(() => [
          h("div", Ub, [
            c(
              l,
              {
                value: t.search,
                "onUpdate:value": e[0] || (e[0] = (p) => (t.search = p)),
                placeholder: "Search elements",
                autofocus: "",
                onKeydown: [
                  e[1] || (e[1] = Dn((p) => t.navigate(1), ["down"])),
                  e[2] || (e[2] = Dn((p) => t.navigate(-1), ["up"])),
                  Dn(t.select, ["enter"]),
                ],
              },
              null,
              8,
              ["value", "onKeydown"]
            ),
          ]),
          h("div", null, [z("", !0)]),
          h(
            "div",
            Hb,
            [
              (d(!0),
              C(
                Z,
                null,
                se(
                  t.filteredOptions,
                  (p, m) => (
                    d(),
                    w(
                      a,
                      {
                        key: p.key,
                        option: p,
                        project: t.project,
                        class: Ae({ navigationActive: t.activeIndex === m }),
                        onClick: (g) => t.$emit("select", p.key),
                        onMousemove: (g) => (t.activeIndex = m),
                        onMouseenter: (g) => (t.activeIndex = m),
                      },
                      null,
                      8,
                      [
                        "option",
                        "project",
                        "class",
                        "onClick",
                        "onMousemove",
                        "onMouseenter",
                      ]
                    )
                  )
                ),
                128
              )),
              t.filteredOptions.length === 0
                ? (d(),
                  C("div", Wb, [
                    e[5] || (e[5] = F(" No registered constraints match ")),
                    h("strong", null, X(t.search), 1),
                    e[6] || (e[6] = F(". ")),
                  ]))
                : z("", !0),
            ],
            512
          ),
        ]),
        _: 1,
      },
      8,
      ["target"]
    )
  );
}
const zp = B(jb, [
  ["render", Zb],
  ["__scopeId", "data-v-192538e8"],
]);
function Gb(t) {
  return t.size.width !== t.size.height || t.size.width > t.digitCount
    ? []
    : [
        {
          params: { type: _.DiagonalMinus },
          description: "Digits cannot repeat along the negative diagonal",
        },
        {
          params: { type: _.DiagonalPlus },
          description: "Digits cannot repeat along the positive diagonal",
        },
      ];
}
function qb(t) {
  switch (t.type) {
    case Ie.Sudoku:
      return [
        {
          description: `Cells with the same position within the boxes contain all the numbers 1 to ${t.maxDigit}`,
          params: { type: _.DisjointGroups },
        },
      ];
    default:
      return [
        {
          description:
            "Cells with the same position within the boxes contain all different digits",
          params: { type: _.DisjointGroups },
        },
      ];
  }
}
function Kb(t) {
  const e = [];
  return (
    (t.type === Ie.Sudoku || t.digitCount >= t.size.height) &&
      e.push({
        description:
          "A marked cell in row X indicates the row where X appears in the column.",
        params: { type: _.RowIndexer },
      }),
    (t.type === Ie.Sudoku || t.digitCount >= t.size.width) &&
      e.push({
        description:
          "A marked cell in column X indicates the column where X appears in the row.",
        params: { type: _.ColumnIndexer },
      }),
    e
  );
}
function Xb(t) {
  return [
    {
      description: `Digits along a lockout line must not be between the digits on the circled ends of the line, which have a difference of at least ${Math.floor(
        t.digitCount / 2
      )}`,
      params: { type: _.LockoutLines },
    },
  ];
}
function Yb(t, e) {
  return [
    {
      description:
        "Digits on a palindrome line read the same forwards and backwards",
      params: { type: _.Palindrome, style: { color: Mc(e) } },
    },
  ];
}
function Jb(t, e) {
  return [
    {
      description:
        "Every renban line contains a set of consecutive digits in any order, without repeats",
      params: { type: _.Renban, style: { color: I0(e) } },
    },
  ];
}
function Qb(t) {
  return t.type === Ie.Custom &&
    t.digitCount >= t.size.width &&
    t.digitCount >= t.size.height
    ? [
        {
          description: "All rows and columns must contain different digits.",
          params: { type: _.SudokuRules },
        },
      ]
    : [];
}
function ek(t) {
  return [
    {
      params: { type: _.SandwichSums },
      description: `Digits between ${t.minDigit} and ${t.maxDigit} in the indicated row or column must sum to the indicated value`,
    },
  ];
}
function tk(t, e) {
  return [
    {
      description:
        "Sequence lines contain digits in order with a constant difference. E.g. 1-2-3, 2-5-8 or even 3-3-3...",
      params: { type: _.Sequence, style: { color: Mc(e) } },
    },
  ];
}
function nk(t) {
  const { minDigit: e, maxDigit: n, digitCount: s } = t,
    o = new No(t),
    r = () => {
      const a = o.createEvensDigitSet(),
        u = o.createOddsDigitSet();
      return {
        description:
          "Every pair of consecutive cells along a parity line must contain an even and odd digit.",
        params: {
          type: _.EntropyLines,
          groups: [Vt(a), Vt(u)],
          style: { color: "#ff6666" },
        },
      };
    },
    l = () => {
      let a;
      switch (s) {
        case 6:
          a = [
            [1, 2],
            [3, 4],
            [5, 6],
          ];
          break;
        case 7:
          a = [
            [1, 2],
            [3, 4, 5],
            [6, 7],
          ];
          break;
        case 8:
          a = [
            [1, 2],
            [3, 4],
            [5, 6],
            [7, 8],
          ];
          break;
        case 9:
          a = [
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9],
          ];
          break;
        default:
          a = [];
      }
      return (
        e === 0 && (a = a.map((u) => u.map((p) => p - 1))),
        {
          description:
            s === 8
              ? `Every ${a.length} consecutive cells along an entropic line must contain one from (${a[0]}), one from (${a[1]}), one from (${a[2]}) and one from (${a[3]}).`
              : `Every ${a.length} consecutive cells along an entropic line must contain a low digit (${a[0]}), middle digit (${a[1]}) and high digit (${a[2]}).`,
          params: {
            type: _.EntropyLines,
            groups: a.map((u) => Vt(u)),
            style: { color: Dc },
          },
        }
      );
    },
    i = (a) => {
      const u = Array.from({ length: a }, () => []);
      for (let p = e; p <= n; p++) u[p % a].push(p);
      return {
        description: `Every ${a} consecutive cells along a ${a}-modular line must contain a complete set of residuals modulo ${a}. i.e: ${At(
          u.map((p) => `one from (${p})`)
        )}.`,
        params: {
          type: _.EntropyLines,
          groups: u.map((p) => Vt(p)),
          style: { color: $0 },
        },
      };
    };
  switch (s) {
    case 7:
      return [l(), i(3), r()];
    case 6:
    case 9:
      return [l(), i(3), r()];
    default:
      return [i(3), r()];
  }
}
function sk(t) {
  const { minDigit: e, maxDigit: n, digitCount: s } = t,
    o = () => {
      const a = [],
        u = [];
      for (let p = e; p <= n; p++)
        p < (e + n) / 2 && a.push(p), p > (e + n) / 2 && u.push(p);
      return {
        description: `Every 2x2 square of cells must contain a low (${a}) and high (${u}) digit.`,
        params: { type: _.GlobalEntropy, groups: [Vt(u), Vt(a)] },
      };
    },
    r = () => {
      const a = [
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8],
      ].map((u) => u.map((p) => p + e));
      return {
        description: `Every 2x2 square of cells must contain a low digit (${a[0]}), middle digit (${a[1]}) and high digit (${a[2]}).`,
        params: { type: _.GlobalEntropy, groups: a.map((u) => Vt(u)) },
      };
    },
    l = () => {
      const a = [
        [0, 3, 6],
        [1, 4, 7],
        [2, 5, 8],
      ].map((u) => u.map((p) => p + e));
      return {
        description: `Every 2x2 square of cells must contain a digit from (${a[0]}), a digit from (${a[1]}) and a digit from (${a[2]}).`,
        params: { type: _.GlobalEntropy, groups: a.map((u) => Vt(u)) },
      };
    },
    i = () => ({
      description:
        "Every 2x2 square of cells must contain at least 1 digit of every specified group.",
      params: { type: _.GlobalEntropy },
    });
  switch (s) {
    case 4:
    case 6:
    case 8:
      return [o()];
    case 9:
      return [r(), l()];
    default:
      return [i()];
  }
}
function ok(t, e) {
  return [
    {
      description:
        "Numbers on a thermometer strictly increase as they move away from the bulb",
      params: { type: _.Thermometer, style: { color: Pa(e) } },
    },
    {
      description:
        "Numbers on a slow thermometer increase or stay the same as they move away from the bulb",
      params: { type: _.Thermometer, slow: !0, style: { color: Pa(e) } },
    },
  ];
}
function rk(t) {
  return [
    {
      description: `Two cells connected by a German whisper line must have a difference of at least ${Math.floor(
        (t.digitCount + 1) / 2
      )}.`,
      params: {
        type: _.Whisper,
        minDifference: Math.floor((t.digitCount + 1) / 2),
        style: { color: xc },
      },
    },
    {
      description: `Two cells connected by a Dutch whisper line must have a difference of at least ${Math.floor(
        (t.digitCount - 1) / 2
      )}.`,
      params: {
        type: _.Whisper,
        minDifference: Math.floor((t.digitCount - 1) / 2),
        style: { color: k0 },
      },
    },
  ];
}
const lk = [
  Qb,
  {
    params: { type: _.Givens },
    description: "Prefill some cells with digits.",
  },
  {
    params: { type: _.Regions },
    description: "Digits cannot repeat in marked regions.",
  },
  Gb,
  {
    params: { type: _.DifferentValues },
    description: "Digits cannot repeat in the marked cells",
  },
  {
    params: { type: _.Antiking },
    description:
      "Cells seperated by a king’s move in chess cannot have the same digit.",
  },
  {
    params: { type: _.Antiknight },
    description:
      "Cells seperated by a knight’s move in chess cannot have the same digit.",
  },
  qb,
  {
    params: { type: _.Nonconsecutive },
    description:
      "Cells that are orthogonally adjacent cannot contain consecutive digits.",
  },
  {
    params: { type: _.Even },
    description: "Cells with these squares must contain even numbers.",
  },
  {
    params: { type: _.Odd },
    description: "Cells with these circles must contain odd numbers.",
  },
  {
    params: { type: _.Maximum },
    description:
      "Cells with this constraint are greater than all adjacent cells without this constraint.",
  },
  {
    params: { type: _.Minimum },
    description:
      "Cells with this constraint are smaller than all adjacent cells without this constraint.",
  },
  {
    params: { type: _.Difference },
    description:
      "Cells joined by a white dot must have a difference of the indicated number. If there is no indicated number, the difference will be assumed to be 1.",
  },
  {
    params: { type: _.Ratio },
    description:
      "Cells joined by a black dot must have a ratio of the indicated number. If there is no indicated number, the ratio will be assumed to be 2.",
  },
  {
    params: { type: _.XV },
    description: "Cells joined by an X or V must sum to 10 (X) or 5 (V).",
  },
  ok,
  {
    params: { type: _.KillerCages },
    description:
      "Digits in cages must sum to the number in the top-left corner and cannot repeat",
  },
  {
    params: { type: _.Clone },
    description:
      "The arrangement of digits in a part of the sudoku must be the same elsewhere",
  },
  {
    params: { type: _.Quadruple },
    description:
      "Every digit in a circle has to be assigned to one of the surrounding cells.",
  },
  {
    params: { type: _.LookAndSayCages },
    description:
      "Read the clue out loud, which describes the nature of the cage. E.g. 1522 says there is “one five and two two(s)” in the cage.",
  },
  Jb,
  rk,
  Yb,
  {
    params: { type: _.BetweenLines },
    description:
      "Digits along a between line must be between the digits on the circled ends of the line.",
  },
  {
    params: { type: _.RegionSumLine },
    description:
      "For each line, digits on the line have an equal sum N within each box it passes through.",
  },
  tk,
  nk,
  sk,
  Xb,
  {
    params: { type: _.Arrow },
    description:
      "Numbers along an arrow sum to the number shown in the circled cells.",
  },
  {
    params: { type: _.DoubleArrow },
    description:
      "The sum of the digits along a ‘double arrow’ line is equal to the sum of the digits in the circles at either end of the line.",
  },
  {
    params: { type: _.LittleKillers },
    description:
      "Digits along marked diagonals sum to the number indicated outside the grid.",
  },
  ek,
  {
    params: { type: _.XSums },
    description:
      "Clues at the edge of the grid show the sum of the first X digits, where X is the first seen digit.",
  },
  {
    params: { type: _.Skyscrapers },
    description:
      "Each digit in the grid represents the height of a building in its cell. Taller buildings obstruct the view of shorter ones behind them. Clues outside the grid give the number of buildings visible from that vantage point in the clue's row or column.",
  },
  {
    params: { type: _.NumberedRooms },
    description:
      "Clues outside the grid indicate the digit which has to be placed in the Nth cell in the corresponding direction, where N is the digit placed in the first cell in that direction.",
  },
  Kb,
  {
    params: { type: _.Custom },
    label: "Custom constraint",
    description: "Code your own constraints in Javascript",
  },
  {
    params: { type: _.CosmeticLine },
    label: "Cosmetic lines",
    description:
      "Place lines without any (programmed) logic associated with them.",
    editorParams: { showStyle: !0 },
  },
  {
    params: { type: _.CosmeticCage },
    label: "Cosmetic cages",
    description:
      "Place cages without any (programmed) logic associated with them.",
    editorParams: { showStyle: !0 },
  },
  {
    params: { type: _.CosmeticSymbol },
    label: "Cosmetic symbols",
    description:
      "Place symbols (squares, circles, text, arrows) without any (programmed) logic associated with them.",
    editorParams: { showStyle: !0 },
    tags: ["squares", "circles", "text", "arrows"],
  },
  {
    params: { type: _.FogLights },
    label: "Fog lights",
    description:
      "Place lights which clear fog at the start. Fog: cover cells with fog that only clears when a correct digit is placed.",
  },
  {
    params: { type: _.FogTriggers },
    label: "Custom fog clearing",
    description:
      "Customize when fog should be cleared. Fog: cover cells with fog that only clears when a correct digit is placed.",
  },
];
function ik(t, e) {
  return lk.flatMap((s) => (typeof s == "function" ? s(t, e) : s));
}
function Rp(t) {
  const {
      selectedConstraint: e,
      selectConstraint: n,
      deselectConstraint: s,
      updateConstraints: o,
      updateConstraint: r,
    } = ke(),
    l = j(!1),
    i = j(),
    a = j(),
    u = b(() =>
      ik(t.value.spec, t.value.allConstraints).map((N, E) => ({
        key: E,
        item: N,
      }))
    ),
    p = b(() =>
      u.value
        .filter(({ item: N }) =>
          je.getIsUnique(N.params.type)
            ? !t.value.allConstraints.some(
                (E) => E.config.type === N.params.type
              )
            : !0
        )
        .map(({ key: N, item: E }) => {
          const R = Ec({
            type: E.params.type,
            spec: t.value.spec,
            otherConstraints: t.value.allConstraints,
          });
          return (
            bn(R, E.params),
            {
              key: N,
              name: E.label || je.getLabel(R, t.value.spec),
              description: E.description,
              preview: je.getPreview(R.type),
              config: R,
              editorParams: E.editorParams,
              tags: E.tags,
            }
          );
        })
    );
  ae(
    e,
    (N, E) => {
      var R;
      e.value
        ? (i.value = e.value)
        : ((R = i.value) == null ? void 0 : R.id) ===
            (E == null ? void 0 : E.id) && (i.value = void 0);
    },
    { immediate: !0 }
  ),
    ae(
      () => t.value.getEnabledConstraints(),
      (N) => {
        e.value && !N.includes(e.value)
          ? s()
          : i.value && !N.includes(i.value) && (i.value = void 0);
      },
      { immediate: !0 }
    );
  function m(N, E) {
    je.getIsSelectable(N.config.type) ? (n(N), ye.setSelecting(!1)) : s(),
      (i.value = N),
      (a.value = E);
  }
  function g() {
    s(), (i.value = void 0);
  }
  function v(N) {
    i.value === N ? g() : m(N);
  }
  function $(N) {
    const E = p.value.find((R) => R.key === N);
    E && k(E.config, { editorParams: E.editorParams });
  }
  function k(N, E) {
    const R = {
      id: fe(),
      name: void 0,
      enabled: !0,
      solverIgnored: !1,
      config: ue(N),
    };
    o((W) => {
      const T = W.allConstraints,
        Y = (E == null ? void 0 : E.after) ?? T.length - 1;
      T.splice(Y + 1, 0, R);
    }),
      (l.value = !1),
      je.getIsOpenable(R.config.type) &&
        m(R, E == null ? void 0 : E.editorParams);
  }
  function M(N) {
    o((E) => {
      _t(E.allConstraints, [N]);
    });
  }
  function P(N) {
    o((E) => {
      E.allConstraints = N;
    });
  }
  function x(N, E) {
    N.name !== E &&
      r(
        N,
        (R) => {
          R.name = E;
        },
        "Rename constraint"
      );
  }
  function A(N, E) {
    E === void 0 && (E = !N.enabled),
      N.enabled !== E &&
        r(
          N,
          (R) => {
            R.enabled = E;
          },
          `${E ? "Enable" : "Disable"} constraint`
        );
  }
  function O(N, E) {
    E === void 0 && (E = !N.solverIgnored),
      N.solverIgnored !== E &&
        r(
          N,
          (R) => {
            R.solverIgnored = E;
          },
          `${E ? "Disable" : "Enable"} constraint for solver`
        );
  }
  function V(N) {
    const E = t.value.allConstraints.findIndex((R) => R.id === N.id);
    k(ue(N.config), { after: E !== -1 ? E : void 0 });
  }
  function I(N, E) {
    N !== 0 &&
      o((R) => {
        const W = R.allConstraints;
        [W[N - 1], W[N]] = [W[N], W[N - 1]];
      }, E);
  }
  function U(N, E) {
    N !== t.value.allConstraints.length - 1 &&
      o((R) => {
        const W = R.allConstraints;
        [W[N + 1], W[N]] = [W[N], W[N + 1]];
      }, E);
  }
  function D(N, E, R) {
    o((W) => {
      const T = W.allConstraints,
        Y = T.splice(N, 1)[0];
      T.splice(E, 0, Y);
    }, R);
  }
  return (
    ot("removeConstraint", () => {
      i.value && M(i.value);
    }),
    ot("openNextConstraint", () => {
      const N = t.value.allConstraints,
        R =
          (N.findIndex((W) => {
            var T;
            return W.id === ((T = i.value) == null ? void 0 : T.id);
          }) +
            1) %
          N.length;
      m(N[R]);
    }),
    ot("openPreviousConstraint", () => {
      const N = t.value.allConstraints,
        E = N.findIndex((W) => {
          var T;
          return W.id === ((T = i.value) == null ? void 0 : T.id);
        }),
        R = E === -1 ? 0 : (E + N.length - 1) % N.length;
      m(N[R]);
    }),
    ot(
      "exitConstraintEditor",
      s,
      b(() => !!i.value)
    ),
    {
      options: p,
      showPicker: l,
      openConstraint: i,
      openEditorInitParams: a,
      toggleOpened: v,
      create: $,
      remove: M,
      rename: x,
      toggleEnabled: A,
      toggleSolverIgnored: O,
      duplicate: V,
      moveUp: I,
      moveDown: U,
      move: D,
      update: P,
    }
  );
}
const ak = S({
    __name: "EditRawDataModal",
    props: { constraint: {} },
    emits: ["close", "submit"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        { project: o } = ke();
      function r() {
        const p = { ...n.constraint.config };
        return delete p.type, new qi(50).stringify(p);
      }
      const l = b(() => {
          const p = n.constraint;
          return p.name || je.getLabel(p.config, o.value.spec);
        }),
        i = j(r()),
        a = b(() => {
          try {
            const p = JSON.parse(i.value);
            return p && typeof p == "object";
          } catch {
            return !1;
          }
        });
      function u() {
        s("submit", { ...JSON.parse(i.value), type: n.constraint.config.type });
      }
      return (p, m) => (
        d(),
        w(
          Id,
          { header: `Edit “${l.value}”`, "full-height": "", dismissible: !1 },
          {
            body: f(() => [
              c(
                lt,
                { type: "warning", border: "" },
                {
                  default: f(
                    () =>
                      m[2] ||
                      (m[2] = [
                        F(
                          " The validation on the data entered here is limited, and entering incorrect values may result in a corrupted puzzle. Proceed with caution. "
                        ),
                      ])
                  ),
                  _: 1,
                }
              ),
              c(
                Ho,
                {
                  "model-value": i.value,
                  "onUpdate:modelValue": m[0] || (m[0] = (g) => (i.value = g)),
                  language: "json",
                },
                null,
                8,
                ["model-value"]
              ),
            ]),
            footer: f(() => [
              c(
                te,
                { onClick: m[1] || (m[1] = (g) => p.$emit("close")) },
                { default: f(() => m[3] || (m[3] = [F(" Cancel ")])), _: 1 }
              ),
              c(Je),
              c(
                te,
                { disabled: !a.value, onClick: u },
                { default: f(() => m[4] || (m[4] = [F(" Update ")])), _: 1 },
                8,
                ["disabled"]
              ),
            ]),
            _: 1,
          },
          8,
          ["header"]
        )
      );
    },
  }),
  Op = B(ak, [["__scopeId", "data-v-8d154a24"]]),
  uk = { components: { Icon: he } };
function ck(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "CaretUp", viewBox: "0 0 10 7" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h("path", { d: "m0 5 2 2 3 -3 3 3 2 -2-5-5-5 5Z" }, null, -1),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Np = B(uk, [["render", ck]]),
  dk = { class: "pickerWrapper" },
  pk = { key: 0, class: "managerHeader" },
  fk = { key: 0, class: "componentManager" },
  hk = { class: "constraintsWrapper" },
  mk = { class: "rearrangeButtons" },
  gk = S({
    __name: "ConstraintsPanel",
    setup(t) {
      const {
          project: e,
          selectedConstraint: n,
          debuggingComponents: s,
          updateConstraint: o,
        } = ke(),
        { solverInputData: r } = as(),
        {
          toggleOpened: l,
          showPicker: i,
          options: a,
          openConstraint: u,
          openEditorInitParams: p,
          create: m,
          remove: g,
          rename: v,
          duplicate: $,
          toggleEnabled: k,
          toggleSolverIgnored: M,
          moveUp: P,
          moveDown: x,
        } = Rp(e);
      ot("newConstraint", () => {
        i.value = !0;
      });
      const A = j();
      function O(U) {
        A.value = U;
      }
      function V(U) {
        A.value &&
          o(
            A.value,
            (D) => {
              D.config = U;
            },
            "edit constraint"
          ),
          (A.value = void 0);
      }
      const I = j({});
      return (
        ae(u, (U) => {
          U &&
            setTimeout(() => {
              var D;
              (D = I.value[U.id]) == null ||
                D.scrollIntoView({ block: "nearest", inline: "nearest" });
            }, 200);
        }),
        (U, D) => (
          d(),
          C(
            Z,
            null,
            [
              h("div", dk, [
                y(s)
                  ? (d(), C("h3", pk, " Components "))
                  : (d(),
                    w(
                      te,
                      {
                        key: 1,
                        class: "pickerButton",
                        onClick: D[0] || (D[0] = (N) => (i.value = !0)),
                      },
                      {
                        default: f(() => D[5] || (D[5] = [F(" Add element ")])),
                        _: 1,
                      }
                    )),
                y(ee).debug
                  ? (d(),
                    w(
                      te,
                      {
                        key: 2,
                        icon: "",
                        active: y(s),
                        onClick: D[1] || (D[1] = (N) => (s.value = !y(s))),
                      },
                      {
                        default: f(() => [
                          c(ip),
                          c(Te, { text: "Debug constraints" }),
                        ]),
                        _: 1,
                      },
                      8,
                      ["active"]
                    ))
                  : z("", !0),
                c(Oe, null, {
                  default: f(({ target: N }) => [
                    y(i)
                      ? (d(),
                        w(
                          zp,
                          {
                            key: 0,
                            target: N,
                            options: y(a),
                            project: y(e),
                            onClose: D[2] || (D[2] = (E) => (i.value = !1)),
                            onSelect: D[3] || (D[3] = (E) => y(m)(E)),
                          },
                          null,
                          8,
                          ["target", "options", "project"]
                        ))
                      : z("", !0),
                  ]),
                  _: 1,
                }),
              ]),
              y(s)
                ? (d(),
                  C("div", fk, [
                    c(vb, { "solver-model": y(r) }, null, 8, ["solver-model"]),
                  ]))
                : z("", !0),
              Ln(
                h(
                  "div",
                  hk,
                  [
                    c(
                      vi,
                      { tag: "div", name: "fade" },
                      {
                        default: f(() => [
                          (d(!0),
                          C(
                            Z,
                            null,
                            se(y(e).allConstraints, (N, E) => {
                              var R, W, T, Y;
                              return (
                                d(),
                                C(
                                  "div",
                                  {
                                    key: N.id,
                                    ref_for: !0,
                                    ref: (J) => {
                                      I.value[N.id] = J;
                                    },
                                    class: Ae([
                                      "buttonWrapper",
                                      {
                                        selected:
                                          ((R = y(n)) == null
                                            ? void 0
                                            : R.id) === N.id,
                                      },
                                    ]),
                                  },
                                  [
                                    h("div", mk, [
                                      c(
                                        te,
                                        {
                                          class: "moveUp",
                                          disabled: E === 0,
                                          onClick: (J) => y(P)(E),
                                        },
                                        { default: f(() => [c(Np)]), _: 2 },
                                        1032,
                                        ["disabled", "onClick"]
                                      ),
                                      c(
                                        te,
                                        {
                                          class: "moveDown",
                                          disabled:
                                            E ===
                                            y(e).allConstraints.length - 1,
                                          onClick: (J) => y(x)(E),
                                        },
                                        { default: f(() => [c(Ri)]), _: 2 },
                                        1032,
                                        ["disabled", "onClick"]
                                      ),
                                    ]),
                                    c(
                                      zb,
                                      {
                                        constraint: N,
                                        selected:
                                          ((W = y(n)) == null
                                            ? void 0
                                            : W.id) === N.id,
                                        open:
                                          ((T = y(u)) == null
                                            ? void 0
                                            : T.id) === N.id,
                                        "editor-init-params":
                                          ((Y = y(u)) == null
                                            ? void 0
                                            : Y.id) === N.id
                                            ? y(p)
                                            : void 0,
                                        onEdit: (J) => y(l)(N),
                                        onRename: (J) => y(v)(N, J),
                                        onDuplicate: (J) => y($)(N),
                                        onToggle: (J) => y(k)(N),
                                        onToggleSolver: (J) => y(M)(N),
                                        onRemove: (J) => y(g)(N),
                                        onEditRaw: (J) => O(N),
                                      },
                                      null,
                                      8,
                                      [
                                        "constraint",
                                        "selected",
                                        "open",
                                        "editor-init-params",
                                        "onEdit",
                                        "onRename",
                                        "onDuplicate",
                                        "onToggle",
                                        "onToggleSolver",
                                        "onRemove",
                                        "onEditRaw",
                                      ]
                                    ),
                                  ],
                                  2
                                )
                              );
                            }),
                            128
                          )),
                        ]),
                        _: 1,
                      }
                    ),
                    c(Oe, null, {
                      default: f(() => [
                        A.value
                          ? (d(),
                            w(
                              Op,
                              {
                                key: 0,
                                constraint: A.value,
                                onSubmit: V,
                                onClose:
                                  D[4] || (D[4] = (N) => (A.value = void 0)),
                              },
                              null,
                              8,
                              ["constraint"]
                            ))
                          : z("", !0),
                      ]),
                      _: 1,
                    }),
                  ],
                  512
                ),
                [[bs, !y(s)]]
              ),
            ],
            64
          )
        )
      );
    },
  }),
  Tp = B(gk, [["__scopeId", "data-v-9e2287f1"]]),
  Vp = rp({
    exportName: "Sudoku Maker - Recent puzzles.json",
    getExportPayload: () => En.getEntries(),
    onImportCallback: (t) => {
      const { failed: e, success: n } = En.merge(t);
      return n === 0
        ? "Unable to import history."
        : e > 0
        ? `${e} of ${n + e} entries could not be imported.`
        : !0;
    },
  }),
  vk = { components: { Icon: he } };
function yk(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      {
        class: "EmptyHistoryIcon",
        viewBox: "-2 -2 24 20",
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        "stroke-linejoin": "round",
        "stroke-linecap": "round",
        "stroke-miterlimit": "2",
      },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "m2 7.99-.3-.3A1 1 0 0 0 .3 9.11l2.1 2.1a1 1 0 0 0 1.39.01l2.2-2.1a1 1 0 1 0-1.38-1.44l-.6.57L4 8a6 6 0 1 1 2.94 5.16 1 1 0 0 0-1.02 1.72A8 8 0 1 0 2 7.98Zm7-2.9v3.34c0 .27.16.53.4.66l2.63 1.42a.75.75 0 1 0 .72-1.32L10.5 7.98v-2.9a.75.75 0 0 0-1.5 0Z",
                  fill: "#aaa",
                },
                null,
                -1
              ),
              h(
                "g",
                { transform: "translate(13.8 -2) scale(0.4)" },
                [
                  h("path", {
                    d: "M10 0a10 10 0 0 0 10 10 10 10 0 0 0-10 10A10 10 0 0 0 0 10 10 10 0 0 0 10 0Z",
                    fill: "#fd0",
                    filter: "drop-shadow(0 0 0.5 #fff)",
                  }),
                  h("path", {
                    fill: "#fff",
                    d: "M8.5 6A2.5 2.5 0 0 0 11 8.5 2.5 2.5 0 0 0 8.5 11 2.5 2.5 0 0 0 6 8.5 2.5 2.5 0 0 0 8.5 6Z",
                  }),
                ],
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Ck = B(vk, [["render", yk]]),
  wk = { components: { Icon: he } };
function bk(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      {
        class: "UploadIcon",
        viewBox: "0 0 20 20",
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        "stroke-linejoin": "round",
        "stroke-miterlimit": "2",
      },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M15.5 19a4.5 4.5 0 0 0 4.5-4.5v-1a1.5 1.5 0 0 0-3 0v1a1.5 1.5 0 0 1-1.5 1.5h-11A1.5 1.5 0 0 1 3 14.5v-1a1.5 1.5 0 0 0-3 0v1A4.5 4.5 0 0 0 4.5 19h11Z",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M8.75 3a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v6h1.74a1 1 0 0 1 .8 1.6l-3 3.95a1 1 0 0 1-1.59 0L6.22 10.6a1 1 0 0 1 .8-1.6h1.73V3Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const jp = B(wk, [["render", bk]]),
  kk = { class: "EmptyState" },
  _k = { class: "text" },
  $k = S({
    __name: "EmptyState",
    setup(t) {
      const { importData: e } = Vp(),
        n = "Sudoku Maker";
      return (s, o) => (
        d(),
        C("div", kk, [
          c(Ck),
          h("div", _k, [
            o[9] ||
              (o[9] = h(
                "p",
                null,
                " You have no recently opened puzzles. ",
                -1
              )),
            h(
              "p",
              null,
              " If you have used " +
                X(y(n)) +
                " somewhere else before, you can copy over your list of recent puzzles by following these steps: ",
              1
            ),
            h("ol", null, [
              h("li", null, [
                o[0] || (o[0] = F("click the ")),
                c(Mo, { inline: "" }),
                o[1] || (o[1] = F(" button in the ")),
                o[2] || (o[2] = h("em", null, "Recent puzzles", -1)),
                o[3] || (o[3] = F(" pop-up,")),
              ]),
              h("li", null, [
                o[4] || (o[4] = F("click on ")),
                c(Ui, { inline: "" }),
                o[5] || (o[5] = F()),
                o[6] || (o[6] = h("strong", null, "Export list", -1)),
              ]),
              o[7] ||
                (o[7] = h(
                  "li",
                  null,
                  "import the file here by using the button below.",
                  -1
                )),
            ]),
            c(
              te,
              { class: "importButton", "with-icon": "", onClick: y(e) },
              {
                default: f(() => [
                  c(jp),
                  o[8] || (o[8] = F(" Import recent puzzles ")),
                ]),
                _: 1,
              },
              8,
              ["onClick"]
            ),
          ]),
        ])
      );
    },
  }),
  Sk = B($k, [["__scopeId", "data-v-c5d07529"]]),
  Ik = { class: "ErrorBoundary" },
  xk = S({
    __name: "ErrorBoundary",
    emits: ["error"],
    setup(t, { emit: e }) {
      const n = e,
        s = j(!1);
      return (
        w1(() => ((s.value = !0), n("error"), !1)),
        (o, r) => (
          d(),
          C("div", Ik, [
            s.value
              ? G(o.$slots, "error", { key: 0 }, () => [
                  r[0] ||
                    (r[0] = F(
                      " Something went wrong. Check the console for more details. "
                    )),
                ])
              : G(o.$slots, "default", { key: 1 }),
          ])
        )
      );
    },
  }),
  Dk = S({
    __name: "PlayButton",
    props: { project: {} },
    setup(t) {
      const e = t,
        n = j(!1);
      function s() {
        if (e.project.isSolved()) o(!0);
        else if (
          !ee.suppressedWarnings.includes("playIncompleteGrid") &&
          e.project.isPotentiallySolved()
        ) {
          let r = !1;
          ws({
            header: "The grid is incomplete",
            bodyComponent: () =>
              c(Z, null, [
                c("p", null, [
                  F(
                    "Not all cells are filled in and therefore no solution will be embedded when playtesting. If you want to share puzzles with incomplete grids as the solution, use the"
                  ),
                  " ",
                  c(Ys, { inline: !0 }, null),
                  " ",
                  c("strong", null, [F("Share")]),
                  " ",
                  F("functionality instead."),
                ]),
                c(
                  ut,
                  { style: "margin-top: 0.5em" },
                  {
                    default: () => [
                      c(
                        at,
                        {
                          checked: r,
                          "onUpdate:checked": (l) => {
                            r = l;
                          },
                        },
                        null
                      ),
                      F("Do not remind me again."),
                    ],
                  }
                ),
              ]),
            confirmText: "Okay!",
            cancelText: "Go back",
            callback: () => {
              r && ee.suppressedWarnings.push("playIncompleteGrid"), o(!1);
            },
          });
        } else o(!1);
      }
      async function o(r) {
        const l = e.project.toPlayablePuzzleData(),
          i = r ? e.project.cells.map((u) => u.value) : void 0,
          a = np(l, i);
        n.value = !0;
        try {
          ed
            ? window
                .open("/generate.html", "_blank")
                .location.replace(await oi(a))
            : window.open(await oi(a), "_blank");
        } finally {
          n.value = !1;
        }
      }
      return (r, l) => (
        d(),
        w(
          nl,
          {
            class: "PlayButton",
            "with-icon": "",
            loading: n.value,
            onClick: s,
          },
          {
            default: f(
              () =>
                l[0] ||
                (l[0] = [
                  h(
                    "img",
                    { class: "sudokuPadLogo", src: Pd, alt: "SudokuPad" },
                    null,
                    -1
                  ),
                  h("span", null, "Playtest", -1),
                ])
            ),
            _: 1,
          },
          8,
          ["loading"]
        )
      );
    },
  }),
  ul = B(Dk, [["__scopeId", "data-v-3a7bbd5b"]]),
  Mk = S({
    components: {
      PlayButton: ul,
      RedErrorIcon: Vo,
      CopyButton: Td,
      ExportLink: Vd,
      ErrorBoundary: xk,
      ExportIcon: Ys,
      ButtonGroup: Yt,
      Pencil: ls,
      UiSpacer: Je,
      FormFooter: Ft,
      FormButton: te,
      SudokuSvg: Xs,
    },
    props: {
      project: { type: Object, required: !0 },
      url: { type: String, required: !0 },
      isBroken: { type: Boolean, default: !1 },
    },
    emits: { open: () => !0 },
    data() {
      return { error: !1, fallbackLink: "" };
    },
    computed: {
      previewPuzzle() {
        return this.project.toPuzzlePreviewData();
      },
      canShare() {
        return !!navigator.share && !this.error;
      },
    },
    watch: {
      isBroken: {
        immediate: !0,
        handler() {
          this.isBroken && this.onPreviewError();
        },
      },
    },
    methods: {
      async share() {
        await navigator.share({ title: this.project.name, url: this.url });
      },
      onCopyError() {
        this.fallbackLink = this.url;
      },
      onPreviewError() {
        (this.error = !0),
          console.error("The following sudoku could not be loaded: ", this.url);
      },
    },
  }),
  Ak = { class: "HistoryPreview" },
  Pk = { key: 0, class: "sudokuComment" },
  Lk = { class: "errorMessage" };
function Ek(t, e, n, s, o, r) {
  const l = H("SudokuSvg"),
    i = H("RedErrorIcon"),
    a = H("ErrorBoundary"),
    u = H("ExportLink"),
    p = H("PlayButton"),
    m = H("ExportIcon"),
    g = H("FormButton"),
    v = H("CopyButton"),
    $ = H("ButtonGroup"),
    k = H("UiSpacer"),
    M = H("Pencil"),
    P = H("FormFooter");
  return (
    d(),
    C("div", Ak, [
      c(
        a,
        { onError: t.onPreviewError },
        {
          default: f(() => [
            c(
              l,
              {
                spec: t.previewPuzzle.spec,
                cells: t.previewPuzzle.cells,
                constraints: t.previewPuzzle.constraints,
                readonly: "",
              },
              null,
              8,
              ["spec", "cells", "constraints"]
            ),
            t.project.comment
              ? (d(), C("div", Pk, X(t.project.comment), 1))
              : z("", !0),
          ]),
          error: f(() => [
            h("div", Lk, [
              c(i),
              e[1] ||
                (e[1] = F(
                  " Something went wrong loading this puzzle. Check the browser developer console for details. "
                )),
            ]),
          ]),
          _: 1,
        },
        8,
        ["onError"]
      ),
      t.fallbackLink
        ? (d(), w(u, { key: 0, to: t.fallbackLink }, null, 8, ["to"]))
        : z("", !0),
      c(P, null, {
        default: f(() => [
          c($, null, {
            default: f(() => [
              c(p, { project: t.project }, null, 8, ["project"]),
              t.canShare
                ? (d(),
                  w(
                    g,
                    { key: 0, "with-icon": "", onClick: t.share },
                    {
                      default: f(() => [
                        c(m),
                        e[2] || (e[2] = h("span", null, "Share", -1)),
                      ]),
                      _: 1,
                    },
                    8,
                    ["onClick"]
                  ))
                : t.fallbackLink
                ? z("", !0)
                : (d(),
                  w(
                    v,
                    {
                      key: 1,
                      text: "Copy link",
                      value: t.url,
                      onError: t.onCopyError,
                    },
                    null,
                    8,
                    ["value", "onError"]
                  )),
            ]),
            _: 1,
          }),
          c(k),
          t.error
            ? z("", !0)
            : (d(),
              w(
                g,
                {
                  key: 0,
                  "with-icon": "",
                  onClick: e[0] || (e[0] = (x) => t.$emit("open")),
                },
                {
                  default: f(() => [
                    e[3] || (e[3] = h("span", null, "Open", -1)),
                    c(M),
                  ]),
                  _: 1,
                }
              )),
        ]),
        _: 1,
      }),
    ])
  );
}
const Fk = B(Mk, [
    ["render", Ek],
    ["__scopeId", "data-v-1f83e9d9"],
  ]),
  Bk = S({
    __name: "SafariHistoryNotice",
    emits: ["close"],
    setup(t) {
      const e = lp(),
        n = "Sudoku Maker",
        s = ll("safariAcknowledged", "");
      function o() {
        s.value = "1";
      }
      return (r, l) =>
        !y(s) && y(ed) && !y(e)
          ? (d(),
            w(
              lt,
              { key: 0 },
              {
                default: f(() => [
                  l[1] ||
                    (l[1] = h("h4", null, "Important to Safari users", -1)),
                  h(
                    "p",
                    null,
                    " If you want to retain your list of recent puzzles after a week of inactivity, it is recommended to use a different browser, or if you are on iOS or iPadOS, to add " +
                      X(y(n)) +
                      " to your home screen. ",
                    1
                  ),
                  c(
                    te,
                    { onClick: o },
                    {
                      default: f(() => l[0] || (l[0] = [F(" I understand ")])),
                      _: 1,
                    }
                  ),
                ]),
                _: 1,
              }
            ))
          : z("", !0);
    },
  }),
  zk = B(Bk, [["__scopeId", "data-v-61420378"]]),
  Rk = S({
    __name: "SettingsDropdown",
    setup(t) {
      const e = j(!1),
        { importData: n, exportData: s } = Vp();
      function o() {
        s(), (e.value = !1);
      }
      function r() {
        ws({
          header: "Clear recent puzzles?",
          body: "Are you sure you want to clear this list? This cannot be undone.",
          confirmText: "Clear list",
          isDestructive: !0,
          callback: () => {
            En.clear();
          },
        });
      }
      return (
        ae(
          () => En.getEntries(),
          () => {
            e.value = !1;
          }
        ),
        (l, i) => (
          d(),
          w(
            te,
            {
              icon: "",
              size: "small",
              onClick: i[1] || (i[1] = (a) => (e.value = !e.value)),
            },
            {
              default: f(() => [
                c(Mo, { style: { height: "1em" } }),
                c(
                  tl,
                  {
                    show: e.value,
                    onClose: i[0] || (i[0] = (a) => (e.value = !1)),
                  },
                  {
                    default: f(() => [
                      c(
                        Ge,
                        { onClick: o },
                        {
                          default: f(() => [
                            c(Ui),
                            i[2] || (i[2] = h("span", null, "Export list", -1)),
                          ]),
                          _: 1,
                        }
                      ),
                      c(
                        Ge,
                        { onClick: y(n) },
                        {
                          default: f(() => [
                            c(jp),
                            i[3] || (i[3] = h("span", null, "Import list", -1)),
                          ]),
                          _: 1,
                        },
                        8,
                        ["onClick"]
                      ),
                      c(
                        Ge,
                        { onClick: r },
                        {
                          default: f(() => [
                            c(xo),
                            i[4] || (i[4] = h("span", null, "Clear list", -1)),
                          ]),
                          _: 1,
                        }
                      ),
                    ]),
                    _: 1,
                  },
                  8,
                  ["show"]
                ),
                e.value ? z("", !0) : (d(), w(Te, { key: 0, text: "Manage" })),
              ]),
              _: 1,
            }
          )
        )
      );
    },
  }),
  { state: Up, selectConstraint: Ok } = ke();
async function ri(t) {
  jt.reset(), od.setSudoku(t), kw();
  const e =
    t.allConstraints.length > 0 && t.allConstraints[0].config.type === _.Givens;
  (Up.value = jc(t)), e && Ok(t.allConstraints[0]);
}
async function Pr(t) {
  Nn.stop(),
    Up.value && (await new Promise((e) => setTimeout(e, 10))),
    await ri(t);
}
class Hp extends Error {
  constructor(n) {
    super();
    L(this, "version");
    this.version = n;
  }
  needsUpdate() {
    const n = Ei.split(".").map(Number),
      s = this.version.split(".").map(Number);
    for (let o = 0; o < 3; o++) {
      if (s[o] > n[o]) return !0;
      if (s[o] < n[o]) return !1;
    }
    return !1;
  }
}
var li = ((t) => (
  (t[(t.Unknown = 0)] = "Unknown"),
  (t[(t.FutureVersion = 1)] = "FutureVersion"),
  (t[(t.UnsupportedVersion = 2)] = "UnsupportedVersion"),
  t
))(li || {});
class ii extends Error {
  constructor(n) {
    super();
    L(this, "cause");
    n instanceof Hp ? (this.cause = n.needsUpdate() ? 1 : 2) : (this.cause = 0);
  }
}
function Lr(t) {
  let e = "";
  do (e = String.fromCharCode(65 + (t % 26)) + e), (t = Math.floor(t / 26) - 1);
  while (t >= 0);
  return e;
}
function Nk(t) {
  let e = 0,
    n = Lr(e);
  for (; t.has(n); ) e++, (n = Lr(e));
  return n;
}
function Tk(t) {
  const e = t;
  return (
    (e.constraints = e.constraints.flatMap((n) => {
      const s = n;
      return n.type === _.FogLights
        ? Object.keys(s.triggers || {}).length > 0 || s.useDefaults
          ? [
              n,
              {
                ...n,
                type: _.FogTriggers,
                patterns: s.useDefaults
                  ? [Be.Self, Be.DiagonalNeighbors, Be.OrthogonalNeighbors]
                  : [],
                triggers: Object.keys(s.triggers).map((o, r) => ({
                  cells: [Number(o)],
                  label: Lr(r),
                })),
                effects: Object.values(s.triggers).map((o, r) => ({
                  cells: Lt.withoutDuplicates(o),
                  label: Lr(r),
                })),
                overrides: s.useDefaults
                  ? Object.keys(s.triggers).map((o) => Number(o))
                  : [],
              },
            ]
          : [n]
        : [n];
    })),
    e
  );
}
function Vk(t, e) {
  if (e === "1.0.0") {
    const n = t;
    n.cells.forEach((s) => {
      s && !s.value && (s.value = void 0);
    });
    for (const s of n.constraints)
      (s.type === _.NumberedRooms ||
        s.type === _.LittleKillers ||
        s.type === _.XSums ||
        s.type === _.Skyscrapers) &&
        (s.clues = s.clues.filter((o) => o.value));
    return n;
  }
  if (["1.1.0", "1.2.0", "1.3.0"].includes(e)) return t;
  if (e === "1.4.0") return Tk(t);
}
function zu(t) {
  try {
    return new URL(t);
  } catch {
    return;
  }
}
class Os {
  urlContainsProject(e) {
    var s;
    const n = (s = zu(e)) == null ? void 0 : s.searchParams.get(El);
    return n ? n.startsWith("N") : !1;
  }
  loadFromUrl(e) {
    var s;
    const n = (s = zu(e)) == null ? void 0 : s.searchParams.get(El);
    if (!n) throw new Error("Invalid URL");
    return this.loadFromUrlEncodedPayload(n);
  }
  loadFromUrlEncodedPayload(e) {
    const s = new P0().decompressFromEncodedURIComponent(e);
    return this.loadFromJSON(s);
  }
  loadFromJSON(e) {
    const { sudoku: n, puzzle: s, formatVersion: o } = JSON.parse(e);
    let r = s || n;
    try {
      if (o !== Ei) {
        const l = Vk(r, o);
        if (l === void 0) throw new Hp(o);
        r = l;
      }
      return this.decompressData(r);
    } catch (l) {
      throw new ii(l);
    }
  }
  async loadFromFile(e) {
    return new Promise((n, s) => {
      const o = new FileReader();
      o.readAsText(e),
        (o.onload = () => {
          try {
            n(this.loadFromJSON(o.result));
          } catch (r) {
            s(r);
          }
        }),
        (o.onerror = s);
    });
  }
  decompressData(e) {
    var r, l, i, a, u, p, m, g;
    const n = this.getSpecFromCompressedModel(e),
      s = new ln(n);
    for (let v = 0; v < s.cells.length; v++) {
      const $ = e.cells[v],
        k = new rs(v, v % n.size.width, Math.floor(v / n.size.width));
      (k.given = ($ == null ? void 0 : $.given) || !1),
        (k.candidates = ($ == null ? void 0 : $.candidates) || 0),
        (k.value = $ == null ? void 0 : $.value),
        (k.cornerPencilMarks = ($ == null ? void 0 : $.cornerPencilMarks) || 0),
        (k.colors = ($ == null ? void 0 : $.colors) || 0),
        (s.cells[v] = k);
    }
    const o = new Fc();
    return (
      (s.allConstraints = e.constraints.map((v) => o.read(v, { spec: n }))),
      (s.name = e.name),
      (s.author = e.author),
      (s.comment = e.comment || ""),
      (s.exportSettings = {
        sudokuPad: {
          showDigits: !!(
            (l = (r = e.export) == null ? void 0 : r.sudokuPad) != null &&
            l.showDigits
          ),
          showColorMarks: !!(
            (a = (i = e.export) == null ? void 0 : i.sudokuPad) != null &&
            a.showColorMarks
          ),
          useIncompleteGridAsSolution: !!(
            (p = (u = e.export) == null ? void 0 : u.sudokuPad) != null &&
            p.useIncompleteGridAsSolution
          ),
          solution:
            ((g = (m = e.export) == null ? void 0 : m.sudokuPad) == null
              ? void 0
              : g.solution) ?? ue(Co.sudokuPad.solution),
        },
      }),
      Object.assign(s.messages, e.messages),
      s
    );
  }
  getSpecFromCompressedModel(e) {
    switch (e.type || Ie.Sudoku) {
      case Ie.Sudoku:
        return $o({ type: Ie.Sudoku, size: e.size || 9 });
      case Ie.Custom:
        return $o({
          type: Ie.Custom,
          size: { width: e.width || 9, height: e.height || 9 },
          minDigit: e.minDigit ?? 1,
          maxDigit: e.maxDigit || 9,
        });
    }
  }
}
function Wp(t, e) {
  try {
    return t();
  } catch {
    return gn(e);
  }
}
async function Ru(t, e) {
  try {
    return await t();
  } catch {
    return gn(e);
  }
}
const jk = { key: 1, class: "main" },
  Uk = { class: "listWrapper" },
  Hk = ["href", "onClick", "onDblclick"],
  Wk = { class: "sudokuId" },
  Zk = { class: "description" },
  Gk = { class: "date" },
  qk = { class: "previewWrapper" },
  Kk = S({
    __name: "HistoryModal",
    emits: ["close"],
    setup(t, { emit: e }) {
      const n = e,
        { project: s } = ke(),
        o = b(() => {
          const g = En.getEntries().map(($) => i($)),
            v = g.findIndex(($) => $.model.equals(s.value));
          return (
            v > -1 && g.splice(v, 1),
            g.sort(($, k) => k.date.valueOf() - $.date.valueOf()),
            g
          );
        }),
        r = j(0),
        l = b(() => o.value.find((g) => g.key === r.value));
      ae(
        o,
        () => {
          var v;
          const g = (v = o.value[0]) == null ? void 0 : v.key;
          !l.value && g && (r.value = g);
        },
        { immediate: !0 }
      );
      function i(g) {
        let v = Wp(() => new Os().loadFromUrl(g.url), void 0);
        return v
          ? {
              key: g.creationTimestamp,
              date: new Date(g.latestUpdateTimestamp),
              model: v,
              description: a(v),
              url: g.url,
            }
          : ((v = ln.createDefault(jo())),
            (v.name = "A corrupted puzzle"),
            (v.author = "!!!"),
            {
              key: g.creationTimestamp,
              date: new Date(g.latestUpdateTimestamp),
              model: v,
              isBroken: !0,
              description: "This puzzle could not be loaded.",
              url: g.url,
            });
      }
      function a(g) {
        try {
          const v = [];
          for (const $ of g.allConstraints)
            v.push(je.getLabel($.config, g.spec));
          return v.join(", ");
        } catch {
          return "CORRUPTED";
        }
      }
      function u(g) {
        var v, $;
        if (r.value === g) {
          const k = o.value.findIndex((M) => M.key === g);
          r.value =
            ((v = o.value[k + 1]) == null ? void 0 : v.key) ||
            (($ = o.value[k - 1]) == null ? void 0 : $.key) ||
            0;
        }
        En.removeEntry(g);
      }
      function p(g, v) {
        g.ctrlKey ||
          g.metaKey ||
          g.shiftKey ||
          g.button !== 0 ||
          (g.preventDefault(), (r.value = v.key));
      }
      function m(g) {
        Pr(g), n("close");
      }
      return (g, v) => (
        d(),
        w(
          Bt,
          {
            class: "HistoryModal",
            variant: o.value.length > 0 ? "fullscreen" : "responsive",
            width: 50,
            onClose: v[1] || (v[1] = ($) => g.$emit("close")),
          },
          {
            default: f(() => [
              c(un, null, {
                default: f(
                  () =>
                    v[2] ||
                    (v[2] = [
                      h(
                        "div",
                        { style: { display: "flex", gap: "1rem" } },
                        " Recent puzzles ",
                        -1
                      ),
                    ])
                ),
                _: 1,
              }),
              c(zk),
              o.value.length === 0
                ? (d(),
                  w(
                    Cd,
                    { key: 0, appear: "" },
                    { default: f(() => [c(Sk)]), _: 1 }
                  ))
                : z("", !0),
              o.value.length > 0
                ? (d(),
                  C("div", jk, [
                    h("div", Uk, [
                      c(
                        Ti,
                        { vertical: "", class: "list" },
                        {
                          default: f(() => [
                            c(
                              vi,
                              { tag: "ol", name: "fade" },
                              {
                                default: f(() => [
                                  (d(!0),
                                  C(
                                    Z,
                                    null,
                                    se(o.value, ($) => {
                                      var k;
                                      return (
                                        d(),
                                        C("li", { key: $.key, class: "item" }, [
                                          h(
                                            "a",
                                            {
                                              class: Ae([
                                                "link",
                                                {
                                                  active:
                                                    $.key ===
                                                    ((k = l.value) == null
                                                      ? void 0
                                                      : k.key),
                                                },
                                              ]),
                                              href: $.url,
                                              target: "_blank",
                                              onClick: (M) => p(M, $),
                                              onDblclick: (M) => m($.model),
                                            },
                                            [
                                              h("div", Wk, [
                                                c(
                                                  rl,
                                                  { name: $.model.name },
                                                  null,
                                                  8,
                                                  ["name"]
                                                ),
                                                F(
                                                  " by " +
                                                    X($.model.author || "???"),
                                                  1
                                                ),
                                              ]),
                                              h(
                                                "small",
                                                Zk,
                                                X($.description),
                                                1
                                              ),
                                              h(
                                                "small",
                                                Gk,
                                                X($.date.toLocaleDateString()) +
                                                  " " +
                                                  X(
                                                    $.date.toLocaleTimeString()
                                                  ),
                                                1
                                              ),
                                            ],
                                            42,
                                            Hk
                                          ),
                                          c(
                                            Jr,
                                            {
                                              "need-confirm": "",
                                              onClick: (M) => u($.key),
                                            },
                                            null,
                                            8,
                                            ["onClick"]
                                          ),
                                        ])
                                      );
                                    }),
                                    128
                                  )),
                                ]),
                                _: 1,
                              }
                            ),
                          ]),
                          _: 1,
                        }
                      ),
                    ]),
                    c(
                      be,
                      { class: "meta" },
                      {
                        default: f(() => [
                          h("div", null, [
                            F(
                              " Recent puzzles: " +
                                X(o.value.length) +
                                " / " +
                                X(y(pc)) +
                                " ",
                              1
                            ),
                            c(dt, null, {
                              default: f(
                                () =>
                                  v[3] ||
                                  (v[3] = [
                                    F(
                                      " Keep in mind that once this list is full, older puzzles may be automatically removed as new ones are added. So make sure to save your important work accordingly. "
                                    ),
                                  ])
                              ),
                              _: 1,
                            }),
                          ]),
                          c(Je),
                          o.value.length > 0
                            ? (d(), w(Rk, { key: 0 }))
                            : z("", !0),
                        ]),
                        _: 1,
                      }
                    ),
                    h("div", qk, [
                      l.value && !l.value.isBroken
                        ? (d(),
                          w(
                            Fk,
                            {
                              key: l.value.key,
                              project: l.value.model,
                              url: l.value.url,
                              onOpen: v[0] || (v[0] = ($) => m(l.value.model)),
                            },
                            null,
                            8,
                            ["project", "url"]
                          ))
                        : z("", !0),
                    ]),
                  ]))
                : z("", !0),
            ]),
            _: 1,
          },
          8,
          ["variant"]
        )
      );
    },
  }),
  Zp = B(Kk, [["__scopeId", "data-v-d13c0453"]]);
function Xk(t) {
  return t.match(/^https?:\/\/tinyurl.com\//)
    ? !0
    : new Os().urlContainsProject(t);
}
const Yk = S({
    __name: "ImportModal",
    emits: ["close"],
    setup(t, { emit: e }) {
      const n = e,
        s = "Sudoku Maker",
        o = j(""),
        r = j(),
        l = j(!1),
        i = j(!1),
        a = b(() => Xk(o.value) || r.value),
        u = b(() => (a.value ? o.value.replace(/^http:/, "https:") : ""));
      ae(o, () => {
        i.value = !1;
      });
      async function p() {
        if (r.value) {
          await Pr(r.value), n("close");
          return;
        }
        (l.value = !0), (i.value = !1);
        for (const k of [m, g]) {
          const M = await k();
          if (M) {
            await Pr(M), n("close");
            return;
          }
        }
        (i.value = !0), (l.value = !1);
      }
      function m() {
        return Wp(() => new Os().loadFromUrl(u.value), void 0);
      }
      async function g() {
        return Ru(async () => {
          const k = await fetch(u.value);
          return new Os().loadFromUrl(k.url);
        }, void 0);
      }
      const v = Oi();
      v.addEventListener(async (k) => {
        !k ||
          k.length === 0 ||
          ((r.value = await Ru(
            async () => new Os().loadFromFile(k[0]),
            void 0
          )),
          r.value || ((i.value = !0), v.clear()));
      });
      function $() {
        (r.value = void 0), v.clear();
      }
      return (k, M) => (
        d(),
        w(
          Bt,
          {
            class: "ImportModal",
            variant: "content",
            onClose: M[3] || (M[3] = (P) => k.$emit("close")),
          },
          {
            default: f(() => [
              c(un, null, {
                default: f(() => M[4] || (M[4] = [F("Open puzzle")])),
                _: 1,
              }),
              h(
                "form",
                { onSubmit: st(p, ["prevent"]) },
                [
                  c(
                    be,
                    { vertical: "", gap: "" },
                    {
                      default: f(() => [
                        r.value
                          ? z("", !0)
                          : (d(),
                            w(
                              ve,
                              { key: 0, label: "Enter URL:", vertical: "" },
                              {
                                default: f(() => [
                                  c(
                                    vt,
                                    {
                                      value: o.value,
                                      "onUpdate:value":
                                        M[0] || (M[0] = (P) => (o.value = P)),
                                      autofocus: "",
                                      placeholder:
                                        "E.g. https://sudokumaker.app/?puzzle=...",
                                    },
                                    null,
                                    8,
                                    ["value"]
                                  ),
                                ]),
                                _: 1,
                              }
                            )),
                        r.value
                          ? (d(),
                            w(
                              Ql,
                              {
                                key: 2,
                                text: `Uploaded file: ${r.value.name}`,
                                onRemove: $,
                              },
                              null,
                              8,
                              ["text"]
                            ))
                          : (d(),
                            w(
                              ve,
                              { key: 1, label: "Or open file:" },
                              {
                                default: f(() => [
                                  c(
                                    te,
                                    {
                                      disabled: !!o.value,
                                      onClick:
                                        M[1] ||
                                        (M[1] = () => {
                                          y(v).open(), (i.value = !1);
                                        }),
                                    },
                                    {
                                      default: f(
                                        () =>
                                          M[5] || (M[5] = [F(" Select file ")])
                                      ),
                                      _: 1,
                                    },
                                    8,
                                    ["disabled"]
                                  ),
                                ]),
                                _: 1,
                              }
                            )),
                      ]),
                      _: 1,
                    }
                  ),
                  Ln(
                    c(
                      lt,
                      { type: "error" },
                      {
                        default: f(() => [
                          h(
                            "p",
                            null,
                            " Something went wrong opening that puzzle. It is either corrupted or not supported by this version of " +
                              X(y(s)) +
                              ". ",
                            1
                          ),
                        ]),
                        _: 1,
                      },
                      512
                    ),
                    [[bs, i.value]]
                  ),
                  c(Ft, null, {
                    default: f(() => [
                      c(
                        te,
                        { onClick: M[2] || (M[2] = (P) => k.$emit("close")) },
                        {
                          default: f(() => M[6] || (M[6] = [F(" Cancel ")])),
                          _: 1,
                        }
                      ),
                      c(Je),
                      c(
                        nl,
                        {
                          type: "submit",
                          "with-icon": "",
                          disabled: !a.value,
                          loading: l.value,
                        },
                        {
                          default: f(() => [
                            M[7] || (M[7] = h("span", null, "Open", -1)),
                            c(Wo),
                          ]),
                          _: 1,
                        },
                        8,
                        ["disabled", "loading"]
                      ),
                    ]),
                    _: 1,
                  }),
                ],
                32
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  Gp = B(Yk, [["__scopeId", "data-v-53008380"]]),
  Jk = S({
    __name: "EasterEgg",
    props: { size: {} },
    setup(t) {
      zn((s) => ({ "24ec7441": s.size }));
      let e = 0;
      function n() {
        e++,
          !(e < 2) &&
            window.open(
              [..."gIStlWhdtwx=v?hctaw/moc.ebutuoy.www//:sptth"]
                .reverse()
                .join("")
            );
      }
      return (s, o) => (d(), C("div", { class: "something", onClick: n }));
    },
  }),
  Qk = B(Jk, [["__scopeId", "data-v-00706c26"]]),
  e8 = S({
    __name: "GridSizeInput",
    props: { modelValue: {} },
    emits: ["update:modelValue"],
    setup(t) {
      return (e, n) => (
        d(),
        w(
          be,
          { class: "GridSizeInput", gap: "", align: "center" },
          {
            default: f(() => [
              c(
                Ht,
                {
                  value: e.modelValue.width,
                  min: 1,
                  max: 99,
                  "onUpdate:value":
                    n[0] ||
                    (n[0] = (s) =>
                      e.$emit("update:modelValue", {
                        ...e.modelValue,
                        width: s,
                      })),
                },
                null,
                8,
                ["value"]
              ),
              n[2] || (n[2] = F(" × ")),
              c(
                Ht,
                {
                  value: e.modelValue.height,
                  min: 1,
                  max: 99,
                  "onUpdate:value":
                    n[1] ||
                    (n[1] = (s) =>
                      e.$emit("update:modelValue", {
                        ...e.modelValue,
                        height: s,
                      })),
                },
                null,
                8,
                ["value"]
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  t8 = B(e8, [["__scopeId", "data-v-3920e793"]]),
  n8 = S({
    __name: "CustomPuzzleForm",
    props: { size: {}, minDigit: {}, maxDigit: {} },
    emits: ["update:size", "update:minDigit", "update:maxDigit"],
    setup(t) {
      return (e, n) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              ve,
              { label: "Grid size:" },
              {
                default: f(() => [
                  c(
                    t8,
                    {
                      "model-value": e.size,
                      "onUpdate:modelValue":
                        n[0] || (n[0] = (s) => e.$emit("update:size", s)),
                    },
                    null,
                    8,
                    ["model-value"]
                  ),
                ]),
                _: 1,
              }
            ),
            e.size.width * e.size.height >= 25 * 25
              ? (d(),
                w(
                  lt,
                  { key: 0 },
                  {
                    default: f(
                      () =>
                        n[3] ||
                        (n[3] = [
                          F(
                            " Caution: large grids can worsen the performance of this application, so use them at your own risk! "
                          ),
                        ])
                    ),
                    _: 1,
                  }
                ))
              : z("", !0),
            c(
              ve,
              { label: "Digits:" },
              {
                default: f(() => [
                  c(
                    hp,
                    {
                      "min-digit": e.minDigit,
                      "max-digit": e.maxDigit,
                      "onUpdate:minDigit":
                        n[1] || (n[1] = (s) => e.$emit("update:minDigit", s)),
                      "onUpdate:maxDigit":
                        n[2] || (n[2] = (s) => e.$emit("update:maxDigit", s)),
                    },
                    null,
                    8,
                    ["min-digit", "max-digit"]
                  ),
                ]),
                _: 1,
              }
            ),
          ],
          64
        )
      );
    },
  }),
  s8 = B(n8, [["__scopeId", "data-v-2cfe37e3"]]);
function o8(t) {
  const e = ln.createDefault(t, "", "");
  if (t.type === Ie.Sudoku)
    for (let n = 0; n < t.size.width; n++) {
      const s = n,
        o = n;
      if (o >= t.size.height) break;
      const r = e.cells[s + o * t.size.width];
      (r.given = !0),
        (r.value =
          ((n + 3 - e.spec.minDigit) %
            (e.spec.maxDigit - e.spec.minDigit + 1)) +
          e.spec.minDigit);
    }
  return (
    t.type === Ie.Sudoku &&
      Ac(t.size) &&
      e.allConstraints.push(ks({ type: _.Regions, spec: t })),
    e
  );
}
const r8 = S({
    __name: "StandardSudokuForm",
    props: { size: {} },
    emits: ["update:size"],
    setup(t) {
      const e = [4, 5, 6, 7, 8, 9].map((n) => ({
        label: `${n}×${n}`,
        value: n,
      }));
      return (n, s) => (
        d(),
        w(
          ve,
          { label: "Sudoku size:" },
          {
            default: f(() => [
              c(
                qs,
                {
                  "model-value": n.size,
                  options: y(e),
                  "dropdown-align": "left",
                  "onUpdate:modelValue":
                    s[0] || (s[0] = (o) => n.$emit("update:size", o)),
                },
                null,
                8,
                ["model-value", "options"]
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  l8 = { class: "preview" },
  i8 = S({
    __name: "NewPuzzleModal",
    emits: ["close"],
    setup(t, { emit: e }) {
      const n = e,
        { project: s } = ke(),
        o = j(s.value.spec.type),
        r = j(ue(s.value.spec.size)),
        l = j(s.value.spec.minDigit),
        i = j(s.value.spec.maxDigit),
        a = [
          { label: "Sudoku", value: Ie.Sudoku },
          { label: "Custom", value: Ie.Custom },
        ],
        u = b(() => {
          switch (o.value) {
            case Ie.Sudoku:
              return $o({ type: Ie.Sudoku, size: r.value.width });
            case Ie.Custom:
              return $o({
                type: Ie.Custom,
                size: r.value,
                minDigit: l.value,
                maxDigit: i.value,
              });
            default:
              return;
          }
        }),
        p = b(() => o8(u.value));
      ae(o, (g) => {
        g === Ie.Sudoku &&
          (r.value.width = r.value.height = Rt(r.value.width, 4, 9));
      });
      async function m() {
        const g = u.value,
          v = ln.createDefault(g, "", ee.defaultAuthorName);
        switch (g.type) {
          case Ie.Sudoku: {
            v.allConstraints.push(ks({ type: _.Givens, spec: g })),
              v.allConstraints.push(ks({ type: _.Regions, spec: g }));
            break;
          }
        }
        await Pr(v), n("close");
      }
      return (g, v) => (
        d(),
        w(
          Bt,
          {
            class: "NewSudokuModal",
            variant: "responsive",
            "responsive-flex": "",
            onClose: v[6] || (v[6] = ($) => g.$emit("close")),
          },
          {
            default: f(() => [
              c(un, null, {
                default: f(() => v[7] || (v[7] = [F("New Puzzle")])),
                _: 1,
              }),
              c(Je),
              h("div", l8, [
                c(Qk, { size: p.value.spec.size.width }, null, 8, ["size"]),
                (d(),
                w(
                  Xs,
                  {
                    key: p.value.id,
                    spec: p.value.spec,
                    cells: p.value.cells,
                    constraints: p.value.allConstraints,
                    readonly: "",
                  },
                  null,
                  8,
                  ["spec", "cells", "constraints"]
                )),
              ]),
              c(
                be,
                { class: "form", vertical: "", gap: "" },
                {
                  default: f(() => [
                    c(
                      ve,
                      { label: "Puzzle type:" },
                      {
                        default: f(() => [
                          c(
                            qs,
                            {
                              modelValue: o.value,
                              "onUpdate:modelValue":
                                v[0] || (v[0] = ($) => (o.value = $)),
                              options: a,
                              "dropdown-align": "left",
                            },
                            null,
                            8,
                            ["modelValue"]
                          ),
                        ]),
                        _: 1,
                      }
                    ),
                    c(
                      be,
                      { class: "puzzleProperties", vertical: "", gap: "" },
                      {
                        default: f(() => [
                          o.value === y(Ie).Sudoku
                            ? (d(),
                              w(
                                r8,
                                {
                                  key: 0,
                                  size: r.value.width,
                                  "onUpdate:size":
                                    v[1] ||
                                    (v[1] = ($) =>
                                      (r.value = { width: $, height: $ })),
                                },
                                null,
                                8,
                                ["size"]
                              ))
                            : o.value === y(Ie).Custom
                            ? (d(),
                              w(
                                s8,
                                {
                                  key: 1,
                                  size: r.value,
                                  "onUpdate:size":
                                    v[2] || (v[2] = ($) => (r.value = $)),
                                  "min-digit": l.value,
                                  "onUpdate:minDigit":
                                    v[3] || (v[3] = ($) => (l.value = $)),
                                  "max-digit": i.value,
                                  "onUpdate:maxDigit":
                                    v[4] || (v[4] = ($) => (i.value = $)),
                                },
                                null,
                                8,
                                ["size", "min-digit", "max-digit"]
                              ))
                            : z("", !0),
                        ]),
                        _: 1,
                      }
                    ),
                  ]),
                  _: 1,
                }
              ),
              c(Je),
              c(Ft, null, {
                default: f(() => [
                  c(
                    te,
                    { onClick: v[5] || (v[5] = ($) => g.$emit("close")) },
                    { default: f(() => v[8] || (v[8] = [F(" Cancel ")])), _: 1 }
                  ),
                  c(Je),
                  c(
                    te,
                    { "with-icon": "", onClick: m },
                    {
                      default: f(() => [
                        v[9] || (v[9] = h("span", null, "Create", -1)),
                        c(ls, { style: { scale: "1.25" } }),
                      ]),
                      _: 1,
                    }
                  ),
                ]),
                _: 1,
              }),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  qp = B(i8, [["__scopeId", "data-v-c7dd3686"]]),
  a8 = { components: { Icon: he } };
function u8(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      {
        class: "HistoryIcon",
        viewBox: "0 0 20 16",
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        "stroke-linejoin": "round",
        "stroke-linecap": "round",
        "stroke-miterlimit": "2",
      },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "m2 7.99-.3-.3A1 1 0 0 0 .3 9.11l2.1 2.1a1 1 0 0 0 1.39.01l2.2-2.1a1 1 0 1 0-1.38-1.44l-.6.57L4 8a6 6 0 1 1 2.94 5.16 1 1 0 0 0-1.02 1.72A8 8 0 1 0 2 7.98Zm7-2.9v3.34c0 .27.16.53.4.66l2.63 1.42a.75.75 0 1 0 .72-1.32L10.5 7.98v-2.9a.75.75 0 0 0-1.5 0Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Kp = B(a8, [["render", u8]]),
  c8 = { components: { Icon: he } };
function d8(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "Sliders", viewBox: "-2 -2 24 24" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M6 2.75A.75.75 0 0 0 5.25 2H.75a.75.75 0 0 0-.75.75v1.5c0 .414.336.75.75.75h4.5A.75.75 0 0 0 6 4.25v-1.5Zm14 6a.75.75 0 0 0-.75-.75h-4.5a.75.75 0 0 0-.75.75v1.5c0 .414.336.75.75.75h4.5a.75.75 0 0 0 .75-.75v-1.5Z",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M18 12h-2v6a.997.997 0 0 0 1 1 .997.997 0 0 0 1-1v-6Zm-2-1h2V2a.997.997 0 0 0-1-1 .997.997 0 0 0-1 1v9Zm-3 3.75a.75.75 0 0 0-.75-.75h-4.5a.75.75 0 0 0-.75.75v1.5c0 .414.336.75.75.75h4.5a.75.75 0 0 0 .75-.75v-1.5Z",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M11 14H9v4a.997.997 0 0 0 1 1 .997.997 0 0 0 1-1v-4Zm-2-1h2V2a.997.997 0 0 0-1-1 .997.997 0 0 0-1 1v11ZM4 6H2v12a.997.997 0 0 0 1 1 .997.997 0 0 0 1-1V6ZM2 5h2V2a.997.997 0 0 0-1-1 .997.997 0 0 0-1 1v3Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const ra = B(c8, [["render", d8]]),
  p8 = { class: "DocumentButtons" },
  f8 = S({
    __name: "DocumentButtons",
    setup(t) {
      const e = j(!1),
        n = j(!1),
        s = j(!1);
      function o() {
        s.value = !0;
      }
      const { open: r } = vp();
      return (l, i) => (
        d(),
        C("div", p8, [
          c(
            Yt,
            { flex: "" },
            {
              default: f(() => [
                c(
                  te,
                  {
                    "with-icon": "",
                    onClick: i[0] || (i[0] = (a) => (e.value = !0)),
                  },
                  {
                    default: f(() => [
                      c(es),
                      i[5] || (i[5] = h("span", null, "New", -1)),
                    ]),
                    _: 1,
                  }
                ),
                c(
                  te,
                  { "with-icon": "", onClick: o },
                  {
                    default: f(() => [
                      c(Wo),
                      i[6] || (i[6] = h("span", null, "Open", -1)),
                    ]),
                    _: 1,
                  }
                ),
                c(
                  te,
                  {
                    "with-icon": "",
                    onClick: i[1] || (i[1] = (a) => (n.value = !0)),
                  },
                  {
                    default: f(() => [
                      c(Kp),
                      i[7] || (i[7] = h("span", null, "Recent", -1)),
                    ]),
                    _: 1,
                  }
                ),
              ]),
              _: 1,
            }
          ),
          c(
            te,
            { icon: "", onClick: y(r) },
            { default: f(() => [c(ra), c(Te, { text: "Preferences" })]), _: 1 },
            8,
            ["onClick"]
          ),
          c(Oe, null, {
            default: f(() => [
              e.value
                ? (d(),
                  w(qp, {
                    key: 0,
                    onClose: i[2] || (i[2] = (a) => (e.value = !1)),
                  }))
                : z("", !0),
            ]),
            _: 1,
          }),
          c(Oe, null, {
            default: f(() => [
              n.value
                ? (d(),
                  w(Zp, {
                    key: 0,
                    onClose: i[3] || (i[3] = (a) => (n.value = !1)),
                  }))
                : z("", !0),
            ]),
            _: 1,
          }),
          c(Oe, null, {
            default: f(() => [
              s.value
                ? (d(),
                  w(Gp, {
                    key: 0,
                    onClose: i[4] || (i[4] = (a) => (s.value = !1)),
                  }))
                : z("", !0),
            ]),
            _: 1,
          }),
        ])
      );
    },
  }),
  Xp = B(f8, [["__scopeId", "data-v-88f401a1"]]),
  h8 = { components: { Icon: he } };
function m8(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      {
        class: "Keyboard",
        viewBox: "-2 0 20 10",
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        "stroke-linejoin": "round",
        "stroke-linecap": "round",
        "stroke-miterlimit": "2",
      },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M16 1c0-.6-.4-1-1-1H1a1 1 0 0 0-1 1v8c0 .6.4 1 1 1h14c.6 0 1-.4 1-1V1ZM3 7H1v2h2V7Zm12 0h-2v2h2V7Zm-3 0H4v2h8V7ZM4.5 4h-2v2h2V4Zm1 0h2v2h-2V4Zm3 0h2v2h-2V4Zm3 0h2v2h-2V4ZM4 1h2v2H4V1Zm3 0h2v2H7V1Zm3 0h2v2h-2V1Zm3 0h2v2h-2V1ZM1 1h2v2H1V1Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const g8 = B(h8, [["render", m8]]),
  v8 = { class: "icon" },
  y8 = S({
    __name: "CustomInput",
    setup(t) {
      return (e, n) => (
        d(),
        w(
          be,
          { class: "CustomInput", align: "center" },
          {
            default: f(() => [
              c(
                vt,
                {
                  placeholder: "Custom value",
                  value: y(ye).getCurrentValue(),
                  "onUpdate:value":
                    n[0] ||
                    (n[0] = (s, o) => {
                      y(ye).triggerInput(s, !0) && o.preventDefault();
                    }),
                },
                null,
                8,
                ["value"]
              ),
              h("div", v8, [c(g8, { inline: "" })]),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  C8 = B(y8, [["__scopeId", "data-v-a2f4a29f"]]),
  w8 = { components: { Icon: he } };
function b8(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "CandidatesBox", viewBox: "0 0 20 20" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M17 19.5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm-13 0a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0ZM16 3H4v-.5a.5.5 0 0 0-.15-.35.5.5 0 0 0-.7 0A.5.5 0 0 0 3 2.5V3h-.5a.5.5 0 0 0-.35.15.5.5 0 0 0 0 .7c.09.1.22.15.35.15H3v12h-.5a.5.5 0 0 0-.35.15.5.5 0 0 0 0 .7c.09.1.22.15.35.15H3v.5c0 .13.05.26.15.35a.5.5 0 0 0 .7 0A.5.5 0 0 0 4 17.5V17h12v.5c0 .13.05.26.15.35a.5.5 0 0 0 .7 0 .5.5 0 0 0 .15-.35V17h.5a.5.5 0 0 0 .35-.15.5.5 0 0 0 0-.7.5.5 0 0 0-.35-.15H17V4h.5a.5.5 0 0 0 .35-.15.5.5 0 0 0 0-.7.5.5 0 0 0-.35-.15H17v-.5a.5.5 0 0 0-.15-.35.5.5 0 0 0-.7 0 .5.5 0 0 0-.15.35V3ZM1 16.5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm19 0a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0ZM4 16h12V4H4v12ZM20 3.5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm-19 0a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm16-3a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0ZM4 .5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Z",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M8.3 12.22h.52V7.88H8.3l-1.13.83v.57l1.08-.8h.04v3.74ZM10.06 9.1h.51c0-.51.34-.85.83-.85.47 0 .83.33.83.77 0 .35-.13.58-.68 1.19l-1.46 1.64v.37h2.74v-.48h-1.98v-.05l1.02-1.13c.7-.76.9-1.11.9-1.56 0-.7-.6-1.22-1.35-1.22-.79 0-1.36.55-1.36 1.32Z",
                  "fill-rule": "nonzero",
                  stroke: "currentColor",
                  "stroke-width": ".2",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const k8 = B(w8, [["render", b8]]),
  _8 = { components: { Icon: he } };
function $8(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      {
        class: "ColorsBox",
        viewBox: "0 0 20 20",
        "xmlns:xlink": "http://www.w3.org/1999/xlink",
      },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "g",
                { transform: "translate(3.8 3.8) scale(0.62)" },
                [
                  h("image", {
                    "xlink:href":
                      "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAQCAwMDAgQDAwMEBAQEBQkGBQUFBQsICAYJDQsNDQ0LDAwOEBQRDg8TDwwMEhgSExUWFxcXDhEZGxkWGhQWFxb/2wBDAQQEBAUFBQoGBgoWDwwPFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhb/wAARCAAUABQDAREAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAABwgG/8QAJxAAAQMDAwMEAwAAAAAAAAAAAQIDBAAFBhEhMQcSExVRcbEiYWL/xAAYAQEBAQEBAAAAAAAAAAAAAAAHBQgJA//EACcRAAEDAwMDBAMAAAAAAAAAAAEAAgMEBREGITEHQWESE1GRIjLh/9oADAMBAAIRAxEAPwClsmesvU3E3o0V1r1UNHsRqNXtuB/X38807naJqfLsbJBpY6qxVYe8H28/X8QT0XxqU7LkR1MKBiyFsrBHBSog/VButK9lLIWE7pKvlwjaxr8/sAfsZTXCsLTUZKFlIIollr5XuJAR7LdG+s7qQLblF7akpVbJT0dYP4rQsgj40rpa5ol2c0EeVXvWr4qWFxeA7wQCnjCczvNrtMeVeFNTVzx5JUnwIbcLnBKigAKJABKjqonUkkkmsydUdCUr7m6ugBAcBt2BG2w7Z8LOEvUK4VFbJFI7EYP4gcNHwPA7fHA2AC3ETL4LzAc9/wB0MPsRY7GFTZqAuGcqT8YYbVNaBTt3V0H4acL11LVyuBBKaWWkKxdoEbDUCj3VMLJIT6ghaVxFW4rPLlPxllppZCQdh7UFVdNEJiAFcimeGcr/2Q==",
                  }),
                ],
                -1
              ),
              h(
                "path",
                {
                  d: "M17 19.5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm-13 0a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0ZM16 3H4v-.5a.5.5 0 0 0-.15-.35.5.5 0 0 0-.7 0A.5.5 0 0 0 3 2.5V3h-.5a.5.5 0 0 0-.35.15.5.5 0 0 0 0 .7c.09.1.22.15.35.15H3v12h-.5a.5.5 0 0 0-.35.15.5.5 0 0 0 0 .7c.09.1.22.15.35.15H3v.5c0 .13.05.26.15.35a.5.5 0 0 0 .7 0A.5.5 0 0 0 4 17.5V17h12v.5c0 .13.05.26.15.35a.5.5 0 0 0 .7 0 .5.5 0 0 0 .15-.35V17h.5a.5.5 0 0 0 .35-.15.5.5 0 0 0 0-.7.5.5 0 0 0-.35-.15H17V4h.5a.5.5 0 0 0 .35-.15.5.5 0 0 0 0-.7.5.5 0 0 0-.35-.15H17v-.5a.5.5 0 0 0-.15-.35.5.5 0 0 0-.7 0 .5.5 0 0 0-.15.35V3ZM1 16.5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm19 0a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0ZM4 16h12V4H4v12ZM20 3.5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm-19 0a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm16-3a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0ZM4 .5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const S8 = B(_8, [
    ["render", $8],
    ["__scopeId", "data-v-a5550bc8"],
  ]),
  I8 = { components: { Icon: he } };
function x8(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "CornersBox", viewBox: "0 0 20 20" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M17 19.5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm-13 0a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0ZM16 3H4v-.5a.5.5 0 0 0-.15-.35.5.5 0 0 0-.7 0A.5.5 0 0 0 3 2.5V3h-.5a.5.5 0 0 0-.35.15.5.5 0 0 0 0 .7c.09.1.22.15.35.15H3v12h-.5a.5.5 0 0 0-.35.15.5.5 0 0 0 0 .7c.09.1.22.15.35.15H3v.5c0 .13.05.26.15.35a.5.5 0 0 0 .7 0A.5.5 0 0 0 4 17.5V17h12v.5c0 .13.05.26.15.35a.5.5 0 0 0 .7 0 .5.5 0 0 0 .15-.35V17h.5a.5.5 0 0 0 .35-.15.5.5 0 0 0 0-.7.5.5 0 0 0-.35-.15H17V4h.5a.5.5 0 0 0 .35-.15.5.5 0 0 0 0-.7.5.5 0 0 0-.35-.15H17v-.5a.5.5 0 0 0-.15-.35.5.5 0 0 0-.7 0 .5.5 0 0 0-.15.35V3ZM1 16.5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm19 0a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0ZM4 16h12V4H4v12ZM20 3.5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm-19 0a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm16-3a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0ZM4 .5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Z",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M6.69 8.77h.46v-3.7h-.46l-.98.7v.5l.94-.69h.04v3.19ZM11.9 6.16h.44c0-.44.3-.73.72-.73.41 0 .73.29.73.65 0 .3-.12.5-.6 1.02l-1.27 1.4v.31h2.39V8.4h-1.73v-.04l.89-.96c.6-.65.78-.95.78-1.33 0-.6-.51-1.04-1.17-1.04-.69 0-1.19.47-1.19 1.13ZM6.3 13.27h.48c.52 0 .85.27.85.7 0 .4-.35.7-.84.7-.47 0-.8-.26-.85-.66H5.5c.03.64.55 1.05 1.3 1.05.73 0 1.3-.47 1.3-1.08 0-.5-.3-.85-.8-.92v-.04c.4-.1.64-.42.64-.86 0-.54-.51-.97-1.16-.97-.7 0-1.16.4-1.2 1.04h.44c.04-.4.32-.63.74-.63.43 0 .71.25.71.62 0 .39-.3.66-.71.66H6.3v.4Z",
                  "fill-rule": "nonzero",
                  stroke: "currentColor",
                  "stroke-width": ".2",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const D8 = B(I8, [["render", x8]]),
  M8 = { components: { Icon: he } };
function A8(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "DigitBox", viewBox: "0 0 20 20" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M17 19.5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm-13 0a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0ZM16 3H4v-.5a.5.5 0 0 0-.15-.35.5.5 0 0 0-.7 0A.5.5 0 0 0 3 2.5V3h-.5a.5.5 0 0 0-.35.15.5.5 0 0 0 0 .7c.09.1.22.15.35.15H3v12h-.5a.5.5 0 0 0-.35.15.5.5 0 0 0 0 .7c.09.1.22.15.35.15H3v.5c0 .13.05.26.15.35a.5.5 0 0 0 .7 0A.5.5 0 0 0 4 17.5V17h12v.5c0 .13.05.26.15.35a.5.5 0 0 0 .7 0 .5.5 0 0 0 .15-.35V17h.5a.5.5 0 0 0 .35-.15.5.5 0 0 0 0-.7.5.5 0 0 0-.35-.15H17V4h.5a.5.5 0 0 0 .35-.15.5.5 0 0 0 0-.7.5.5 0 0 0-.35-.15H17v-.5a.5.5 0 0 0-.15-.35.5.5 0 0 0-.7 0 .5.5 0 0 0-.15.35V3ZM1 16.5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm19 0a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0ZM4 16h12V4H4v12ZM20 3.5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm-19 0a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Zm16-3a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0ZM4 .5a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0Z",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M9.83 14.42c2.02 0 3.17-1.66 3.17-4.57 0-.93-.13-1.7-.4-2.35-.51-1.25-1.47-1.92-2.7-1.92A2.8 2.8 0 0 0 7 8.48c0 1.65 1.14 2.84 2.71 2.84.98 0 1.8-.48 2.2-1.3H12c-.06 2.25-.82 3.47-2.16 3.47-.81 0-1.44-.48-1.66-1.28H7.12a2.63 2.63 0 0 0 2.7 2.21Zm.06-4.02c-1.09 0-1.85-.8-1.85-1.95 0-1.1.8-1.95 1.87-1.95 1.05 0 1.86.86 1.86 1.99 0 1.12-.78 1.91-1.88 1.91Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const P8 = B(M8, [["render", A8]]),
  L8 = { components: { Icon: he } };
function E8(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "Backspace", viewBox: "-2 0 21 12" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M5.37.93.65 5.64a.5.5 0 0 0 0 .7l4.72 4.72c.27.28.64.43 1.02.43h8.66c.8 0 1.45-.65 1.45-1.45v-8.1c0-.8-.65-1.45-1.45-1.45H6.39c-.38 0-.75.15-1.02.43Zm.7.7c.09-.08.2-.13.32-.13h8.66c.25 0 .45.2.45.45v8.1c0 .25-.2.45-.45.45H6.39a.45.45 0 0 1-.31-.13L1.7 6l4.37-4.37ZM9.3 6 7.65 7.65a.5.5 0 0 0 .7.7L10 6.71l1.65 1.64a.5.5 0 0 0 .7-.7L10.71 6l1.64-1.65a.5.5 0 0 0-.7-.7L10 5.29 8.35 3.65a.5.5 0 0 0-.7.7L9.29 6Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const F8 = B(L8, [["render", E8]]),
  B8 = { components: { Icon: he } };
function z8(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "Eraser", viewBox: "0 0 20 20" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M6.94 16h8.21a.5.5 0 0 0 0-1h-3.27l4.33-7.5a1 1 0 0 0-.36-1.37l-5.2-3a1 1 0 0 0-1.37.37l-3.5 6.06-2.03 3.53-.07.18-.03.2v.19l.05.18.08.18.11.16.15.13.11.08L6.94 16Zm3.79-1 1.12-1.94-5.2-3-2 3.47L7.2 15h3.53ZM7.15 9.2l5.2 3 3-5.2-5.2-3-3 5.2Z",
                },
                null,
                -1
              ),
              h(
                "path",
                { d: "m13.22 13.88 1.28-1.56.43.98M16.35 14l2.65-.9v.79" },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const R8 = B(B8, [["render", z8]]),
  O8 = { components: { Icon: he } };
function N8(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "RedoIcon", viewBox: "0 0 20 20" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M14.24 8.76 16 7v5h-5l1.83-1.83a3.99 3.99 0 0 0-6.75 2.02c-.09.46-.5.8-.96.8l-.04.01a1 1 0 0 1-.98-1.19 6 6 0 0 1 10.14-3.05Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const T8 = B(O8, [["render", N8]]),
  V8 = {
    components: { Icon: he },
    props: { selectColor: { type: String, default: "#000" } },
  },
  j8 = ["stroke"];
function U8(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "SelectAll", viewBox: "-1 -1 26 26" },
      {
        default: f(() => [
          h(
            "path",
            {
              fill: "none",
              stroke: n.selectColor,
              "stroke-width": "2",
              d: "M1 1h22v22H1z",
            },
            null,
            8,
            j8
          ),
          e[0] ||
            (e[0] = h(
              "path",
              {
                fill: "none",
                stroke: "currentColor",
                d: "M3 3h8v8H3zm0 10h8v8H3zM13 3h8v8h-8zm2.333 17L13 13l7 2.333-1.556 1.556 2.334 2.333-1.556 1.556-2.333-2.334L15.333 20Z",
                "stroke-linejoin": "round",
              },
              null,
              -1
            )),
        ]),
        _: 1,
      }
    )
  );
}
const H8 = B(V8, [["render", U8]]),
  W8 = {
    components: { Icon: he },
    props: { selectColor: { type: String, default: "#000" } },
  },
  Z8 = ["stroke"];
function G8(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "SelectIcon", viewBox: "-1 -1 26 26" },
      {
        default: f(() => [
          h(
            "path",
            {
              d: "M11 11V1h12v12H13v10H1V11h10Z",
              fill: "none",
              stroke: n.selectColor,
              "stroke-width": "2",
            },
            null,
            8,
            Z8
          ),
          e[0] ||
            (e[0] = h(
              "path",
              {
                fill: "none",
                stroke: "currentColor",
                d: "M3 13h8v8H3zM13 3h8v8h-8zm3.333 18L14 14l7 2.333-1.556 1.556 2.334 2.333-1.556 1.556-2.333-2.334L16.333 21Z",
                "stroke-linejoin": "round",
              },
              null,
              -1
            )),
          e[1] ||
            (e[1] = h(
              "path",
              { stroke: "currentColor", d: "M2 5h6M5 2v6" },
              null,
              -1
            )),
        ]),
        _: 1,
      }
    )
  );
}
const q8 = B(W8, [["render", G8]]),
  K8 = { components: { Icon: he } };
function X8(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "UndoIcon", viewBox: "0 0 20 20" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M5.76 8.76 4 7v5h5L7.17 10.17a3.99 3.99 0 0 1 6.75 2.02c.09.46.5.8.96.8l.04.01a1 1 0 0 0 .98-1.19A6 6 0 0 0 5.76 8.76Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Y8 = B(K8, [["render", X8]]),
  J8 = { class: "InputPanel" },
  Q8 = { class: "buttons" },
  e_ = { class: "column" },
  t_ = { class: "grid" },
  n_ = { class: "column" },
  s_ = S({
    __name: "InputPanel",
    props: { buttonSize: {} },
    setup(t) {
      const { editMode: e, setCellEditMode: n, colorMarkingsPage: s } = ke(),
        o = b(() => jt.canUndo()),
        r = b(() => jt.canRedo()),
        l = b(() => `Undo: ${jt.getUndoText()}`),
        i = b(() => `Redo: ${jt.getRedoText()}`),
        a = b(() => ye.getButtons()),
        u = b(() => e.value.type === ie.CellDigit),
        p = b(() => e.value.type === ie.CellCornerPencilMark),
        m = b(() => e.value.type === ie.CellCandidate),
        g = b(() => e.value.type === ie.CellColor),
        v = b(() => {
          var re;
          return (
            ((re = ye.getInputMode()) == null ? void 0 : re.type) ===
            Ke.CosmeticText
          );
        }),
        $ = b(() => {
          const re = ye.getInputMode();
          return (
            (re == null ? void 0 : re.type) !== void 0 && re.type !== Ke.Replace
          );
        }),
        k = b(() => {
          var re;
          return (re = ye.getInputMode()) == null ? void 0 : re.deleteButton;
        }),
        M = b(() => ye.isSelecting()),
        P = b(() => ye.getPagination()),
        x = b(() => {
          const re = P.value.enabled,
            ce = $.value,
            ge = k.value;
          return re && ce
            ? ["pagination", "backspace"]
            : re && ge
            ? ["pagination", "delete"]
            : re
            ? ["pagination", "empty"]
            : [ce ? "backspace" : "empty", ge ? "delete" : "empty"];
        }),
        A = b(() => ({
          ctrl: !1,
          alt: !1,
          meta: !1,
          shift: !1,
          key: "Delete",
          useCode: !1,
        }));
      function O() {
        s.value = ye.openNextPage();
      }
      function V(re) {
        ye.triggerInput(re.input);
      }
      function I() {
        ye.triggerBackspace();
      }
      function U() {
        ye.triggerDelete();
      }
      function D() {
        ye.triggerUndo();
      }
      function N() {
        ye.triggerRedo();
      }
      function E() {
        ye.triggerSelectAll();
      }
      function R() {
        ye.setSelecting(!ye.isSelecting());
      }
      function W() {
        n(ie.CellDigit);
      }
      function T() {
        n(ie.CellCornerPencilMark);
      }
      function Y() {
        n(ie.CellCandidate);
      }
      function J() {
        n(ie.CellColor);
      }
      return (re, ce) => (
        d(),
        C("div", J8, [
          v.value ? (d(), w(C8, { key: 0 })) : z("", !0),
          h("div", Q8, [
            h("div", e_, [
              c(
                pt,
                { disabled: !o.value, onClick: D },
                {
                  default: f(() => [
                    c(Y8),
                    o.value
                      ? (d(),
                        w(Te, { key: 0, text: l.value, delay: "" }, null, 8, [
                          "text",
                        ]))
                      : z("", !0),
                  ]),
                  _: 1,
                },
                8,
                ["disabled"]
              ),
              c(
                pt,
                { disabled: !r.value, onClick: N },
                {
                  default: f(() => [
                    c(T8),
                    r.value
                      ? (d(),
                        w(Te, { key: 0, text: i.value, delay: "" }, null, 8, [
                          "text",
                        ]))
                      : z("", !0),
                  ]),
                  _: 1,
                },
                8,
                ["disabled"]
              ),
              c(
                pt,
                { onClick: E },
                {
                  default: f(() => [
                    c(H8, { "select-color": y(ee).selectionColor }, null, 8, [
                      "select-color",
                    ]),
                    c(
                      Te,
                      { delay: "" },
                      {
                        default: f(() => [
                          ce[3] || (ce[3] = F(" Select all ")),
                          c(
                            pn,
                            { hotkeys: y(kt).getHotkeys("selectAll") },
                            null,
                            8,
                            ["hotkeys"]
                          ),
                        ]),
                        _: 1,
                      }
                    ),
                  ]),
                  _: 1,
                }
              ),
              c(
                pt,
                { active: M.value, onClick: R },
                {
                  default: f(() => [
                    c(q8, { "select-color": y(ee).selectionColor }, null, 8, [
                      "select-color",
                    ]),
                    c(Te, { text: "Toggle select", delay: "" }),
                  ]),
                  _: 1,
                },
                8,
                ["active"]
              ),
            ]),
            h("div", t_, [
              (d(!0),
              C(
                Z,
                null,
                se(
                  a.value,
                  (ge, de) => (
                    d(),
                    w(
                      pt,
                      {
                        key: de,
                        disabled: !ge,
                        onClick: (ze) =>
                          (ge == null ? void 0 : ge.input) && V(ge),
                      },
                      {
                        default: f(() => [
                          ge ? (d(), w(qe(ge.label), { key: 0 })) : z("", !0),
                          ge != null && ge.tooltip
                            ? (d(),
                              w(Te, { key: 1, text: ge.tooltip }, null, 8, [
                                "text",
                              ]))
                            : z("", !0),
                        ]),
                        _: 2,
                      },
                      1032,
                      ["disabled", "onClick"]
                    )
                  )
                ),
                128
              )),
              (d(!0),
              C(
                Z,
                null,
                se(
                  x.value,
                  (ge, de) => (
                    d(),
                    C(
                      Z,
                      { key: de },
                      [
                        ge === "backspace"
                          ? (d(),
                            w(
                              pt,
                              {
                                key: 0,
                                onClick: ce[0] || (ce[0] = (ze) => I()),
                              },
                              {
                                default: f(() => [
                                  c(F8),
                                  c(Te, { text: "Backspace", delay: "" }),
                                ]),
                                _: 1,
                              }
                            ))
                          : ge === "pagination"
                          ? (d(),
                            w(
                              pt,
                              {
                                key: 1,
                                onClick: ce[1] || (ce[1] = (ze) => O()),
                              },
                              {
                                default: f(() => {
                                  var ze;
                                  return [
                                    P.value.enabled
                                      ? (d(),
                                        w(
                                          qe(
                                            (ze = P.value) == null
                                              ? void 0
                                              : ze.label
                                          ),
                                          { key: 0 }
                                        ))
                                      : z("", !0),
                                  ];
                                }),
                                _: 1,
                              }
                            ))
                          : ge === "delete"
                          ? (d(),
                            w(
                              pt,
                              {
                                key: 2,
                                onClick: ce[2] || (ce[2] = (ze) => U()),
                              },
                              {
                                default: f(() => [
                                  c(R8),
                                  c(
                                    Te,
                                    { delay: "" },
                                    {
                                      default: f(() => [
                                        ce[4] ||
                                          (ce[4] = F(" Remove element ")),
                                        c(pn, { hotkeys: A.value }, null, 8, [
                                          "hotkeys",
                                        ]),
                                      ]),
                                      _: 1,
                                    }
                                  ),
                                ]),
                                _: 1,
                              }
                            ))
                          : (d(), w(pt, { key: 3, disabled: "" })),
                      ],
                      64
                    )
                  )
                ),
                128
              )),
            ]),
            h("div", n_, [
              c(
                pt,
                { active: u.value, toggleable: "", onClick: W },
                {
                  default: f(() => [
                    c(P8),
                    c(
                      Te,
                      { delay: "" },
                      {
                        default: f(() => [
                          F(X(y(gs)("setEnterDigits")) + " ", 1),
                          c(
                            pn,
                            { hotkeys: y(kt).getHotkeys("setEnterDigits") },
                            null,
                            8,
                            ["hotkeys"]
                          ),
                        ]),
                        _: 1,
                      }
                    ),
                  ]),
                  _: 1,
                },
                8,
                ["active"]
              ),
              c(
                pt,
                { active: p.value, toggleable: "", onClick: T },
                {
                  default: f(() => [
                    c(D8),
                    c(
                      Te,
                      { delay: "" },
                      {
                        default: f(() => [
                          F(X(y(gs)("setEnterCornerPencilMarks")) + " ", 1),
                          c(
                            pn,
                            {
                              hotkeys: y(kt).getHotkeys(
                                "setEnterCornerPencilMarks"
                              ),
                            },
                            null,
                            8,
                            ["hotkeys"]
                          ),
                        ]),
                        _: 1,
                      }
                    ),
                  ]),
                  _: 1,
                },
                8,
                ["active"]
              ),
              c(
                pt,
                { active: m.value, toggleable: "", onClick: Y },
                {
                  default: f(() => [
                    c(k8),
                    c(
                      Te,
                      { delay: "" },
                      {
                        default: f(() => [
                          F(X(y(gs)("setEnterCandidates")) + " ", 1),
                          c(
                            pn,
                            { hotkeys: y(kt).getHotkeys("setEnterCandidates") },
                            null,
                            8,
                            ["hotkeys"]
                          ),
                        ]),
                        _: 1,
                      }
                    ),
                  ]),
                  _: 1,
                },
                8,
                ["active"]
              ),
              c(
                pt,
                { active: g.value, toggleable: "", onClick: J },
                {
                  default: f(() => [
                    c(S8),
                    c(
                      Te,
                      { delay: "" },
                      {
                        default: f(() => [
                          F(X(y(gs)("setEnterColorMarks")) + " ", 1),
                          c(
                            pn,
                            { hotkeys: y(kt).getHotkeys("setEnterColorMarks") },
                            null,
                            8,
                            ["hotkeys"]
                          ),
                        ]),
                        _: 1,
                      }
                    ),
                  ]),
                  _: 1,
                },
                8,
                ["active"]
              ),
            ]),
          ]),
        ])
      );
    },
  }),
  la = B(s_, [["__scopeId", "data-v-3ffbdf55"]]),
  o_ = S({
    data() {
      return { count: 3, interval: 0 };
    },
    mounted() {
      this.interval = window.setInterval(
        () => (this.count = (this.count + 1) % 4),
        500
      );
    },
    beforeUnmount() {
      clearInterval(this.interval);
    },
    methods: {
      getStyle(t) {
        return { visibility: this.count >= t ? "visible" : "hidden" };
      },
    },
  });
function r_(t, e, n, s, o, r) {
  return (
    d(),
    C(
      Z,
      null,
      [
        h("span", { style: We(t.getStyle(1)) }, ".", 4),
        h("span", { style: We(t.getStyle(2)) }, ".", 4),
        h("span", { style: We(t.getStyle(3)) }, ".", 4),
      ],
      64
    )
  );
}
const l_ = B(o_, [["render", r_]]),
  i_ = { class: "content" },
  a_ = { key: 0, class: "icon" },
  u_ = ["textContent"],
  c_ = { key: 0, class: "duration" },
  d_ = { key: 0, class: "solvingProgress" },
  p_ = S({
    __name: "LogsView",
    props: { logs: {}, solving: { type: Boolean } },
    emits: ["stopSolver"],
    setup(t) {
      const e = t,
        n = j(),
        s = j(),
        o = b(() => e.logs.lines);
      function r() {
        Nn.stop();
      }
      function l(a) {
        return `took ${K0.format(a)}s`;
      }
      const i = b(() => kt.getHotkeys("stopSolver"));
      return (
        ot(
          "stopSolver",
          r,
          b(() => e.solving)
        ),
        b1(() => {
          wn(() => {
            n.value.scrollTo({ top: s.value.offsetHeight });
          });
        }),
        (a, u) => (
          d(),
          C(
            "div",
            { ref_key: "toScroll", ref: n, class: "LogsView" },
            [
              h(
                "ol",
                { ref_key: "list", ref: s },
                [
                  (d(!0),
                  C(
                    Z,
                    null,
                    se(
                      o.value,
                      (p, m) => (
                        d(),
                        C(
                          "li",
                          {
                            key: m,
                            class: Ae([p.type, { outOfDate: p.outOfDate }]),
                          },
                          [
                            h("div", i_, [
                              typeof p.icon == "object"
                                ? (d(), C("span", a_, [(d(), w(qe(p.icon)))]))
                                : p.icon
                                ? (d(),
                                  C(
                                    "span",
                                    { key: 1, textContent: X(p.icon) },
                                    null,
                                    8,
                                    u_
                                  ))
                                : z("", !0),
                              F(" " + X(p.text), 1),
                            ]),
                            p.duration
                              ? (d(), C("div", c_, X(l(p.duration)), 1))
                              : z("", !0),
                          ],
                          2
                        )
                      )
                    ),
                    128
                  )),
                  a.solving
                    ? (d(),
                      C("li", d_, [
                        h("strong", null, [
                          u[0] || (u[0] = F(" Solving")),
                          c(l_),
                        ]),
                        c(
                          te,
                          { class: "cancelButton", size: "small", onClick: r },
                          {
                            default: f(() => [
                              u[1] ||
                                (u[1] = h("span", null, " Stop solving ", -1)),
                              c(pn, { hotkeys: i.value }, null, 8, ["hotkeys"]),
                            ]),
                            _: 1,
                          }
                        ),
                      ]))
                    : z("", !0),
                ],
                512
              ),
            ],
            512
          )
        )
      );
    },
  }),
  f_ = B(p_, [["__scopeId", "data-v-d4cb69a7"]]),
  h_ = { class: "logicStepName" },
  m_ = ["innerHTML"],
  g_ = { key: 0 },
  v_ = { key: 0, class: "secondary" },
  y_ = S({
    __name: "LogicStepItem",
    props: {
      name: {},
      info: {},
      description: {},
      examples: {},
      selected: { type: Boolean },
      disabled: { type: Boolean },
    },
    emits: ["update:selected"],
    setup(t) {
      const e = t,
        n = b(() => (e.description ? Et(e.description) : []));
      return (s, o) => (
        d(),
        C(
          "div",
          { class: Ae(["LogicStepItem", { selected: s.selected }]) },
          [
            c(
              ve,
              { disabled: s.disabled, clickable: "" },
              {
                label: f(() => [
                  h("span", h_, X(s.name), 1),
                  o[5] || (o[5] = F(" " + X(" ") + " ")),
                  s.info
                    ? (d(),
                      w(
                        dt,
                        {
                          key: 0,
                          "as-info": "",
                          onClick:
                            o[0] || (o[0] = st(() => {}, ["prevent", "stop"])),
                        },
                        { default: f(() => [F(X(s.info), 1)]), _: 1 }
                      ))
                    : z("", !0),
                  n.value.length > 0
                    ? (d(),
                      w(
                        dt,
                        {
                          key: 1,
                          onClick:
                            o[1] || (o[1] = st(() => {}, ["prevent", "stop"])),
                        },
                        {
                          default: f(() => [
                            (d(!0),
                            C(
                              Z,
                              null,
                              se(
                                n.value,
                                (r, l) => (
                                  d(),
                                  C("p", { key: l, innerHTML: r }, null, 8, m_)
                                )
                              ),
                              128
                            )),
                            s.examples
                              ? (d(),
                                C("p", g_, [
                                  o[3] ||
                                    (o[3] = h(
                                      "strong",
                                      null,
                                      "Applied when there are constraints such as:",
                                      -1
                                    )),
                                  o[4] || (o[4] = h("br", null, null, -1)),
                                  F(" " + X(s.examples), 1),
                                ]))
                              : z("", !0),
                          ]),
                          _: 1,
                        }
                      ))
                    : z("", !0),
                ]),
                default: f(({ controlId: r }) => [
                  c(
                    Ao,
                    {
                      id: r,
                      checked: s.selected,
                      "onUpdate:checked":
                        o[2] || (o[2] = (l) => s.$emit("update:selected", l)),
                    },
                    null,
                    8,
                    ["id", "checked"]
                  ),
                ]),
                _: 1,
              },
              8,
              ["disabled"]
            ),
            s.selected && s.$slots.default
              ? (d(), C("div", v_, [G(s.$slots, "default", {}, void 0, !0)]))
              : z("", !0),
          ],
          2
        )
      );
    },
  }),
  ai = B(y_, [["__scopeId", "data-v-8dd40483"]]);
var Re = ((t) => (
  (t.NakedSets = "nakedSets"),
  (t.HiddenSets = "hiddenSets"),
  (t.PointingSets = "pointingSets"),
  (t.XWings = "xWings"),
  (t.Fishes = "fishes"),
  (t.YWings = "yWings"),
  (t.FinnedXWings = "skyscrapers"),
  (t.UnorthodoxNakedSet = "unorthodoxNakedSets"),
  (t.SimpleSums = "simpleSumsLogic"),
  (t.ConsecutiveSets = "consecutiveSetsLogic"),
  (t.KropkiDots = "kropkiDotsLogic"),
  (t.UnorthodoxFishes = "unorthodoxFishes"),
  (t.ByContradiction = "byContradiction"),
  t
))(Re || {});
const C_ = {
    [Re.NakedSets]: { name: "Naked pairs/triples/etc." },
    [Re.HiddenSets]: { name: "Hidden pairs/triples/etc." },
    [Re.PointingSets]: {
      name: "Pointing pairs/triples/etc.",
      info: "Also applied on constraints when the solver has deduced a digit is required in a group of cells other than the standard houses.",
    },
    [Re.XWings]: { name: "X-Wings" },
    [Re.Fishes]: { name: "Swordfishes and Jellyfishes" },
    [Re.YWings]: { name: "Y-Wings" },
    [Re.FinnedXWings]: { name: "Finned X-wings" },
    [Re.UnorthodoxNakedSet]: {
      name: "Unorthodox naked pairs/triples/etc.",
      examples: "Killer cages, anti-king, anti-knight, diagonals",
      description:
        "Similar to normal naked pairs/triples/etc., but also takes constraints into account like cages, chess-move constraints etc.",
    },
    [Re.SimpleSums]: {
      name: "Basic sum logic",
      examples: "Killer cages, region sums, arrows",
      description: [
        "When a group of cells require digits due to a sum constraint, this removes those digits from all cells seen by all cells of that group.",
        "When a group of cells require digits due to a sum constraint, and those digits are confined to a house, removes those digits from all other cells in that house.",
      ],
    },
    [Re.ConsecutiveSets]: {
      name: "Consecutive sets logic",
      examples: "Renban lines",
      description: [
        "For every group of cells that requires a set of consecutive digits, this removes digits that cannot make a consecutive set that is big enough.",
        "When a group of cells requiring a set of consecutive digits <em>must</em> contain digits, this removes those digits from all cells seen by all cells of that group.",
      ],
    },
    [Re.KropkiDots]: {
      name: "Pointing difference/ratio pairs",
      examples: "Kropki dots",
      description:
        "When the amount of candidates for a difference or ratio pair is reduced to only 3, and every candidate has a friend in the opposite cell, this removes the middle digit from all cells seen by that pair.",
    },
    [Re.UnorthodoxFishes]: {
      name: "Unorthodox X-wings & other Fishes",
      examples: "Quadruples, look-and-say cages",
      description:
        "When a group of cells requires a digit X times and that group spans for instance X rows, this removes that digit from all other cells of those rows not part of the group.",
    },
    [Re.ByContradiction]: {
      name: "By contradiction",
      description:
        "See if setting a cell to one of its candidates and all consequential naked singles results in a broken Sudoku. If so, this removes that digit from that cell.",
    },
  },
  w_ = { class: "LogicStepSelector" },
  b_ = S({
    __name: "LogicStepSelector",
    props: { value: {} },
    emits: ["update:value"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = b(() =>
          Object.entries(C_).map(([i, a]) => {
            const u = Array.isArray(a.description)
              ? a.description
              : a.description
              ? [a.description]
              : [];
            return {
              type: i,
              name: a.name,
              examples: a.examples,
              info: a.info,
              description: u,
            };
          })
        );
      function r(i) {
        return n.value.includes(i);
      }
      function l(i, a) {
        const u = r(i);
        a !== u &&
          (r(i)
            ? s("update:value", mn(n.value, [i]))
            : s("update:value", [...n.value, i]));
      }
      return (i, a) => (
        d(),
        C("div", w_, [
          (d(!0),
          C(
            Z,
            null,
            se(
              o.value,
              (u) => (
                d(),
                w(
                  ai,
                  {
                    key: u.type,
                    name: u.name,
                    description: u.description,
                    info: u.info,
                    examples: u.examples,
                    selected: r(u.type),
                    "onUpdate:selected": (p) => l(u.type, p),
                  },
                  {
                    default: f(() => [G(i.$slots, u.type, {}, void 0, !0)]),
                    _: 2,
                  },
                  1032,
                  [
                    "name",
                    "description",
                    "info",
                    "examples",
                    "selected",
                    "onUpdate:selected",
                  ]
                )
              )
            ),
            128
          )),
        ])
      );
    },
  }),
  Ou = B(b_, [["__scopeId", "data-v-98d40cad"]]),
  k_ = 1,
  vs = xs({
    name: "logicalSolverSettings",
    version: k_,
    getDefault() {
      return {
        strategy: {
          stepTypes: [
            Re.NakedSets,
            Re.HiddenSets,
            Re.PointingSets,
            Re.XWings,
            Re.Fishes,
            Re.YWings,
            Re.FinnedXWings,
            Re.ByContradiction,
            Re.UnorthodoxNakedSet,
            Re.SimpleSums,
            Re.ConsecutiveSets,
            Re.KropkiDots,
            Re.UnorthodoxFishes,
          ],
          useRandomness: !0,
        },
      };
    },
  }),
  __ = 1,
  It = xs({
    name: "solverSettings",
    version: __,
    getDefault() {
      return {
        solutionCountLimit: 1e4,
        solveTimeLimit: 60,
        strategy: { stepTypes: [], useRandomness: !0 },
      };
    },
  }),
  $_ = S({
    components: { ExpandVertically: ns },
    props: {
      open: { type: Boolean, default: !1 },
      manualOpen: { type: Boolean, default: !1 },
    },
    emits: { toggle: (t) => !0 },
    data() {
      return { internalOpen: !1 };
    },
    watch: {
      open: {
        immediate: !0,
        handler(t) {
          this.manualOpen && (this.internalOpen = t);
        },
      },
    },
    methods: {
      toggle() {
        this.manualOpen
          ? this.$emit("toggle", !this.open)
          : (this.internalOpen = !this.internalOpen);
      },
    },
  }),
  S_ = { class: "Collapsible" },
  I_ = { key: 0, class: "body" },
  x_ = { class: "bodyWrapper" };
function D_(t, e, n, s, o, r) {
  const l = H("ExpandVertically");
  return (
    d(),
    C("div", S_, [
      h(
        "div",
        {
          class: "header",
          onClick: e[0] || (e[0] = (...i) => t.toggle && t.toggle(...i)),
        },
        [G(t.$slots, "header", {}, void 0, !0)]
      ),
      c(l, null, {
        default: f(() => [
          t.internalOpen
            ? (d(),
              C("div", I_, [
                h("div", x_, [G(t.$slots, "default", {}, void 0, !0)]),
              ]))
            : z("", !0),
        ]),
        _: 3,
      }),
    ])
  );
}
const M_ = B($_, [
    ["render", D_],
    ["__scopeId", "data-v-c9721c99"],
  ]),
  A_ = S({
    __name: "ToggleRow",
    props: { checked: { type: Boolean }, disabled: { type: Boolean } },
    emits: ["update:checked"],
    setup(t) {
      return (e, n) => (
        d(),
        w(
          ve,
          { class: "ToggleRow", disabled: e.disabled, clickable: "" },
          {
            label: f(() => [G(e.$slots, "default", {}, void 0, !0)]),
            default: f(({ controlId: s }) => [
              c(
                Ao,
                {
                  id: s,
                  checked: e.checked,
                  "onUpdate:checked":
                    n[0] || (n[0] = (o) => e.$emit("update:checked", o)),
                },
                null,
                8,
                ["id", "checked"]
              ),
            ]),
            _: 3,
          },
          8,
          ["disabled"]
        )
      );
    },
  }),
  xn = B(A_, [["__scopeId", "data-v-659cc5ca"]]),
  Nu =
    "When enabled and the solver needs to pick a cell from multiple cells that are considered ‘equally’ restricted, it will pick a random one. When disabled, it picks the ‘first’ one.",
  P_ = S({
    __name: "SolverSettings",
    emits: ["close"],
    setup(t) {
      const e = j("logical"),
        n = [
          { id: "logical", label: "Logical solver" },
          { id: "solutionsFinder", label: "Solutions finder" },
        ],
        s = "Sudoku Maker",
        o = Re.ByContradiction;
      return (r, l) => (
        d(),
        w(
          Bt,
          {
            class: "SolverSettings",
            variant: "responsive",
            onClose: l[7] || (l[7] = (i) => r.$emit("close")),
          },
          {
            default: f(() => [
              c(un, null, {
                default: f(() => l[8] || (l[8] = [F("Solver settings")])),
                _: 1,
              }),
              c(
                ts,
                {
                  "active-tab": e.value,
                  "onUpdate:activeTab": l[0] || (l[0] = (i) => (e.value = i)),
                  tabs: n,
                },
                null,
                8,
                ["active-tab"]
              ),
              e.value === "logical"
                ? (d(),
                  w(
                    be,
                    { key: 0, vertical: "", gap: "" },
                    {
                      default: f(() => [
                        h("div", null, [
                          l[10] || (l[10] = h("h4", null, "Logical steps", -1)),
                          c(ai, {
                            name: "Naked and hidden singles",
                            selected: "",
                            disabled: "",
                            info: "This logical step cannot be disabled",
                          }),
                          c(
                            Ou,
                            {
                              value: y(vs).strategy.stepTypes,
                              "onUpdate:value":
                                l[2] ||
                                (l[2] = (i) => (y(vs).strategy.stepTypes = i)),
                            },
                            {
                              [y(o)]: f(() => [
                                c(
                                  xn,
                                  {
                                    checked: y(vs).strategy.useRandomness,
                                    "onUpdate:checked":
                                      l[1] ||
                                      (l[1] = (i) =>
                                        (y(vs).strategy.useRandomness = i)),
                                  },
                                  {
                                    default: f(() => [
                                      l[9] ||
                                        (l[9] = F(
                                          " Try out restricted cells at random "
                                        )),
                                      c(dt, null, {
                                        default: f(() => [F(X(Nu))]),
                                        _: 1,
                                      }),
                                    ]),
                                    _: 1,
                                  },
                                  8,
                                  ["checked"]
                                ),
                              ]),
                              _: 2,
                            },
                            1032,
                            ["value"]
                          ),
                        ]),
                      ]),
                      _: 1,
                    }
                  ))
                : e.value === "solutionsFinder"
                ? (d(),
                  w(
                    be,
                    { key: 1, vertical: "", gap: "" },
                    {
                      default: f(() => [
                        c(
                          ve,
                          { label: "Time limit per solution:" },
                          {
                            default: f(() => [
                              c(
                                Ht,
                                {
                                  value: y(It).solveTimeLimit,
                                  "onUpdate:value":
                                    l[3] ||
                                    (l[3] = (i) => (y(It).solveTimeLimit = i)),
                                  min: 1,
                                  max: 99999,
                                },
                                null,
                                8,
                                ["value"]
                              ),
                              l[11] ||
                                (l[11] = h(
                                  "span",
                                  { class: "inputUnit" },
                                  "seconds",
                                  -1
                                )),
                            ]),
                            _: 1,
                          }
                        ),
                        h("div", null, [
                          c(
                            ve,
                            { label: "Solution amount limit:" },
                            {
                              default: f(() => [
                                c(
                                  Ht,
                                  {
                                    value: y(It).solutionCountLimit,
                                    "onUpdate:value":
                                      l[4] ||
                                      (l[4] = (i) =>
                                        (y(It).solutionCountLimit = i)),
                                    min: 1,
                                    max: 999999,
                                  },
                                  null,
                                  8,
                                  ["value"]
                                ),
                              ]),
                              _: 1,
                            }
                          ),
                        ]),
                        c(M_, null, {
                          header: f(
                            () =>
                              l[12] ||
                              (l[12] = [
                                h("strong", null, "Advanced settings", -1),
                              ])
                          ),
                          default: f(() => [
                            c(
                              be,
                              { vertical: "", gap: "" },
                              {
                                default: f(() => [
                                  c(lt, null, {
                                    default: f(() => [
                                      h(
                                        "p",
                                        null,
                                        " In general the default settings for the solver should be fine. But since " +
                                          X(y(s)) +
                                          " is still in development, tweaking these settings might improve the solver for certain puzzles. ",
                                        1
                                      ),
                                    ]),
                                    _: 1,
                                  }),
                                  h("div", null, [
                                    c(
                                      xn,
                                      {
                                        checked: y(It).strategy.useRandomness,
                                        "onUpdate:checked":
                                          l[5] ||
                                          (l[5] = (i) =>
                                            (y(It).strategy.useRandomness = i)),
                                      },
                                      {
                                        default: f(() => [
                                          l[13] ||
                                            (l[13] = F(
                                              " Non-deterministic solve "
                                            )),
                                          c(dt, null, {
                                            default: f(() => [F(X(Nu))]),
                                            _: 1,
                                          }),
                                        ]),
                                        _: 1,
                                      },
                                      8,
                                      ["checked"]
                                    ),
                                  ]),
                                  h("div", null, [
                                    l[14] ||
                                      (l[14] = h(
                                        "h4",
                                        null,
                                        "Logical steps to try before brute-forcing",
                                        -1
                                      )),
                                    h("div", null, [
                                      c(ai, {
                                        name: "Naked and hidden singles",
                                        selected: "",
                                        disabled: "",
                                        info: "This logical step cannot be disabled",
                                      }),
                                      c(
                                        Ou,
                                        {
                                          value: y(It).strategy.stepTypes,
                                          "onUpdate:value":
                                            l[6] ||
                                            (l[6] = (i) =>
                                              (y(It).strategy.stepTypes = i)),
                                        },
                                        null,
                                        8,
                                        ["value"]
                                      ),
                                    ]),
                                  ]),
                                ]),
                                _: 1,
                              }
                            ),
                          ]),
                          _: 1,
                        }),
                      ]),
                      _: 1,
                    }
                  ))
                : z("", !0),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  L_ = B(P_, [["__scopeId", "data-v-b27b1b2b"]]),
  E_ = { components: { Icon: he } };
function F_(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      {
        class: "SingleStep",
        viewBox: "0 0 20 20",
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-miterlimit": "1.5",
      },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "g",
                { transform: "translate(0.5 0.5)" },
                [
                  h("path", {
                    class: "colored",
                    d: "M11.83 4.42s-2.72-.56-3.18-.49c-.46.06-1.64.75-1.77.74 0 0-3-.01-3.12 2.2l-.9 1.06c-.3.4-.68 1.34-.67 2.35.03 2.3 2.38 2.71 3.32 2.67.18 0 .7.16 1.57.36.2.11.47.23.73.31.44.16 1.53.9 1.47.93.33.3 1.18.74 2.2.74 1.98 0 3.12-1.88 3.24-2.37.03-.12 1.03-.72 1.03-1.79 0-.26.37-2.32.37-2.73 0-.53-.75-2.08-1.78-2.91a5.46 5.46 0 0 0-2.5-1.07Z",
                    fill: "#e57ca1",
                  }),
                  h("g", { fill: "none", stroke: "currentColor" }, [
                    h("path", {
                      d: "M10.66 4.43s-.8-.71-1.87-.71c-.62 0-1.33.25-2.04.98 0 0-2.83-.2-2.98 2.45 0 0-1.8.18-1.77 3.08.03 2.66 2.53 2.98 3.62 2.93a2.62 2.62 0 0 0 2.21-1.47",
                    }),
                    h("path", {
                      d: "M3.77 7.15s-.14 1.56 1.36 1.56H6.3m0 0s1.04-.02 1.02-.78m-1.02.78s.86.62.82 1.26m6.64.98c-2.18.06-2.5 2.2-4.3 2.92-1.46.58-3.16-.83-3.16-.83m2.28-6.69s.85-2.1 3.25-2.1S15.1 6.4 15.1 6.4s1.41.64 1.41 2.05c0 1.4-.84 1.58-.84 1.58",
                    }),
                    h("path", {
                      d: "M8.65 14.02s.6 1.48 2.87 1.48 3.24-2 3.38-2.55c0 0 1-.6 1-1.95 0-1.34-1.42-2.6-2.66-2.6h-1.4s-1.36-.08-1.45.82",
                    }),
                    h("path", { d: "M13.04 7.12c0 .64.07.8.54 1.3" }),
                  ]),
                ],
                -1
              ),
              h("path", { d: "M14.5 12v5l4.5-2.5-4.5-2.5Z" }, null, -1),
              h(
                "path",
                {
                  d: "m14.99 11.13 4.5 2.5a1 1 0 0 1 0 1.74l-4.5 2.5A1 1 0 0 1 13.5 17v-5a1 1 0 0 1 1.49-.87Zm-.49.87v5l4.5-2.5-4.5-2.5Z",
                  fill: "var(--mainBgColor)",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Yp = B(E_, [
    ["render", F_],
    ["__scopeId", "data-v-14199ef4"],
  ]),
  B_ = { components: { Icon: he } };
function z_(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      {
        class: "AutoStep",
        viewBox: "0 0 20 20",
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-miterlimit": "1.5",
      },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  class: "colored",
                  d: "M11.83 4.42s-2.72-.56-3.18-.49c-.46.06-1.64.75-1.77.74 0 0-3-.01-3.12 2.2l-.9 1.06c-.3.4-.68 1.34-.67 2.35.03 2.3 2.38 2.71 3.32 2.67.18 0 .7.16 1.57.36.2.11.47.23.73.31.44.16 1.53.9 1.47.93.33.3 1.18.74 2.2.74 1.98 0 3.12-1.88 3.24-2.37.03-.12 1.03-.72 1.03-1.79 0-.26.37-2.32.37-2.73 0-.53-.75-2.08-1.78-2.91a5.46 5.46 0 0 0-2.5-1.07Z",
                  fill: "#e57ca1",
                },
                null,
                -1
              ),
              h(
                "g",
                { fill: "none", stroke: "currentColor" },
                [
                  h("path", {
                    d: "M10.66 4.43s-.8-.71-1.87-.71c-.62 0-1.33.25-2.04.98 0 0-2.83-.2-2.98 2.45 0 0-1.8.18-1.77 3.08.03 2.66 2.53 2.98 3.62 2.93a2.62 2.62 0 0 0 2.21-1.47",
                  }),
                  h("path", {
                    d: "M3.77 7.15s-.14 1.56 1.36 1.56H6.3m0 0s1.04-.02 1.02-.78m-1.02.78s.86.62.82 1.26m6.64.98c-2.18.06-2.5 2.2-4.3 2.92-1.46.58-3.16-.83-3.16-.83m2.28-6.69s.85-2.1 3.25-2.1S15.1 6.4 15.1 6.4s1.41.64 1.41 2.05c0 1.4-.84 1.58-.84 1.58",
                  }),
                  h("path", {
                    d: "M8.65 14.02s.6 1.48 2.87 1.48 3.24-2 3.38-2.55c0 0 1-.6 1-1.95 0-1.34-1.42-2.6-2.66-2.6h-1.4s-1.36-.08-1.45.82",
                  }),
                  h("path", { d: "M13.04 7.12c0 .64.07.8.54 1.3" }),
                ],
                -1
              ),
              h(
                "path",
                {
                  d: "m10.49 11.13 3.01 1.67V12a1 1 0 0 1 1.49-.87l4.5 2.5a1 1 0 0 1 0 1.74l-4.5 2.5A1 1 0 0 1 13.5 17v-.8l-3.01 1.67A1 1 0 0 1 9 17v-5a1 1 0 0 1 1.49-.87Zm4.01.87v5l4.5-2.5-4.5-2.5Zm0 2.5L10 12v5l4.5-2.5Zm1 0v.8l1.44-.8-1.44-.8v.8Zm-3.06 0L11 13.7v1.6l1.44-.8Z",
                  fill: "var(--mainBgColor)",
                },
                null,
                -1
              ),
              h(
                "path",
                { d: "M10 12v5l4.5-2.5V17l4.5-2.5-4.5-2.5v2.5L10 12Z" },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const R_ = B(B_, [
  ["render", z_],
  ["__scopeId", "data-v-38b0ccef"],
]);
var ss = ((t) => (
  (t[(t.None = 0)] = "None"),
  (t[(t.Step = 1)] = "Step"),
  (t[(t.FindSolutions = 2)] = "FindSolutions"),
  t
))(ss || {});
const tn = j(!0),
  Zt = j(0);
function cl(t) {
  const { solverLogs: e } = ke();
  if (t instanceof yp) {
    e.value.logInfo("Stopped the solver (puzzle was modified)");
    return;
  }
  const n = t;
  n.message && e.value.logError(n.message);
}
ae(vs, () => {
  Nn.resetLogicalSolver(), (tn.value = !0);
});
class ia {
  constructor(e) {
    L(this, "stateBeforeSolve", this.getState());
    L(this, "actionId", fe());
    this.name = e;
  }
  record() {
    const { project: e, solverLogs: n } = ke(),
      s = this.getState();
    jt.executeAndRecord(
      () => {
        e.value.updateFromData(s.cellData),
          n.value.set(s.logs),
          (Zt.value = s.lastSolverAction);
      },
      () => {
        Nn.stop(),
          e.value.updateFromData(this.stateBeforeSolve.cellData),
          n.value.set(this.stateBeforeSolve.logs),
          (Zt.value = this.stateBeforeSolve.lastSolverAction),
          (tn.value = !0);
      },
      this.name,
      {
        id: this.actionId,
        type: qr.Overwrite,
        lookbackAmount: 1 / 0,
        allowRewrite: !0,
        onReentry() {
          n.value.set(s.logs);
        },
      }
    );
  }
  getState() {
    const { project: e, solverLogs: n } = ke();
    return {
      cellData: fc(e.value.cells),
      logs: n.value.lines.slice(),
      lastSolverAction: Zt.value,
    };
  }
}
class Xo {
  constructor() {
    L(this, "panelComponent", null);
    L(this, "hotkeyActionName");
  }
  open(e) {
    this.panelComponent = e;
  }
  close() {
    this.panelComponent = null;
  }
  getTooltip() {
    return this.hotkeyActionName ? gs(this.hotkeyActionName) : "";
  }
  getPanelComponent() {
    return this.panelComponent;
  }
}
class Eo {
  constructor() {
    L(this, "startTimestamp", 0);
    L(this, "passedTime", 0);
    L(this, "running", !1);
  }
  reset() {
    (this.running = !1), (this.passedTime = 0);
  }
  start() {
    (this.startTimestamp = performance.now()), (this.running = !0);
  }
  stop() {
    (this.passedTime += this.startTimestamp - performance.now()),
      (this.running = !1);
  }
  getElapsedSeconds() {
    return this.running
      ? (this.passedTime + performance.now() - this.startTimestamp) / 1e3
      : this.passedTime / 1e3;
  }
}
class O_ extends Xo {
  constructor() {
    super(...arguments);
    L(this, "hotkeyActionName", "doAllLogicalSteps");
  }
  getIllustration() {
    return R_;
  }
  getCanExecute() {
    const { solverEnabled: n } = ke();
    return n.value ? tn.value && !rt.value : !1;
  }
  async execute() {
    rt.value = !0;
    const { project: n, solverLogs: s } = ke(),
      { getSolverInputData: o } = as(),
      r = new Eo();
    r.start();
    const l = Nn.getLogicalSolver(await o(), vs.strategy),
      i = new ia("Auto-step");
    Zt.value !== ss.Step && s.value.clear(), (Zt.value = ss.Step);
    try {
      for (;;) {
        const a = await l.step();
        if (a.error) {
          a.cueResults && s.value.logCueResults(a.cueResults),
            s.value.logError(a.error);
          break;
        }
        if (
          (a.cueResults && s.value.logCueResults(a.cueResults),
          a.sudokuData &&
            (n.value.updateFromData(a.sudokuData), !a.cueResults && a.valid))
        ) {
          n.value.isSolved()
            ? (s.value.logSolved(r.getElapsedSeconds()), (tn.value = !1))
            : s.value.logCueResult(void 0),
            i.record(),
            (tn.value = !1);
          break;
        }
        i.record();
      }
    } catch (a) {
      cl(a);
    }
    rt.value = !1;
  }
}
const N_ = { components: { Icon: he } };
function T_(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      {
        class: "CheckSolution",
        viewBox: "0 0 20 20",
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-miterlimit": "1.5",
      },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  class: "colored",
                  d: "M7.83 13.67a4.29 4.29 0 0 1 2.18-8.02 4.29 4.29 0 0 1 2.18 8.02",
                  fill: "url(#checkSolutionGradient)",
                  stroke: "none",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M7.83 13.67a4.29 4.29 0 0 1 2.18-8.02 4.29 4.29 0 0 1 2.18 8.02",
                  fill: "none",
                  stroke: "currentColor",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  class: "questionMark",
                  d: "M10.38 10.73a.42.42 0 0 1-.41.35H9.8a.23.23 0 0 1-.23-.23c0-.28.05-.5.13-.69.09-.18.26-.39.51-.61.26-.23.4-.38.46-.45a.5.5 0 0 0-.06-.7.98.98 0 0 0-.61-.18c-.22 0-.4.07-.56.2a.89.89 0 0 0-.25.4.1.1 0 0 1-.1.07l-.25-.04a.45.45 0 0 1-.35-.64 1.62 1.62 0 0 1 1.5-.88c.5 0 .9.15 1.2.43.3.29.44.62.44 1 0 .21-.05.41-.16.6-.1.19-.34.45-.7.77-.18.17-.3.3-.34.4a.72.72 0 0 0-.05.2Z",
                  "fill-rule": "nonzero",
                },
                null,
                -1
              ),
              h(
                "circle",
                { class: "questionMark", cx: "10", cy: "12.12", r: ".54" },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M7.83 13.67v3.44m4.36-.73v-2.71m-4.36 3.44 4.36-.71m0-1.44-4.36.72m4.36-2.01-4.36.58M3 10H1m16 0h2m-8.99-7V1M5.05 14.95l-1.41 1.41m11.31-1.41 1.41 1.41M14.95 5.05l1.41-1.41m-11.3 1.4L3.64 3.63",
                  fill: "none",
                  stroke: "currentColor",
                },
                null,
                -1
              ),
              h(
                "defs",
                null,
                [
                  h(
                    "radialGradient",
                    {
                      id: "checkSolutionGradient",
                      cx: "0",
                      cy: "0",
                      r: "1",
                      gradientUnits: "userSpaceOnUse",
                      gradientTransform: "matrix(3.82 0 0 3.77 10.01 9.95)",
                    },
                    [
                      h("stop", { offset: "0", "stop-color": "#fff" }),
                      h("stop", { offset: "1", "stop-color": "#ffcd00" }),
                    ]
                  ),
                ],
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const V_ = B(N_, [
    ["render", T_],
    ["__scopeId", "data-v-ecc256e3"],
  ]),
  ui = S({
    __name: "GreenCheck",
    setup(t) {
      return (e, n) => (
        d(),
        w(
          he,
          { class: "GreenCheck", viewBox: "-1 -1 15 14" },
          {
            default: f(
              () =>
                n[0] ||
                (n[0] = [
                  h(
                    "path",
                    {
                      d: "m0 5 2-2 3 3 6-6 2 2-8 8-5-5Z",
                      stroke: "currentColor",
                      fill: "#0e0",
                    },
                    null,
                    -1
                  ),
                ])
            ),
            _: 1,
          }
        )
      );
    },
  }),
  j_ = S({
    __name: "RedCross",
    setup(t) {
      return (e, n) => (
        d(),
        w(
          he,
          { class: "RedCross", viewBox: "-1 -1 15 15" },
          {
            default: f(
              () =>
                n[0] ||
                (n[0] = [
                  h(
                    "path",
                    {
                      d: "M3 1l3.5 3.5l3.5-3.5l2 2l-3.5 3.5l3.5 3.5l-2 2l-3.5-3.5l-3.5 3.5l-2-2l3.5-3.5l-3.5-3.5z",
                      stroke: "#000",
                    },
                    null,
                    -1
                  ),
                ])
            ),
            _: 1,
          }
        )
      );
    },
  }),
  Tu = B(j_, [["__scopeId", "data-v-fab6adff"]]);
class U_ {
  constructor() {
    L(this, "deferred", new co());
    L(this, "timerId", -1);
  }
  get promise() {
    return this.deferred.promise;
  }
  start(e) {
    this.timerId = window.setTimeout(() => this.deferred.resolve(!0), e);
  }
  cancel() {
    clearTimeout(this.timerId);
  }
}
class Er {
  constructor() {
    L(this, "countdown", new U_());
  }
  async start(e, n, s) {
    return (
      this.countdown.start(n),
      await Promise.race([
        (async () => (
          await (typeof e == "function" ? e() : e), (s = void 0), !0
        ))(),
        (async () => (await this.countdown.promise, s == null || s(), !1))(),
      ])
    );
  }
  resetTimer(e) {
    this.countdown.cancel(), this.countdown.start(e);
  }
}
class H_ extends Xo {
  constructor() {
    super(...arguments);
    L(this, "hotkeyActionName", "checkValidity");
  }
  getIllustration() {
    return V_;
  }
  getCanExecute() {
    const { solverEnabled: n } = ke();
    return n.value ? !rt.value : !1;
  }
  async execute() {
    rt.value = !0;
    const { solverLogs: n } = ke(),
      { getSolverInputData: s } = as();
    await new W_(await s(), n.value).execute(), (rt.value = !1);
  }
}
class W_ {
  constructor(e, n) {
    L(this, "usingUserData");
    L(this, "solveTimeLimitInMs");
    L(this, "solver");
    (this.solverModel = e),
      (this.solverLogs = n),
      (this.usingUserData = !Ne.dismissUserDataForCheck && Vu(e)),
      (this.solveTimeLimitInMs = It.solveTimeLimit * 1e3);
  }
  async execute() {
    const e = this.getStateToSolve();
    (this.solver = Nn.getSolutionFinder(e, It.strategy)),
      this.solverLogs.clear(),
      (Zt.value = ss.FindSolutions),
      this.usingUserData
        ? this.solverLogs.log({
            type: "text",
            text: "Making use of the filled-in values and pencil marks...",
            icon: _s,
          })
        : e !== this.solverModel &&
          this.solverLogs.log({
            type: "text",
            text: "Dismissing the filled-in values and pencil marks...",
            icon: _s,
          });
    try {
      if (!(await this.findASolution())) return;
      await this.checkUniqueness();
    } catch (n) {
      cl(n);
    }
  }
  async findASolution() {
    const e = new Eo();
    e.start();
    let n = !1;
    return (await new Er().start(
      async () => {
        const { error: r } = await this.solver.findNext();
        r || (n = !0);
      },
      this.solveTimeLimitInMs,
      () => this.solver.dispose()
    ))
      ? n
        ? (this.solverLogs.log({
            type: "text",
            icon: ui,
            text: "This puzzle has a solution.",
            duration: e.getElapsedSeconds(),
          }),
          !0)
        : (this.solverLogs.log({
            type: "text",
            icon: Tu,
            text: "This puzzle has no solutions.",
            duration: e.getElapsedSeconds(),
          }),
          !1)
      : (this.solverLogs.logInfo("Stopped solving (time limit was reached)"),
        !1);
  }
  async checkUniqueness() {
    const e = new Eo();
    e.start();
    const n = new Er();
    let s = !1;
    if (
      !(await n.start(
        async () => {
          const { sudokuData: r } = await this.solver.findNext();
          r && (s = !0);
        },
        this.solveTimeLimitInMs,
        () => this.solver.dispose()
      ))
    ) {
      this.solverLogs.logError(
        "Stopped checking for uniqueness (time limit was reached)"
      );
      return;
    }
    s
      ? this.solverLogs.log({
          type: "text",
          icon: Tu,
          text: "The solution is not unique.",
          duration: e.getElapsedSeconds(),
        })
      : this.solverLogs.log({
          type: "text",
          icon: ui,
          text: "The solution is unique!",
          duration: e.getElapsedSeconds(),
        });
  }
  getStateToSolve() {
    return Ne.dismissUserDataForCheck && Vu(this.solverModel)
      ? {
          ...this.solverModel,
          cells: this.solverModel.cells.map((e) => ({
            value: e.given ? e.value : void 0,
            candidates: 0,
          })),
        }
      : this.solverModel;
  }
}
function Vu(t) {
  return t.cells.some((e) =>
    e.given ? !1 : e.value !== void 0 || e.candidates !== 0
  );
}
const Z_ = { components: { Icon: he } };
function G_(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "ClearAll", viewBox: "0 0 20 20" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h("circle", { cx: "10", cy: "10", r: "1" }, null, -1),
              h(
                "path",
                {
                  d: "M7.1 7.1 4.33 4.33m11.33 11.33L12.9 12.9m0-5.8 2.76-2.76M4.34 15.66 7.1 12.9M5.89 10H2m16 0h-3.89M10 5.89V2m0 16v-3.89",
                  fill: "none",
                  stroke: "currentColor",
                  "stroke-linecap": "round",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const q_ = B(Z_, [["render", G_]]);
async function Jp({ actionName: t = "Clear sudoku", actionId: e = fe() } = {}) {
  const { solverLogs: n, updateSudokuCells: s } = ke();
  if (
    (await s(
      (r) => {
        for (const l of r.cells) l.clear();
      },
      t,
      { id: e }
    )) ||
    n.value.lines.length > 0
  ) {
    const r = n.value.lines.slice();
    jt.executeAndRecord(
      () => {
        n.value.clear();
      },
      () => {
        n.value.set(r);
      },
      "",
      { id: e, type: qr.Amend }
    );
  }
}
class K_ extends Xo {
  constructor() {
    super(...arguments);
    L(this, "hotkeyActionName", "clearGrid");
  }
  getIllustration() {
    return q_;
  }
  getCanExecute() {
    return !rt.value;
  }
  execute() {
    Jp();
  }
}
const X_ = {
    components: { Icon: he },
    computed: {
      renderData() {
        return [
          2, 7, 6, 9, 1, 4, 5, 8, 9, 1, 6, 3, 5, 4, 4, 3, 5, 2, 7, 8, 9, 5, 2,
          9, 3, 8, 6, 7, 7, 8, 4, 1, 2, 9, 6,
        ].map((t, e) => ({
          digit: t,
          x: 2.97 + (e % 7) * 2.08,
          y: 5.6 + Math.floor(e / 7) * 2.96,
        }));
      },
    },
  },
  Y_ = ["transform"],
  J_ = ["xlink:href"];
function Q_(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      {
        class: "ShowCandidates",
        viewBox: "0 0 20 20",
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-miterlimit": "1.5",
      },
      {
        default: f(() => [
          e[0] ||
            (e[0] = h(
              "defs",
              null,
              [
                h("g", { id: "digit1" }, [
                  h("path", {
                    d: "M.4 0H.25v-.52a.48.48 0 0 1-.18.1v-.12A.4.4 0 0 0 .2-.6a.25.25 0 0 0 .08-.12H.4V0Z",
                    style: { "fill-rule": "nonzero" },
                  }),
                ]),
                h("g", { id: "digit2" }, [
                  h("path", {
                    d: "M.5-.13V0H.04c0-.05.02-.1.04-.14.03-.04.08-.1.16-.17a.9.9 0 0 0 .11-.12.15.15 0 0 0 .03-.08.1.1 0 0 0-.03-.07.1.1 0 0 0-.07-.03.1.1 0 0 0-.06.03C.2-.56.19-.53.19-.49L.04-.51c0-.07.04-.13.08-.16s.1-.05.16-.05c.07 0 .13.02.17.06.04.04.06.08.06.14l-.02.1a.4.4 0 0 1-.06.08.9.9 0 0 1-.09.1 1.62 1.62 0 0 0-.1.11H.5Z",
                    style: { "fill-rule": "nonzero" },
                  }),
                ]),
                h("g", { id: "digit3" }, [
                  h("path", {
                    d: "M0.038,-0.19l0.132,-0.016c0.005,0.034 0.016,0.06 0.035,0.078c0.018,0.017 0.041,0.026 0.067,0.026c0.028,0 0.052,-0.01 0.072,-0.032c0.019,-0.021 0.029,-0.05 0.029,-0.087c-0,-0.034 -0.01,-0.062 -0.028,-0.082c-0.019,-0.02 -0.041,-0.03 -0.068,-0.03c-0.018,-0 -0.039,0.003 -0.063,0.01l0.015,-0.112c0.037,0.001 0.065,-0.007 0.085,-0.024c0.019,-0.017 0.029,-0.04 0.029,-0.068c0,-0.024 -0.007,-0.043 -0.021,-0.057c-0.015,-0.015 -0.034,-0.022 -0.057,-0.022c-0.024,0 -0.044,0.008 -0.06,0.024c-0.017,0.017 -0.027,0.04 -0.031,0.072l-0.126,-0.022c0.009,-0.043 0.022,-0.078 0.04,-0.103c0.017,-0.026 0.042,-0.047 0.074,-0.062c0.032,-0.014 0.067,-0.022 0.107,-0.022c0.067,0 0.121,0.022 0.162,0.065c0.033,0.035 0.05,0.075 0.05,0.119c-0,0.063 -0.034,0.113 -0.103,0.15c0.041,0.009 0.074,0.029 0.098,0.059c0.025,0.031 0.037,0.068 0.037,0.111c0,0.063 -0.023,0.117 -0.069,0.161c-0.046,0.044 -0.103,0.066 -0.171,0.066c-0.065,0 -0.119,-0.018 -0.161,-0.056c-0.043,-0.037 -0.068,-0.086 -0.074,-0.146Z",
                    style: { "fill-rule": "nonzero" },
                  }),
                ]),
                h("g", { id: "digit4" }, [
                  h("path", {
                    d: "M.31 0v-.14h-.3v-.12l.32-.46h.11v.45h.1v.13h-.1V0H.31Zm0-.27V-.5l-.16.24H.3Z",
                    style: { "fill-rule": "nonzero" },
                  }),
                ]),
                h("g", { id: "digit5" }, [
                  h("path", {
                    d: "M.04-.18.18-.2c0 .03.02.06.04.07a.1.1 0 0 0 .06.03c.03 0 .06 0 .07-.03a.12.12 0 0 0 .05-.1.13.13 0 0 0-.04-.1.1.1 0 0 0-.07-.04.12.12 0 0 0-.1.05L.05-.33l.07-.38H.5v.13H.23l-.02.12a.21.21 0 0 1 .25.05.24.24 0 0 1 .01.33.23.23 0 0 1-.19.1.24.24 0 0 1-.16-.06.22.22 0 0 1-.08-.14Z",
                    style: { "fill-rule": "nonzero" },
                  }),
                ]),
                h("g", { id: "digit6" }, [
                  h("path", {
                    d: "m.5-.54-.13.01c0-.02 0-.04-.02-.06A.07.07 0 0 0 .3-.6a.1.1 0 0 0-.08.04C.2-.54.2-.49.18-.4a.16.16 0 0 1 .13-.07c.06 0 .1.03.15.07.04.04.06.1.06.17S.5-.1.46-.05A.22.22 0 0 1 .29 0a.22.22 0 0 1-.18-.08C.07-.13.04-.22.04-.35a.5.5 0 0 1 .07-.28.24.24 0 0 1 .2-.09c.05 0 .1.02.13.05a.2.2 0 0 1 .07.13Zm-.3.3c0 .04 0 .08.03.1.02.03.04.04.07.04l.06-.03C.38-.15.4-.18.4-.23S.38-.3.36-.33a.09.09 0 0 0-.14 0L.2-.24Z",
                    style: { "fill-rule": "nonzero" },
                  }),
                ]),
                h("g", { id: "digit7" }, [
                  h("path", {
                    d: "M.04-.58V-.7h.47v.1a.96.96 0 0 0-.24.6L.14.01a1.03 1.03 0 0 1 .21-.58h-.3Z",
                    style: { "fill-rule": "nonzero" },
                  }),
                ]),
                h("g", { id: "digit8" }, [
                  h("path", {
                    d: "M.16-.39a.16.16 0 0 1-.08-.06.16.16 0 0 1-.02-.08c0-.06.02-.1.06-.14a.23.23 0 0 1 .15-.05c.07 0 .12.02.16.05.04.04.06.08.06.14 0 .03-.01.06-.03.08a.16.16 0 0 1-.07.06c.04.02.07.04.09.07a.2.2 0 0 1 .03.11c0 .07-.02.12-.06.16a.23.23 0 0 1-.17.06.25.25 0 0 1-.16-.05.2.2 0 0 1-.08-.17.2.2 0 0 1 .03-.1.18.18 0 0 1 .09-.09Zm.03-.13c0 .02 0 .04.02.06l.06.02c.03 0 .05 0 .07-.02l.02-.07c0-.02 0-.04-.02-.06A.08.08 0 0 0 .27-.6c-.02 0-.04 0-.06.02a.08.08 0 0 0-.02.07Zm-.01.3c0 .04 0 .07.02.1a.1.1 0 0 0 .08.02.1.1 0 0 0 .07-.03.13.13 0 0 0 .02-.09c0-.03 0-.06-.02-.08a.1.1 0 0 0-.07-.03.09.09 0 0 0-.08.04.13.13 0 0 0-.02.07Z",
                    style: { "fill-rule": "nonzero" },
                  }),
                ]),
                h("g", { id: "digit9" }, [
                  h("path", {
                    d: "m.04-.17.14-.01.02.06.06.02C.29-.1.3-.11.33-.14A.4.4 0 0 0 .37-.3a.16.16 0 0 1-.13.06.2.2 0 0 1-.15-.07.24.24 0 0 1-.06-.17c0-.07.02-.13.07-.17a.2.2 0 0 1 .16-.07c.07 0 .13.03.18.08.05.06.07.15.07.28 0 .13-.02.23-.07.29a.23.23 0 0 1-.2.08.2.2 0 0 1-.13-.04.21.21 0 0 1-.07-.14Zm.32-.3a.13.13 0 0 0-.04-.1.1.1 0 0 0-.07-.03.08.08 0 0 0-.06.02c-.02.03-.02.06-.02.1 0 .05 0 .08.02.1.02.03.04.04.07.04a.1.1 0 0 0 .07-.03c.02-.02.03-.06.03-.1Z",
                    style: { "fill-rule": "nonzero" },
                  }),
                ]),
              ],
              -1
            )),
          (d(!0),
          C(
            Z,
            null,
            se(
              r.renderData,
              ({ digit: i, x: a, y: u }, p) => (
                d(),
                C(
                  "g",
                  { key: p, transform: `matrix(2.85,0,0,2.85,${a},${u})` },
                  [h("use", { "xlink:href": `#digit${i}` }, null, 8, J_)],
                  8,
                  Y_
                )
              )
            ),
            128
          )),
        ]),
        _: 1,
      }
    )
  );
}
const e6 = B(X_, [["render", Q_]]);
class t6 extends Xo {
  constructor() {
    super(...arguments);
    L(this, "hotkeyActionName", "findSolutions");
  }
  getIllustration() {
    return e6;
  }
  getCanExecute() {
    const { solverEnabled: n } = ke();
    return n.value ? !rt.value : !1;
  }
  async execute() {
    rt.value = !0;
    const { project: n, solverLogs: s } = ke(),
      { getSolverInputData: o } = as();
    await new n6(n.value, await o(), s.value).execute(), (rt.value = !1);
  }
}
class n6 {
  constructor(e, n, s) {
    L(this, "project");
    L(this, "input");
    L(this, "logs");
    L(this, "solverChange");
    L(this, "usingUserData", !1);
    L(this, "aggregatedSudokuData");
    L(this, "solveTimeLimitInMs");
    L(this, "solver");
    (this.project = e),
      (this.input = n),
      (this.logs = s),
      (this.aggregatedSudokuData = new Uint32Array(
        this.input.spec.size.width * this.input.spec.size.height * 2
      )),
      (this.solveTimeLimitInMs = It.solveTimeLimit * 1e3);
  }
  async execute() {
    Ne.dismissUserDataForSolutions && (await Jp()),
      (this.usingUserData = this.input.cells.some(
        (e) => !e.given && (e.value !== void 0 || e.candidates !== 0)
      )),
      (this.solverChange = new ia("Find all solutions and valid candidates")),
      this.logs.clear(),
      (Zt.value = ss.FindSolutions),
      (this.solver = Nn.getSolutionFinder(this.input, It.strategy));
    try {
      (await this.findSolution()) &&
        (It.solutionCountLimit > 1
          ? await this.findRemainingSolutions()
          : (this.logs.logInfo("Stopped counting (counting limit was reached)"),
            this.solverChange.record()));
    } catch (e) {
      cl(e);
    }
  }
  async findSolution() {
    const e = new Eo();
    e.start();
    let n;
    return (await new Er().start(
      async () => {
        n = await this.solver.findNext();
      },
      this.solveTimeLimitInMs,
      () => {
        this.solver.dispose();
      }
    ))
      ? n.error
        ? (this.logs.logError(n.error), this.solverChange.record(), !1)
        : (this.aggregatedSudokuData.set(n.sudokuData, 0),
          n.changed && this.project.updateFromData(this.aggregatedSudokuData),
          this.logs.logSolved(e.getElapsedSeconds()),
          this.solverChange.record(),
          !0)
      : (this.logs.logInfo("Stopped solving (time limit was reached)"),
        this.solverChange.record(),
        !1);
  }
  async findRemainingSolutions() {
    let e = performance.now();
    const n = new Eo();
    n.start();
    let s = 1,
      o = 1;
    const r = new Er(),
      l = await r.start(
        async () => {
          await this.solver.findAll((i) => {
            if (!(i != null && i.sudokuData)) return !1;
            s++, o++, U1(this.aggregatedSudokuData, i.sudokuData);
            const a = performance.now();
            return (
              (o % 100 === 0 || a - e > 1e3) &&
                (this.project.updateFromData(this.aggregatedSudokuData),
                this.logs.logCount(s, n.getElapsedSeconds()),
                this.solverChange.record(),
                (e = a),
                (o = 0)),
              r.resetTimer(this.solveTimeLimitInMs),
              s < It.solutionCountLimit
            );
          });
        },
        this.solveTimeLimitInMs,
        () => this.solver.dispose()
      );
    if (
      (s > 1 &&
        (this.project.updateFromData(this.aggregatedSudokuData),
        this.logs.logCount(s, n.getElapsedSeconds())),
      !l)
    )
      this.logs.logInfo(
        "Stopped counting (finding another solution took too long.)"
      );
    else if (s >= It.solutionCountLimit)
      this.logs.logInfo("Stopped counting (counting limit was reached)");
    else if (s === 1) {
      const i = this.usingUserData
        ? "This is a unique solution (based on already entered values and pencil marks.)"
        : "This is a unique solution.";
      this.logs.log({
        type: "text",
        text: i,
        icon: ui,
        duration: n.getElapsedSeconds(),
      });
    } else
      this.logs.log({
        type: "text",
        text: this.usingUserData
          ? "All solutions found (based on already entered values and pencil marks.)"
          : "All solutions found.",
        duration: n.getElapsedSeconds(),
      });
    this.solverChange.record();
  }
}
class s6 extends Xo {
  constructor() {
    super(...arguments);
    L(this, "hotkeyActionName", "doSingleLogicalStep");
  }
  getIllustration() {
    return Yp;
  }
  getCanExecute() {
    const { solverEnabled: n } = ke();
    return n.value ? tn.value && !rt.value : !1;
  }
  async execute(n) {
    var a, u;
    rt.value = !0;
    const { project: s, solverLogs: o } = ke(),
      { getSolverInputData: r } = as(),
      l = new ia("Step");
    Zt.value !== ss.Step && o.value.clear(), (Zt.value = ss.Step);
    const i = Nn.getLogicalSolver(await r(), vs.strategy);
    try {
      const { cueResults: p, sudokuData: m, error: g } = await i.step();
      p && o.value.logCueResults(p),
        g && o.value.logError(g),
        (tn.value = !g),
        m &&
          (s.value.updateFromData(m),
          !g && s.value.isSolved()
            ? (o.value.logSolved(), (tn.value = !1))
            : !p && !g && (o.value.logCueResult(void 0), (tn.value = !1))),
        l.record();
    } catch (p) {
      cl(p);
    }
    (rt.value = !1),
      n != null &&
        n.target &&
        ((u = (a = n.target).focus) == null || u.call(a));
  }
}
const Js = [];
function Yo(t) {
  Js.push(t),
    t.hotkeyActionName &&
      ot(t.hotkeyActionName, () => {
        t.getCanExecute() && t.execute();
      });
}
function o6(t, e) {
  ot(t, e);
}
Yo(new K_());
Yo(new s6());
Yo(new O_());
Yo(new t6());
Yo(new H_());
o6("toggleFog", () => {
  Ne.showFog = !Ne.showFog;
});
const r6 = { components: { Icon: he } };
function l6(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "CogWheel", viewBox: "0 0 24 24" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  "fill-rule": "evenodd",
                  d: "M16 12a4 4 0 11-8 0 4 4 0 018 0zm-1.5 0a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  "fill-rule": "evenodd",
                  d: "M12 1c-.268 0-.534.01-.797.028-.763.055-1.345.617-1.512 1.304l-.352 1.45c-.02.078-.09.172-.225.22a8.45 8.45 0 00-.728.303c-.13.06-.246.044-.315.002l-1.274-.776c-.604-.368-1.412-.354-1.99.147-.403.348-.78.726-1.129 1.128-.5.579-.515 1.387-.147 1.99l.776 1.275c.042.069.059.185-.002.315-.112.237-.213.48-.302.728-.05.135-.143.206-.221.225l-1.45.352c-.687.167-1.249.749-1.304 1.512a11.149 11.149 0 000 1.594c.055.763.617 1.345 1.304 1.512l1.45.352c.078.02.172.09.22.225.09.248.191.491.303.729.06.129.044.245.002.314l-.776 1.274c-.368.604-.354 1.412.147 1.99.348.403.726.78 1.128 1.129.579.5 1.387.515 1.99.147l1.275-.776c.069-.042.185-.059.315.002.237.112.48.213.728.302.135.05.206.143.225.221l.352 1.45c.167.687.749 1.249 1.512 1.303a11.125 11.125 0 001.594 0c.763-.054 1.345-.616 1.512-1.303l.352-1.45c.02-.078.09-.172.225-.22.248-.09.491-.191.729-.303.129-.06.245-.044.314-.002l1.274.776c.604.368 1.412.354 1.99-.147.403-.348.78-.726 1.129-1.128.5-.579.515-1.387.147-1.99l-.776-1.275c-.042-.069-.059-.185.002-.315.112-.237.213-.48.302-.728.05-.135.143-.206.221-.225l1.45-.352c.687-.167 1.249-.749 1.303-1.512a11.125 11.125 0 000-1.594c-.054-.763-.616-1.345-1.303-1.512l-1.45-.352c-.078-.02-.172-.09-.22-.225a8.469 8.469 0 00-.303-.728c-.06-.13-.044-.246-.002-.315l.776-1.274c.368-.604.354-1.412-.147-1.99-.348-.403-.726-.78-1.128-1.129-.579-.5-1.387-.515-1.99-.147l-1.275.776c-.069.042-.185.059-.315-.002a8.465 8.465 0 00-.728-.302c-.135-.05-.206-.143-.225-.221l-.352-1.45c-.167-.687-.749-1.249-1.512-1.304A11.149 11.149 0 0012 1zm-.69 1.525a9.648 9.648 0 011.38 0c.055.004.135.05.162.16l.351 1.45c.153.628.626 1.08 1.173 1.278.205.074.405.157.6.249a1.832 1.832 0 001.733-.074l1.275-.776c.097-.06.186-.036.228 0 .348.302.674.628.976.976.036.042.06.13 0 .228l-.776 1.274a1.832 1.832 0 00-.074 1.734c.092.195.175.395.248.6.198.547.652 1.02 1.278 1.172l1.45.353c.111.026.157.106.161.161a9.653 9.653 0 010 1.38c-.004.055-.05.135-.16.162l-1.45.351a1.833 1.833 0 00-1.278 1.173 6.926 6.926 0 01-.25.6 1.832 1.832 0 00.075 1.733l.776 1.275c.06.097.036.186 0 .228a9.555 9.555 0 01-.976.976c-.042.036-.13.06-.228 0l-1.275-.776a1.832 1.832 0 00-1.733-.074 6.926 6.926 0 01-.6.248 1.833 1.833 0 00-1.172 1.278l-.353 1.45c-.026.111-.106.157-.161.161a9.653 9.653 0 01-1.38 0c-.055-.004-.135-.05-.162-.16l-.351-1.45a1.833 1.833 0 00-1.173-1.278 6.928 6.928 0 01-.6-.25 1.832 1.832 0 00-1.734.075l-1.274.776c-.097.06-.186.036-.228 0a9.56 9.56 0 01-.976-.976c-.036-.042-.06-.13 0-.228l.776-1.275a1.832 1.832 0 00.074-1.733 6.948 6.948 0 01-.249-.6 1.833 1.833 0 00-1.277-1.172l-1.45-.353c-.111-.026-.157-.106-.161-.161a9.648 9.648 0 010-1.38c.004-.055.05-.135.16-.162l1.45-.351a1.833 1.833 0 001.278-1.173 6.95 6.95 0 01.249-.6 1.832 1.832 0 00-.074-1.734l-.776-1.274c-.06-.097-.036-.186 0-.228.302-.348.628-.674.976-.976.042-.036.13-.06.228 0l1.274.776a1.832 1.832 0 001.734.074 6.95 6.95 0 01.6-.249 1.833 1.833 0 001.172-1.277l.353-1.45c.026-.111.106-.157.161-.161z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const i6 = B(r6, [["render", l6]]),
  a6 = { class: "ToolsPanel" },
  u6 = { class: "top" },
  c6 = { class: "mainButtons" },
  d6 = { key: 0 },
  p6 = { class: "toggles" },
  f6 = S({
    __name: "ToolsPanel",
    setup(t) {
      const { project: e, solverEnabled: n, solverLogs: s } = ke(),
        o = j(!1),
        r = j(!1),
        l = b(() =>
          e.value
            .getEnabledConstraints()
            .some((a) => [_.FogLights, _.FogTriggers].includes(a.config.type))
        );
      function i(a) {
        return a.hotkeyActionName ? kt.getHotkeys(a.hotkeyActionName) : [];
      }
      return (a, u) => (
        d(),
        C("div", a6, [
          h("div", u6, [
            h("div", c6, [
              (d(!0),
              C(
                Z,
                null,
                se(
                  y(Js),
                  (p, m) => (
                    d(),
                    w(
                      pt,
                      {
                        key: m,
                        disabled: !p.getCanExecute(),
                        onClick: (g) => p.execute(g),
                      },
                      {
                        default: f(() => [
                          (d(), w(qe(p.getIllustration()))),
                          c(
                            Te,
                            null,
                            {
                              default: f(() => [
                                F(X(p.getTooltip()) + " ", 1),
                                c(pn, { hotkeys: i(p) }, null, 8, ["hotkeys"]),
                              ]),
                              _: 2,
                            },
                            1024
                          ),
                        ]),
                        _: 2,
                      },
                      1032,
                      ["disabled", "onClick"]
                    )
                  )
                ),
                128
              )),
            ]),
            c(
              te,
              {
                class: "settingsButton",
                icon: "",
                active: o.value,
                onClick: u[0] || (u[0] = (p) => (o.value = !o.value)),
              },
              {
                default: f(() => [
                  c(i6),
                  c(Te, { text: "More tools & settings" }),
                ]),
                _: 1,
              },
              8,
              ["active"]
            ),
          ]),
          c(ns, null, {
            default: f(() => [
              o.value
                ? (d(),
                  C("div", d6, [
                    c(
                      be,
                      { class: "drawer", vertical: "", gap: "" },
                      {
                        default: f(() => [
                          h("div", p6, [
                            y(n)
                              ? (d(),
                                w(
                                  xn,
                                  {
                                    key: 0,
                                    checked: y(Ne).highlightConflicts,
                                    "onUpdate:checked":
                                      u[1] ||
                                      (u[1] = (p) =>
                                        (y(Ne).highlightConflicts = p)),
                                  },
                                  {
                                    default: f(
                                      () =>
                                        u[9] ||
                                        (u[9] = [F(" Highlight conflicts ")])
                                    ),
                                    _: 1,
                                  },
                                  8,
                                  ["checked"]
                                ))
                              : z("", !0),
                            c(
                              xn,
                              {
                                checked: y(Ne).enterDigitsAsGivens,
                                "onUpdate:checked":
                                  u[2] ||
                                  (u[2] = (p) =>
                                    (y(Ne).enterDigitsAsGivens = p)),
                              },
                              {
                                default: f(() => [
                                  u[11] ||
                                    (u[11] = F(" Enter digits as givens ")),
                                  c(dt, null, {
                                    default: f(
                                      () =>
                                        u[10] ||
                                        (u[10] = [
                                          F(
                                            " Toggle this on to enter digits as givens even when the "
                                          ),
                                          h("strong", null, "Given digits", -1),
                                          F(
                                            " constraint is not selected. This also allows you to delete givens even when the constraint is not selected. "
                                          ),
                                        ])
                                    ),
                                    _: 1,
                                  }),
                                ]),
                                _: 1,
                              },
                              8,
                              ["checked"]
                            ),
                            y(n)
                              ? (d(),
                                w(
                                  xn,
                                  {
                                    key: 1,
                                    checked: y(Ne).useCornerMarksAutomatically,
                                    "onUpdate:checked":
                                      u[3] ||
                                      (u[3] = (p) =>
                                        (y(Ne).useCornerMarksAutomatically =
                                          p)),
                                  },
                                  {
                                    default: f(() => [
                                      u[13] ||
                                        (u[13] = F(
                                          " Update candidates when entering corner marks "
                                        )),
                                      c(dt, null, {
                                        default: f(
                                          () =>
                                            u[12] ||
                                            (u[12] = [
                                              F(
                                                " When corner-marking a group of cells, automatically remove the marked digit from all cells seen by every cell of that group. "
                                              ),
                                            ])
                                        ),
                                        _: 1,
                                      }),
                                    ]),
                                    _: 1,
                                  },
                                  8,
                                  ["checked"]
                                ))
                              : z("", !0),
                            y(n)
                              ? (d(),
                                w(
                                  xn,
                                  {
                                    key: 2,
                                    checked: y(Ne).dismissUserDataForSolutions,
                                    "onUpdate:checked":
                                      u[4] ||
                                      (u[4] = (p) =>
                                        (y(Ne).dismissUserDataForSolutions =
                                          p)),
                                  },
                                  {
                                    default: f(
                                      () =>
                                        u[14] ||
                                        (u[14] = [
                                          F(
                                            " Clear the grid before finding all solutions and valid candidates. "
                                          ),
                                        ])
                                    ),
                                    _: 1,
                                  },
                                  8,
                                  ["checked"]
                                ))
                              : z("", !0),
                            y(n)
                              ? (d(),
                                w(
                                  xn,
                                  {
                                    key: 3,
                                    checked: y(Ne).dismissUserDataForCheck,
                                    "onUpdate:checked":
                                      u[5] ||
                                      (u[5] = (p) =>
                                        (y(Ne).dismissUserDataForCheck = p)),
                                  },
                                  {
                                    default: f(
                                      () =>
                                        u[15] ||
                                        (u[15] = [
                                          F(
                                            " Dismiss filled-in values and pencil marks when checking for validity and uniqueness "
                                          ),
                                        ])
                                    ),
                                    _: 1,
                                  },
                                  8,
                                  ["checked"]
                                ))
                              : z("", !0),
                            l.value
                              ? (d(),
                                w(
                                  xn,
                                  {
                                    key: 4,
                                    checked: y(Ne).showFog,
                                    "onUpdate:checked":
                                      u[6] ||
                                      (u[6] = (p) => (y(Ne).showFog = p)),
                                  },
                                  {
                                    default: f(
                                      () => u[16] || (u[16] = [F(" Show fog ")])
                                    ),
                                    _: 1,
                                  },
                                  8,
                                  ["checked"]
                                ))
                              : z("", !0),
                          ]),
                          c(
                            te,
                            {
                              "with-icon": "",
                              style: { "align-self": "flex-start" },
                              onClick: u[7] || (u[7] = (p) => (r.value = !0)),
                            },
                            {
                              default: f(() => [
                                c(Yp, { style: { transform: "scale(1.5)" } }),
                                u[17] ||
                                  (u[17] = h(
                                    "span",
                                    null,
                                    "Solver settings",
                                    -1
                                  )),
                              ]),
                              _: 1,
                            }
                          ),
                        ]),
                        _: 1,
                      }
                    ),
                  ]))
                : z("", !0),
            ]),
            _: 1,
          }),
          y(rt) || y(s).lines.length > 0
            ? (d(),
              w(f_, { key: 0, logs: y(s), solving: y(rt) }, null, 8, [
                "logs",
                "solving",
              ]))
            : z("", !0),
          c(Oe, null, {
            default: f(() => [
              r.value
                ? (d(),
                  w(L_, {
                    key: 0,
                    onClose: u[8] || (u[8] = (p) => (r.value = !1)),
                  }))
                : z("", !0),
            ]),
            _: 1,
          }),
        ])
      );
    },
  }),
  aa = B(f6, [["__scopeId", "data-v-78167519"]]);
function ua(t) {
  function e(s) {
    var o;
    for (const r of Js)
      ((o = r.getPanelComponent()) == null ? void 0 : o.id) === s && r.close();
    n.value === s && (n.value = t);
  }
  const n = j(t);
  return { activeTab: n, removeTab: e };
}
const h6 = {},
  m6 = { class: "Panel" },
  g6 = { class: "container" };
function v6(t, e) {
  return (
    d(), C("div", m6, [h("div", g6, [G(t.$slots, "default", {}, void 0, !0)])])
  );
}
const ci = B(h6, [
    ["render", v6],
    ["__scopeId", "data-v-569dbae1"],
  ]),
  y6 = { class: "DesktopLayout" },
  C6 = { class: "header" },
  w6 = { class: "sudokuWrapper" },
  b6 = { class: "actions" },
  k6 = S({
    __name: "DesktopLayout",
    setup(t) {
      const { project: e } = ke(),
        { activeTab: n } = ua("tools"),
        s = Wi(),
        o = Qi(),
        r = b(() => {
          const a = [{ id: "tools", label: "Tools", component: aa }];
          for (const u of Js) {
            const p = u.getPanelComponent();
            p && a.push(p);
          }
          return a;
        });
      function l() {
        s.open(e.value);
      }
      function i() {
        o.open();
      }
      return (a, u) => (
        d(),
        C("div", y6, [
          c(ci, null, {
            default: f(() => [
              h("div", C6, [c(xp), c(Ap)]),
              c(Xp),
              u[0] ||
                (u[0] = h(
                  "h2",
                  { style: { "margin-bottom": "0.5em" } },
                  " Elements ",
                  -1
                )),
              (d(), w(Tp, { key: y(e).id })),
            ]),
            _: 1,
          }),
          h("div", w6, [
            h("div", b6, [
              c(Yt, null, {
                default: f(() => [
                  c(
                    te,
                    { "with-icon": "", onClick: l },
                    {
                      default: f(() => [
                        c(ls),
                        c(rl, { name: y(e).name }, null, 8, ["name"]),
                      ]),
                      _: 1,
                    }
                  ),
                  c(ul, { project: y(e) }, null, 8, ["project"]),
                  c(
                    te,
                    { "with-icon": "", onClick: i },
                    {
                      default: f(() => [
                        c(Ys),
                        u[1] || (u[1] = h("span", null, "Share", -1)),
                      ]),
                      _: 1,
                    }
                  ),
                ]),
                _: 1,
              }),
            ]),
            G(a.$slots, "sudoku"),
            c(oa, { "include-version": "" }),
          ]),
          c(ci, null, {
            default: f(() => [
              (d(!0),
              C(
                Z,
                null,
                se(
                  r.value,
                  (p) => (
                    d(),
                    w(
                      yi,
                      { key: p.id },
                      [
                        y(n) === p.id
                          ? (d(),
                            w(qe(p.component), {
                              key: 0,
                              class: "panelContent",
                            }))
                          : z("", !0),
                      ],
                      1024
                    )
                  )
                ),
                128
              )),
              c(la),
            ]),
            _: 1,
          }),
        ])
      );
    },
  }),
  Sl = B(k6, [["__scopeId", "data-v-3d561a47"]]),
  _6 = S({}),
  $6 = { class: "Description" };
function S6(t, e, n, s, o, r) {
  return d(), C("div", $6, [G(t.$slots, "default")]);
}
const I6 = B(_6, [
    ["render", S6],
    ["__scopeId", "data-v-3d146338"],
  ]),
  x6 = {},
  D6 = { class: "SubForm" },
  M6 = { class: "content" };
function A6(t, e) {
  return (
    d(), C("div", D6, [h("div", M6, [G(t.$slots, "default", {}, void 0, !0)])])
  );
}
const Qp = B(x6, [
    ["render", A6],
    ["__scopeId", "data-v-4a6d700e"],
  ]),
  P6 = { components: { Icon: he } };
function L6(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "Brush", viewBox: "0 0 16 16" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M4.91 15.06c-1.55-.04-3.42-1.2-3.86-2.63-.85-2.72 4.6-1.6 3-2.55-.58-.35-1.68-.9-2.4-1.55C.47 7.28.46 6.35.46 6.35s.71 1.43 2.55 2.28c1.75.81 3.02.93 3.02 1.63 0 1-3.5.65-2 2.06.7.65 1.55 1.01 2.73.98-.28.73-.6 1.23-1.23 1.27-.39.03-.52.06-.63.49Z",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M7.45 12.27a2 2 0 1 1 3.98-.27c0 3.2-6 3.07-6 3.07 1.06 0 2-1.07 2.02-2.8ZM10.9 9.9l-1.24-.4s-.91-1.4.05-4.41c.97-3.02 2.85-4.63 2.85-4.63l1.24.4s.59 2.4-.38 5.42C12.45 9.29 10.9 9.9 10.9 9.9Z",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const E6 = B(P6, [
    ["render", L6],
    ["__scopeId", "data-v-de821a45"],
  ]),
  F6 = S({
    __name: "EditorFormBase",
    props: { context: {}, showStyleControls: { type: Boolean } },
    emits: ["toggleStyleControls"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = k1(),
        r = !!o.appearance,
        l = j(!!o.buttonsLeft || !!o.buttons || !!o.appearance),
        i = j(n.showStyleControls || !1);
      return (
        ae(i, () => {
          s("toggleStyleControls", i.value);
        }),
        (a, u) => (
          d(),
          w(
            be,
            { class: "EditorFormBase", vertical: "", gap: "" },
            {
              default: f(() => [
                a.$slots.description
                  ? (d(),
                    w(
                      I6,
                      { key: 0 },
                      {
                        default: f(() => [
                          G(a.$slots, "description", {}, void 0, !0),
                        ]),
                        _: 3,
                      }
                    ))
                  : z("", !0),
                G(a.$slots, "properties", {}, void 0, !0),
                c(ns, null, {
                  default: f(() => [
                    i.value
                      ? (d(),
                        w(
                          Qp,
                          { key: 0 },
                          {
                            default: f(() => [
                              c(
                                be,
                                { vertical: "", gap: "" },
                                {
                                  default: f(() => [
                                    G(a.$slots, "appearance", {}, void 0, !0),
                                  ]),
                                  _: 3,
                                }
                              ),
                            ]),
                            _: 3,
                          }
                        ))
                      : z("", !0),
                  ]),
                  _: 3,
                }),
                l.value
                  ? (d(),
                    w(
                      be,
                      { key: 1, class: "buttons", gap: "" },
                      {
                        default: f(() => [
                          r
                            ? (d(),
                              w(
                                te,
                                {
                                  key: 0,
                                  icon: "",
                                  active: i.value,
                                  onClick:
                                    u[0] ||
                                    (u[0] = (p) => (i.value = !i.value)),
                                },
                                {
                                  default: f(() => [
                                    c(E6),
                                    c(
                                      Te,
                                      {
                                        text: i.value
                                          ? "Hide appearance controls"
                                          : "Edit appearance",
                                        delay: "",
                                      },
                                      null,
                                      8,
                                      ["text"]
                                    ),
                                  ]),
                                  _: 1,
                                },
                                8,
                                ["active"]
                              ))
                            : z("", !0),
                          G(a.$slots, "buttonsLeft", {}, void 0, !0),
                          c(Je),
                          c(Yt, null, {
                            default: f(() => [
                              G(a.$slots, "buttons", {}, void 0, !0),
                            ]),
                            _: 3,
                          }),
                        ]),
                        _: 3,
                      }
                    ))
                  : z("", !0),
              ]),
              _: 3,
            }
          )
        )
      );
    },
  }),
  yt = B(F6, [["__scopeId", "data-v-1e3c337b"]]),
  ca = S({
    __name: "DefaultEditor",
    props: { context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        w(
          yt,
          { context: e.context },
          os({ properties: f(() => [G(e.$slots, "properties")]), _: 2 }, [
            e.$slots.appearance
              ? {
                  name: "appearance",
                  fn: f(() => [G(e.$slots, "appearance")]),
                  key: "0",
                }
              : void 0,
          ]),
          1032,
          ["context"]
        )
      );
    },
  }),
  B6 = S({}),
  z6 = { class: "ControlRow" };
function R6(t, e, n, s, o, r) {
  return d(), C("div", z6, [G(t.$slots, "default", {}, void 0, !0)]);
}
const dl = B(B6, [
    ["render", R6],
    ["__scopeId", "data-v-dd42858a"],
  ]),
  O6 = S({
    components: { FormControlLabel: ut, CheckBox: at },
    props: {
      value: { type: Boolean, required: !0 },
      label: { type: String, required: !0 },
    },
    emits: { input: (t, e) => !0 },
    data() {
      return { controlId: fe() };
    },
    methods: {
      updateValue(t) {
        this.$emit("input", t, this.controlId);
      },
    },
  });
function N6(t, e, n, s, o, r) {
  const l = H("CheckBox"),
    i = H("FormControlLabel");
  return (
    d(),
    w(
      i,
      { class: "BooleanInput" },
      {
        default: f(() => [
          c(
            l,
            { checked: t.value, "onUpdate:checked": t.updateValue },
            null,
            8,
            ["checked", "onUpdate:checked"]
          ),
          F(" " + X(t.label), 1),
        ]),
        _: 1,
      }
    )
  );
}
const T6 = B(O6, [["render", N6]]),
  V6 = S({
    components: { FormRow: ve, ColorPicker: yo },
    props: {
      color: { type: String, required: !0 },
      label: { type: String, default: "Color" },
    },
    emits: { input: (t, e) => !0 },
    data() {
      return { colorControlId: fe(), colorPicker: null };
    },
    mounted() {
      this.colorPicker = this.$refs.colorPicker;
    },
    methods: {
      updateColor(t) {
        this.$emit("input", t, this.colorControlId);
      },
    },
  });
function j6(t, e, n, s, o, r) {
  const l = H("ColorPicker"),
    i = H("FormRow");
  return (
    d(),
    w(
      i,
      {
        class: "ColorInput",
        label: `${t.label}:`,
        clickable: "",
        onLabelClick:
          e[0] ||
          (e[0] = (a) => {
            var u;
            return (u = t.colorPicker) == null ? void 0 : u.open();
          }),
      },
      {
        default: f(() => [
          c(
            l,
            {
              ref: "colorPicker",
              "model-value": t.color,
              "include-alpha": "",
              "onUpdate:modelValue": t.updateColor,
            },
            null,
            8,
            ["model-value", "onUpdate:modelValue"]
          ),
        ]),
        _: 1,
      },
      8,
      ["label"]
    )
  );
}
const Cn = B(V6, [["render", j6]]),
  U6 = S({
    components: { NumberInput: Ht, FormRow: ve },
    props: {
      value: { type: Number, required: !0 },
      label: { type: String, required: !0 },
      min: { type: Number, default: 0 },
      max: { type: Number, default: 1 },
    },
    emits: { input: (t, e) => !0 },
    data() {
      return { controlId: fe() };
    },
    computed: {
      scaledValue() {
        return Math.round(this.value * 100);
      },
    },
    methods: {
      updateValue(t) {
        this.$emit("input", t / 100, this.controlId);
      },
    },
  }),
  H6 = ["min", "max", "value"];
function W6(t, e, n, s, o, r) {
  const l = H("NumberInput"),
    i = H("FormRow");
  return (
    d(),
    w(
      i,
      { class: "GeometrySizeInput", label: `${t.label}:` },
      {
        default: f(() => [
          h(
            "input",
            {
              class: "slider",
              type: "range",
              min: t.min * 100,
              max: t.max * 100,
              value: t.scaledValue,
              onInput:
                e[0] || (e[0] = (a) => t.updateValue(Number(a.target.value))),
            },
            null,
            40,
            H6
          ),
          c(
            l,
            {
              value: t.scaledValue,
              min: t.min * 100,
              compact: "",
              "onUpdate:value": t.updateValue,
            },
            null,
            8,
            ["value", "min", "onUpdate:value"]
          ),
        ]),
        _: 1,
      },
      8,
      ["label"]
    )
  );
}
const hn = B(U6, [
    ["render", W6],
    ["__scopeId", "data-v-99d9e71d"],
  ]),
  Z6 = S({
    components: { GeometrySizeInput: hn },
    props: {
      radius: { type: Number, required: !0 },
      label: { type: String, default: "Radius" },
    },
    emits: { input: (t, e) => !0 },
    methods: {
      updateRadius(t, e) {
        this.$emit("input", t, e);
      },
    },
  });
function G6(t, e, n, s, o, r) {
  const l = H("GeometrySizeInput");
  return (
    d(),
    w(
      l,
      {
        class: "RadiusInput",
        label: t.label,
        value: t.radius,
        max: 0.5,
        onInput: t.updateRadius,
      },
      null,
      8,
      ["label", "value", "onInput"]
    )
  );
}
const Fr = B(Z6, [["render", G6]]),
  q6 = S({
    components: {
      ControlRow: dl,
      FormControlLabel: ut,
      CheckBox: at,
      TooltipIndicator: dt,
      Tooltip: Te,
      FormRow: ve,
      TextInput: vt,
    },
    props: {
      properties: { type: Array, required: !0 },
      layout: { type: Array, default: void 0 },
      context: { type: Object, required: !0 },
    },
    computed: {
      propertiesByName() {
        const t = {};
        for (const e of this.properties) t[e.name] = e;
        return t;
      },
      rows() {
        return (this.layout || this.properties.map((e) => [e.name])).map((e) =>
          e.map((n) => this.getComponent(this.propertiesByName[n]))
        );
      },
    },
    methods: {
      getComponent(t) {
        const { type: e, name: n, value: s, label: o, binding: r } = t;
        switch (e) {
          case "color":
            return {
              name: n,
              component: Cn,
              props: {
                color: s,
                label: o,
                onInput: (l, i) => {
                  this.context.updateConstraintAppearance(
                    (r == null ? void 0 : r(l)) || { [n]: l },
                    `update:${n}`,
                    i
                  );
                },
              },
            };
          case "radius":
            return {
              name: n,
              component: Fr,
              props: {
                radius: s,
                label: o,
                onInput: (l, i) => {
                  this.context.updateConstraintAppearance(
                    (r == null ? void 0 : r(l)) || { [n]: l },
                    `update:${n}`,
                    i
                  );
                },
              },
            };
          case "size":
            return {
              name: n,
              component: hn,
              props: {
                value: s,
                label: o,
                min: t.min,
                max: t.max,
                onInput: (l, i) => {
                  this.context.updateConstraintAppearance(
                    (r == null ? void 0 : r(l)) || { [n]: l },
                    `update:${n}`,
                    i
                  );
                },
              },
            };
          case "lineWidth":
            return {
              name: n,
              component: hn,
              props: {
                value: s,
                label: o,
                max: 0.5,
                onInput: (l, i) => {
                  this.context.updateConstraintAppearance(
                    (r == null ? void 0 : r(l)) || { [n]: l },
                    `update:${n}`,
                    i
                  );
                },
              },
            };
          case "boolean":
            return {
              name: n,
              component: T6,
              props: {
                value: s,
                label: o,
                onInput: (l, i) => {
                  this.context.updateConstraintAppearance(
                    (r == null ? void 0 : r(l)) || { [n]: l },
                    `update:${n}`,
                    i
                  );
                },
              },
            };
        }
      },
    },
  });
function K6(t, e, n, s, o, r) {
  const l = H("ControlRow");
  return (
    d(!0),
    C(
      Z,
      null,
      se(
        t.rows,
        (i, a) => (
          d(),
          w(
            l,
            { key: a },
            {
              default: f(() => [
                (d(!0),
                C(
                  Z,
                  null,
                  se(
                    i,
                    ({ name: u, component: p, props: m }) => (
                      d(), w(qe(p), St({ key: u, ref_for: !0 }, m), null, 16)
                    )
                  ),
                  128
                )),
              ]),
              _: 2,
            },
            1024
          )
        )
      ),
      128
    )
  );
}
const X6 = B(q6, [
  ["render", K6],
  ["__scopeId", "data-v-3a6b20cc"],
]);
function Y6(t, e) {
  bn(t, e);
}
function J6(t, e) {
  bn(t.style, e);
}
function xe({
  editor: t,
  propertiesForm: e,
  appearanceForm: n,
  updateFunc: s = Y6,
  updateStyleFunc: o = J6,
}) {
  const r = () => ({});
  return (
    t || (t = { component: ca }),
    t.props || (t.props = r),
    n && !n.component && (n.component = X6),
    S({
      props: {
        constraint: { type: Object, required: !0 },
        initParams: { type: Object, default: void 0 },
      },
      setup(l) {
        const {
            project: i,
            updateConstraint: a,
            updateConstraintAppearance: u,
          } = ke(),
          p = b(() => ({ project: i.value, helpers: i.value.helpers })),
          m = (v, $, k, M) => {
            u(
              l.constraint,
              (P) => {
                o(P.config, ue(v));
              },
              $,
              { id: k, ...M }
            );
          },
          g = (v, $, k, M) => {
            a(
              l.constraint,
              (P) => {
                s(P.config, ue(v), p.value);
              },
              $,
              { id: k, ...M }
            );
          };
        return () => {
          const v = {
            project: p.value.project,
            helpers: p.value.helpers,
            constraint: l.constraint,
            constraints: i.value.allConstraints,
            initParams: l.initParams,
            updateConstraintAppearance: m,
            updateConstraint: g,
          };
          return Qt(
            t.component,
            { context: v, ...t.props(l.constraint.config, p.value) },
            {
              properties: e
                ? () =>
                    Qt(e.component, {
                      context: v,
                      ...e.props(l.constraint.config, p.value),
                    })
                : void 0,
              appearance: n
                ? () =>
                    Qt(n.component, {
                      context: v,
                      ...n.props(l.constraint.config, p.value),
                    })
                : void 0,
              ...gn(t.slots, l.constraint.config),
            }
          );
        };
      },
    })
  );
}
const Q6 = S({
    __name: "ConstraintButton",
    props: { project: {}, constraint: {}, active: { type: Boolean } },
    setup(t) {
      const e = t,
        n = b(() => je.getPreview(e.constraint.config.type)),
        s = b(() => !e.constraint.enabled);
      return (o, r) => (
        d(),
        w(
          te,
          {
            class: Ae([
              "ConstraintButton",
              { active: o.active, disabled: s.value },
            ]),
          },
          {
            default: f(() => [
              (d(),
              w(
                qe(n.value),
                {
                  constraint: o.constraint.config,
                  context: o.project,
                  class: "image",
                },
                null,
                8,
                ["constraint", "context"]
              )),
              c(
                Bp,
                { constraint: o.constraint, "show-warnings": !o.active },
                null,
                8,
                ["constraint", "show-warnings"]
              ),
            ]),
            _: 1,
          },
          8,
          ["class"]
        )
      );
    },
  }),
  e$ = B(Q6, [["__scopeId", "data-v-51206fc5"]]),
  t$ = { class: "ConstraintsBar" },
  n$ = { class: "buttons" },
  s$ = { key: 0 },
  o$ = { key: 0 },
  r$ = { class: "header" },
  l$ = { class: "name" },
  i$ = S({
    __name: "ConstraintsBar",
    setup(t) {
      const { project: e, updateConstraint: n } = ke(),
        s = j({}),
        {
          toggleOpened: o,
          showPicker: r,
          options: l,
          openConstraint: i,
          openEditorInitParams: a,
          create: u,
          remove: p,
          rename: m,
          duplicate: g,
          toggleEnabled: v,
          toggleSolverIgnored: $,
          moveUp: k,
          moveDown: M,
        } = Rp(e),
        { open: P } = gp(),
        x = b(() => {
          if (!i.value || !i.value.enabled) return;
          const U = je.getEditor(i.value.config.type);
          return U || xe({ editor: { component: ca } });
        }),
        A = b(() => {
          const U = i.value;
          return U ? U.name || je.getLabel(U.config, e.value.spec) : "";
        });
      ae(i, (U) => {
        U &&
          wn(() => {
            var D;
            (D = s.value[U.id]) == null ||
              D.scrollIntoView({ block: "nearest", inline: "nearest" });
          });
      });
      const O = j();
      function V(U) {
        O.value = U;
      }
      function I(U) {
        O.value &&
          n(
            O.value,
            (D) => {
              D.config = U;
            },
            "edit constraint"
          ),
          (O.value = void 0);
      }
      return (U, D) => {
        var N, E;
        return (
          d(),
          C("div", t$, [
            h("div", n$, [
              c(Ti, null, {
                default: f(() => [
                  c(
                    vi,
                    { tag: "div", class: "wrapper", name: "fade" },
                    {
                      default: f(() => [
                        (d(!0),
                        C(
                          Z,
                          null,
                          se(
                            y(e).allConstraints,
                            (R, W) => (
                              d(),
                              C(
                                "div",
                                {
                                  key: R.id,
                                  ref_for: !0,
                                  ref: (T) => {
                                    s.value[R.id] = T;
                                  },
                                  class: "buttonWrapper",
                                },
                                [
                                  c(
                                    Yl,
                                    null,
                                    {
                                      default: f(() => [
                                        R === y(i) && W > 0
                                          ? (d(),
                                            C("div", s$, [
                                              c(
                                                te,
                                                {
                                                  class:
                                                    "moveButton moveLeftButton",
                                                  icon: "",
                                                  onClick: (T) => y(k)(W),
                                                },
                                                {
                                                  default: f(() => [c(sp)]),
                                                  _: 2,
                                                },
                                                1032,
                                                ["onClick"]
                                              ),
                                            ]))
                                          : z("", !0),
                                      ]),
                                      _: 2,
                                    },
                                    1024
                                  ),
                                  c(
                                    e$,
                                    {
                                      project: y(e),
                                      active: R === y(i),
                                      constraint: R,
                                      onClick: (T) => y(o)(R),
                                    },
                                    null,
                                    8,
                                    [
                                      "project",
                                      "active",
                                      "constraint",
                                      "onClick",
                                    ]
                                  ),
                                  c(
                                    Yl,
                                    null,
                                    {
                                      default: f(() => [
                                        R === y(i) &&
                                        W < y(e).allConstraints.length - 1
                                          ? (d(),
                                            C("div", o$, [
                                              c(
                                                te,
                                                {
                                                  class:
                                                    "moveButton moveRightButton",
                                                  icon: "",
                                                  onClick: (T) => y(M)(W),
                                                },
                                                {
                                                  default: f(() => [c(op)]),
                                                  _: 2,
                                                },
                                                1032,
                                                ["onClick"]
                                              ),
                                            ]))
                                          : z("", !0),
                                      ]),
                                      _: 2,
                                    },
                                    1024
                                  ),
                                ]
                              )
                            )
                          ),
                          128
                        )),
                      ]),
                      _: 1,
                    }
                  ),
                ]),
                _: 1,
              }),
              c(
                te,
                {
                  class: "addButton",
                  icon: "",
                  onClick: D[0] || (D[0] = (R) => (r.value = !0)),
                },
                { default: f(() => [c(es)]), _: 1 }
              ),
              c(Oe, null, {
                default: f(({ target: R }) => [
                  y(r)
                    ? (d(),
                      w(
                        zp,
                        {
                          key: 0,
                          target: R,
                          options: y(l),
                          project: y(e),
                          onClose: D[1] || (D[1] = (W) => (r.value = !1)),
                          onSelect: y(u),
                        },
                        null,
                        8,
                        ["target", "options", "project", "onSelect"]
                      ))
                    : z("", !0),
                ]),
                _: 1,
              }),
            ]),
            y(i)
              ? (d(),
                C(
                  "div",
                  { key: (N = y(i)) == null ? void 0 : N.id, class: "editor" },
                  [
                    h("h3", r$, [
                      h("span", l$, [
                        F(X(A.value) + " ", 1),
                        (E = y(i)) != null && E.enabled
                          ? z("", !0)
                          : (d(), C(Z, { key: 0 }, [F("(disabled)")], 64)),
                      ]),
                      c(
                        Fp,
                        {
                          constraint: y(i),
                          onRename: D[2] || (D[2] = (R) => y(m)(y(i), R)),
                          onEdit: D[3] || (D[3] = (R) => y(P)(y(i))),
                          onDuplicate: D[4] || (D[4] = (R) => y(g)(y(i))),
                          onToggle: D[5] || (D[5] = (R) => y(v)(y(i))),
                          onToggleSolver: D[6] || (D[6] = (R) => y($)(y(i))),
                          onRemove: D[7] || (D[7] = (R) => y(p)(y(i))),
                          onEditRaw: D[8] || (D[8] = (R) => V(y(i))),
                        },
                        null,
                        8,
                        ["constraint"]
                      ),
                    ]),
                    (d(),
                    w(
                      qe(x.value),
                      {
                        constraint: y(i),
                        "init-params": y(a),
                        onOpenCustomConstraintEditor:
                          D[9] || (D[9] = (R) => y(P)(y(i))),
                      },
                      null,
                      40,
                      ["constraint", "init-params"]
                    )),
                    c(Oe, null, {
                      default: f(() => [
                        O.value
                          ? (d(),
                            w(
                              Op,
                              {
                                key: 0,
                                constraint: O.value,
                                onSubmit: I,
                                onClose:
                                  D[10] || (D[10] = (R) => (O.value = void 0)),
                              },
                              null,
                              8,
                              ["constraint"]
                            ))
                          : z("", !0),
                      ]),
                      _: 1,
                    }),
                  ]
                ))
              : z("", !0),
          ])
        );
      };
    },
  }),
  a$ = B(i$, [["__scopeId", "data-v-2b8744af"]]),
  u$ = S({
    components: { SudokuSvg: Xs },
    props: {
      project: { type: ln, required: !0 },
      includeNonGivens: { type: Boolean, default: !1 },
    },
    computed: {
      previewPuzzle() {
        return this.project.toPuzzlePreviewData();
      },
    },
  }),
  c$ = { class: "ProjectPreview" };
function d$(t, e, n, s, o, r) {
  const l = H("SudokuSvg");
  return (
    d(),
    C("div", c$, [
      c(
        l,
        {
          spec: t.previewPuzzle.spec,
          cells: t.previewPuzzle.cells,
          constraints: t.previewPuzzle.constraints,
          readonly: "",
        },
        null,
        8,
        ["spec", "cells", "constraints"]
      ),
    ])
  );
}
const p$ = B(u$, [
    ["render", d$],
    ["__scopeId", "data-v-e16835de"],
  ]),
  f$ = { class: "FilePanel" },
  h$ = { class: "footer" },
  m$ = { class: "version" },
  g$ = S({
    __name: "FilePanel",
    setup(t) {
      const e = "Sudoku Maker",
        { project: n } = ke(),
        s = Qi();
      return (o, r) => (
        d(),
        C("div", f$, [
          c(p$, { project: y(n) }, null, 8, ["project"]),
          c(
            mp,
            {
              author: y(n).author,
              "onUpdate:author": r[0] || (r[0] = (l) => (y(n).author = l)),
              name: y(n).name,
              "onUpdate:name": r[1] || (r[1] = (l) => (y(n).name = l)),
              comment: y(n).comment,
              "onUpdate:comment": r[2] || (r[2] = (l) => (y(n).comment = l)),
              "completion-message": y(n).messages.completion,
              "onUpdate:completionMessage":
                r[3] || (r[3] = (l) => (y(n).messages.completion = l)),
              "min-digit": y(n).spec.minDigit,
              "onUpdate:minDigit":
                r[4] || (r[4] = (l) => (y(n).spec.minDigit = l)),
              "max-digit": y(n).spec.maxDigit,
              "onUpdate:maxDigit":
                r[5] || (r[5] = (l) => (y(n).spec.maxDigit = l)),
              "show-digits-input": y(n).spec.type === y(Ie).Custom,
            },
            null,
            8,
            [
              "author",
              "name",
              "comment",
              "completion-message",
              "min-digit",
              "max-digit",
              "show-digits-input",
            ]
          ),
          c(Ft, null, {
            default: f(() => [
              c(Je),
              c(Yt, null, {
                default: f(() => [
                  c(ul, { project: y(n) }, null, 8, ["project"]),
                  c(
                    te,
                    {
                      "with-icon": "",
                      onClick: r[6] || (r[6] = (l) => y(s).open()),
                    },
                    {
                      default: f(() => [
                        c(Ys),
                        r[7] || (r[7] = h("span", null, "Share", -1)),
                      ]),
                      _: 1,
                    }
                  ),
                ]),
                _: 1,
              }),
            ]),
            _: 1,
          }),
          h("div", h$, [
            h("div", m$, [
              c(
                Ap,
                { "as-link": "" },
                { default: f(() => [F(" About " + X(y(e)), 1)]), _: 1 }
              ),
              r[8] || (r[8] = F(" · ")),
              c(sa),
            ]),
            c(oa),
          ]),
        ])
      );
    },
  }),
  v$ = B(g$, [["__scopeId", "data-v-7e37ce56"]]),
  y$ = { class: "MobileLayout" },
  C$ = { class: "scrollable" },
  w$ = { class: "wrapper" },
  b$ = { class: "header" },
  k$ = { class: "tabPanel" },
  _$ = { key: 0, class: "fileButtons" },
  $$ = { class: "main" },
  S$ = { class: "sudokuWrapper" },
  I$ = S({
    __name: "MobileLayout",
    setup(t) {
      zn((p) => ({ "3fdf260f": i.value, "475648e1": u.value }));
      const { activeTab: e } = ua("elements"),
        n = b(() => e.value !== "file"),
        s = b(() => {
          const p = [{ id: "tools", label: "Tools", component: aa }];
          for (const m of Js) {
            const g = m.getPanelComponent();
            g && p.push(g);
          }
          return p;
        }),
        o = b(() => [
          { id: "file", label: "File" },
          { id: "elements", label: "Elements" },
          ...s.value.map((p) => ({
            id: p.id,
            label: p.label,
            removable: p.id !== "tools",
          })),
        ]),
        { project: r } = ke();
      ae(r, () => {
        e.value === "file" && (e.value = "elements");
      });
      const l = j(),
        i = j("0rem"),
        a = b(() => {
          var p;
          return (p = l.value) == null
            ? void 0
            : p.$el.querySelector(".buttons");
        });
      js(a, (p) => {
        i.value = `${p.at(-1).target.clientHeight}px`;
      }),
        ae(a, (p) => {
          p || (i.value = "0rem");
        });
      const u = b(() => (td ? "2rem" : "0.5rem"));
      return (p, m) => (
        d(),
        C("div", y$, [
          c(
            ts,
            {
              "active-tab": y(e),
              "onUpdate:activeTab":
                m[0] || (m[0] = (g) => (Rn(e) ? (e.value = g) : null)),
              tabs: o.value,
              compact: "",
            },
            null,
            8,
            ["active-tab", "tabs"]
          ),
          h("div", C$, [
            h("div", w$, [
              h("div", b$, [
                h("div", k$, [
                  y(e) === "file" ? (d(), C("div", _$, [c(Xp)])) : z("", !0),
                  n.value
                    ? Ln(
                        (d(), w(a$, { key: 1, class: "elements" }, null, 512)),
                        [[bs, y(e) === "elements"]]
                      )
                    : z("", !0),
                  (d(!0),
                  C(
                    Z,
                    null,
                    se(
                      s.value,
                      (g) => (
                        d(),
                        w(
                          yi,
                          { key: g.id },
                          [
                            y(e) === g.id
                              ? (d(),
                                w(qe(g.component), {
                                  key: 0,
                                  class: "panelContent",
                                }))
                              : z("", !0),
                          ],
                          1024
                        )
                      )
                    ),
                    128
                  )),
                ]),
              ]),
              h("div", $$, [
                y(e) === "file"
                  ? (d(), w(v$, { key: 0 }))
                  : (d(),
                    C(
                      Z,
                      { key: 1 },
                      [
                        h("div", S$, [G(p.$slots, "sudoku")]),
                        c(la, { ref_key: "inputPanel", ref: l }, null, 512),
                      ],
                      64
                    )),
              ]),
            ]),
          ]),
        ])
      );
    },
  }),
  lr = B(I$, [["__scopeId", "data-v-08e6b66a"]]),
  x$ = 1;
function D$() {
  return { hideInputPanel: !1 };
}
const ir = xs({ name: "interfaceState", version: x$, getDefault: D$ }),
  M$ = { class: "content" },
  A$ = S({
    __name: "CollapsibleInputPanel",
    setup(t) {
      function e() {
        ir.hideInputPanel = !ir.hideInputPanel;
      }
      return (n, s) => (
        d(),
        C(
          "div",
          {
            class: Ae([
              "CollapsibleInputPanel",
              { hidden: y(ir).hideInputPanel },
            ]),
          },
          [
            Ln(
              c(
                ns,
                null,
                {
                  default: f(() => [
                    h("div", M$, [
                      c(la),
                      h("button", { class: "toggleButton", onClick: e }, [
                        c(Ri),
                      ]),
                    ]),
                  ]),
                  _: 1,
                },
                512
              ),
              [[bs, !y(ir).hideInputPanel]]
            ),
            c(
              te,
              { class: "showButton", "with-icon": "", onClick: e },
              {
                default: f(() => [
                  c(Np),
                  s[0] || (s[0] = h("span", null, "Show input panel", -1)),
                ]),
                _: 1,
              }
            ),
          ],
          2
        )
      );
    },
  }),
  P$ = B(A$, [["__scopeId", "data-v-c1ff9c56"]]),
  L$ = S({
    __name: "FileDropdown",
    setup(t) {
      const e = j(!1),
        n = j(!1),
        s = j(!1),
        o = j(!1),
        { open: r } = vp();
      return (l, i) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              Ge,
              { onClick: i[0] || (i[0] = (a) => (e.value = !0)) },
              {
                default: f(() => [c(es), i[8] || (i[8] = F(" New puzzle "))]),
                _: 1,
              }
            ),
            c(
              Ge,
              { onClick: i[1] || (i[1] = (a) => (s.value = !0)) },
              {
                default: f(() => [c(Wo), i[9] || (i[9] = F(" Open puzzle "))]),
                _: 1,
              }
            ),
            c(
              Ge,
              { onClick: i[2] || (i[2] = (a) => (n.value = !0)) },
              {
                default: f(() => [
                  c(Kp),
                  i[10] || (i[10] = F(" Recent puzzles ")),
                ]),
                _: 1,
              }
            ),
            i[13] || (i[13] = h("hr", null, null, -1)),
            c(
              Ge,
              { onClick: y(r) },
              {
                default: f(() => [
                  c(ra),
                  i[11] || (i[11] = F(" Preferences ")),
                ]),
                _: 1,
              },
              8,
              ["onClick"]
            ),
            i[14] || (i[14] = h("hr", null, null, -1)),
            c(
              Ge,
              { onClick: i[3] || (i[3] = (a) => (o.value = !0)) },
              {
                default: f(() => [c(_s), i[12] || (i[12] = F(" About "))]),
                _: 1,
              }
            ),
            c(Oe, null, {
              default: f(() => [
                e.value
                  ? (d(),
                    w(qp, {
                      key: 0,
                      onClose: i[4] || (i[4] = (a) => (e.value = !1)),
                    }))
                  : z("", !0),
              ]),
              _: 1,
            }),
            c(Oe, null, {
              default: f(() => [
                n.value
                  ? (d(),
                    w(Zp, {
                      key: 0,
                      onClose: i[5] || (i[5] = (a) => (n.value = !1)),
                    }))
                  : z("", !0),
              ]),
              _: 1,
            }),
            c(Oe, null, {
              default: f(() => [
                s.value
                  ? (d(),
                    w(Gp, {
                      key: 0,
                      onClose: i[6] || (i[6] = (a) => (s.value = !1)),
                    }))
                  : z("", !0),
              ]),
              _: 1,
            }),
            c(Oe, null, {
              default: f(() => [
                o.value
                  ? (d(),
                    w(Mp, {
                      key: 0,
                      onClose: i[7] || (i[7] = (a) => (o.value = !1)),
                    }))
                  : z("", !0),
              ]),
              _: 1,
            }),
          ],
          64
        )
      );
    },
  }),
  E$ = { components: { Icon: he } };
function F$(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      { class: "HamburgerIcon", viewBox: "0 0 16 16", stroke: "none" },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h("rect", { x: "0", y: "2", width: "16", height: "2" }, null, -1),
              h("rect", { x: "0", y: "7", width: "16", height: "2" }, null, -1),
              h(
                "rect",
                { x: "0", y: "12", width: "16", height: "2" },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const B$ = B(E$, [["render", F$]]),
  z$ = { class: "TabletLayout" },
  R$ = { class: "sudokuWrapper" },
  O$ = { class: "actions" },
  N$ = { class: "puzzleName" },
  T$ = { class: "menuButtonWrapper" },
  V$ = S({
    __name: "TabletLayout",
    setup(t) {
      const { project: e } = ke(),
        { activeTab: n } = ua("elements"),
        s = Wi(),
        o = Qi(),
        r = b(() => {
          const a = [
            { id: "elements", label: "Elements", component: Tp },
            { id: "tools", label: "Tools", component: aa },
          ];
          for (const u of Js) {
            const p = u.getPanelComponent();
            p && a.push(p);
          }
          return a;
        });
      function l() {
        s.open(e.value);
      }
      function i() {
        o.open();
      }
      return (a, u) => (
        d(),
        C("div", z$, [
          h("div", R$, [
            h("div", O$, [
              c(Yt, null, {
                default: f(() => [
                  c(
                    te,
                    { "with-icon": "", onClick: l },
                    {
                      default: f(() => [
                        c(ls, { style: { "flex-shrink": "0" } }),
                        h("span", N$, [
                          c(rl, { name: y(e).name }, null, 8, ["name"]),
                        ]),
                      ]),
                      _: 1,
                    }
                  ),
                  c(ul, { project: y(e) }, null, 8, ["project"]),
                  c(
                    te,
                    { class: "shareButton", "with-icon": "", onClick: i },
                    {
                      default: f(() => [
                        c(Ys),
                        u[1] || (u[1] = h("span", null, "Share", -1)),
                      ]),
                      _: 1,
                    }
                  ),
                ]),
                _: 1,
              }),
            ]),
            G(a.$slots, "sudoku"),
            c(oa, { "include-version": "" }),
          ]),
          (d(),
          w(
            ci,
            { key: y(e).id, class: "mainPanel" },
            {
              default: f(() => [
                c(be, null, {
                  default: f(() => [
                    h("div", T$, [
                      c(
                        sl,
                        { align: "left", persist: "" },
                        {
                          icon: f(() => [c(B$)]),
                          default: f(() => [c(L$)]),
                          _: 1,
                        }
                      ),
                    ]),
                    c(
                      ts,
                      {
                        "active-tab": y(n),
                        "onUpdate:activeTab":
                          u[0] ||
                          (u[0] = (p) => (Rn(n) ? (n.value = p) : null)),
                        tabs: r.value,
                      },
                      null,
                      8,
                      ["active-tab", "tabs"]
                    ),
                  ]),
                  _: 1,
                }),
                (d(!0),
                C(
                  Z,
                  null,
                  se(
                    r.value,
                    (p) => (
                      d(),
                      w(
                        yi,
                        { key: p.id },
                        [
                          y(n) === p.id
                            ? (d(),
                              w(qe(p.component), {
                                key: 0,
                                class: "panelContent",
                              }))
                            : z("", !0),
                        ],
                        1024
                      )
                    )
                  ),
                  128
                )),
                u[2] || (u[2] = h("hr", null, null, -1)),
                c(P$),
              ]),
              _: 1,
            }
          )),
        ])
      );
    },
  }),
  Il = B(V$, [["__scopeId", "data-v-b91a71c7"]]),
  j$ = S({
    __name: "MainLayout",
    setup(t) {
      const { project: e } = ke(),
        n = Qr();
      function s(i, a) {
        return Math.min(i - 25 * n.rem, a - 6 * n.rem);
      }
      function o(i, a) {
        return Math.min(i, a - 23 * n.rem);
      }
      function r(i, a) {
        return Math.min(i - 60 * n.rem, a - 6 * n.rem);
      }
      const l = b(() => {
        const { width: i, height: a, rem: u } = n,
          p = r(i, a),
          m = s(i, a),
          g = o(i, a),
          v = p >= u * 10,
          $ = m >= u * 10;
        switch (ee.preferredLayout) {
          case "wide":
            return v ? Sl : $ ? Il : lr;
          case "landscape":
            return $ ? Il : lr;
          case "portrait":
            return lr;
          default:
            return (i >= 80 * u && a >= 50 * u) || (p >= m && p >= g)
              ? Sl
              : m >= p && m >= g
              ? Il
              : lr;
        }
      });
      return (i, a) => (
        d(),
        w(qe(l.value), null, {
          sudoku: f(() => [(d(), w(Qw, { key: y(e).id }))]),
          _: 1,
        })
      );
    },
  }),
  U$ = S({
    __name: "App",
    setup(t) {
      const { project: e, addUndoRedoChildFactory: n, solverLogs: s } = ke(),
        o = bw(),
        r = Cw(),
        l = T3(),
        i = ww(),
        a = yw();
      return (
        n((u) => {
          if (u !== Nc.Visuals) {
            const p = Zt.value,
              m = s.value.lines.slice();
            return {
              action() {
                Nn.stop(new yp()),
                  (tn.value = !0),
                  s.value.logReset(),
                  (Zt.value = ss.None);
              },
              undo() {
                s.value.set(m), (Zt.value = p);
              },
            };
          } else return {};
        }),
        ae(e, () => {
          tn.value = !0;
        }),
        (u, p) => (
          d(),
          C(
            Z,
            null,
            [
              c(j$),
              c(Oe, null, {
                default: f(() => [
                  y(o).isOpen
                    ? (d(),
                      w(aw, {
                        key: 0,
                        onClose: p[0] || (p[0] = (m) => (y(o).isOpen = !1)),
                      }))
                    : z("", !0),
                ]),
                _: 1,
              }),
              c(Oe, null, {
                default: f(() => [
                  y(r).isOpen && y(r).params
                    ? (d(),
                      w(
                        qy,
                        {
                          key: 0,
                          constraint: y(r).params,
                          onClose: p[1] || (p[1] = (m) => (y(r).isOpen = !1)),
                        },
                        null,
                        8,
                        ["constraint"]
                      ))
                    : z("", !0),
                ]),
                _: 1,
              }),
              c(Oe, null, {
                default: f(() => [
                  y(i).isOpen
                    ? (d(),
                      w(LC, {
                        key: 0,
                        onClose: p[2] || (p[2] = (m) => (y(i).isOpen = !1)),
                      }))
                    : z("", !0),
                ]),
                _: 1,
              }),
              c(Oe, null, {
                default: f(() => [
                  y(l).isOpen && y(l).params
                    ? (d(),
                      w(
                        mw,
                        {
                          key: 0,
                          project: y(l).params,
                          onClose: p[3] || (p[3] = (m) => (y(l).isOpen = !1)),
                        },
                        null,
                        8,
                        ["project"]
                      ))
                    : z("", !0),
                ]),
                _: 1,
              }),
              c(Oe, null, {
                default: f(() => [
                  y(a).isOpen
                    ? (d(),
                      w(c5, {
                        key: 0,
                        onClose: p[4] || (p[4] = (m) => (y(a).isOpen = !1)),
                      }))
                    : z("", !0),
                ]),
                _: 1,
              }),
            ],
            64
          )
        )
      );
    },
  }),
  H$ = S({
    __name: "AlertDialog",
    setup(t) {
      const e = b(() => dn.value.options),
        n = j(fe()),
        s = j();
      ae(e, () => {
        (n.value = fe()),
          wn(() => {
            var l;
            (l = s.value) == null || l.$el.focus();
          });
      });
      function o() {
        dn.value.callback();
      }
      function r() {
        return Hc(dn.value.options.body);
      }
      return (l, i) => (
        d(),
        w(
          Oe,
          { key: n.value },
          {
            default: f(() => [
              y(dn).show
                ? (d(),
                  w(
                    Bt,
                    {
                      key: 0,
                      class: "AlertDialog",
                      variant: "content",
                      "backdrop-dismissible": !1,
                      dismissible: !1,
                      onClose: o,
                    },
                    {
                      default: f(() => [
                        h("h1", null, X(y(dn).options.header), 1),
                        h("div", null, [c(r)]),
                        c(Ft, null, {
                          default: f(() => [
                            c(Je),
                            c(
                              te,
                              {
                                ref_key: "okButton",
                                ref: s,
                                tabindex: "0",
                                onClick: o,
                              },
                              {
                                default: f(() => [
                                  F(X(y(dn).options.buttonText || "Got it"), 1),
                                ]),
                                _: 1,
                              },
                              512
                            ),
                          ]),
                          _: 1,
                        }),
                      ]),
                      _: 1,
                    }
                  ))
                : z("", !0),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  W$ = B(H$, [["__scopeId", "data-v-977bf2a1"]]),
  Z$ = { key: 0 },
  G$ = S({
    __name: "ConfirmDialog",
    setup(t) {
      const e = b(() => bt.options),
        n = j(fe());
      ae(e, (r) => {
        r && (n.value = fe());
      });
      function s() {
        var r;
        (r = bt.cancelCallback) == null || r.call(bt), (bt.show = !1);
      }
      function o() {
        var r;
        (r = bt.callback) == null || r.call(bt);
      }
      return (r, l) => (
        d(),
        w(
          Oe,
          { key: n.value },
          {
            default: f(() => [
              y(bt).show
                ? (d(),
                  w(
                    Bt,
                    {
                      key: 0,
                      class: "AlertDialog",
                      width: 30,
                      variant: "content",
                      onClose: s,
                    },
                    {
                      default: f(() => [
                        h("h2", null, X(e.value.header), 1),
                        e.value.body
                          ? (d(), C("div", Z$, X(e.value.body), 1))
                          : e.value.bodyComponent
                          ? (d(), w(qe(e.value.bodyComponent), { key: 1 }))
                          : z("", !0),
                        c(Ft, null, {
                          default: f(() => [
                            c(
                              te,
                              { onClick: s },
                              {
                                default: f(() => [
                                  h(
                                    "span",
                                    null,
                                    X(e.value.cancelText || "No"),
                                    1
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            c(Je),
                            c(
                              te,
                              {
                                variant: e.value.isDestructive
                                  ? "danger"
                                  : "default",
                                onClick: o,
                              },
                              {
                                default: f(() => [
                                  h(
                                    "span",
                                    null,
                                    X(e.value.confirmText || "Yes"),
                                    1
                                  ),
                                ]),
                                _: 1,
                              },
                              8,
                              ["variant"]
                            ),
                          ]),
                          _: 1,
                        }),
                      ]),
                      _: 1,
                    }
                  ))
                : z("", !0),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  q$ = B(G$, [["__scopeId", "data-v-97cae73a"]]),
  K$ = S({
    __name: "DevDialog",
    setup(t) {
      const e = ll("devNoticeRead", !1),
        n = "Sudoku Maker";
      return (s, o) => (
        d(),
        w(Oe, null, {
          default: f(() => [
            y(e)
              ? z("", !0)
              : (d(),
                w(
                  Bt,
                  { key: 0, variant: "content", dismissible: !1 },
                  {
                    default: f(() => [
                      c(un, null, {
                        default: f(() => [F(X(y(n)) + " DEV ", 1)]),
                        _: 1,
                      }),
                      h("p", null, [
                        o[2] || (o[2] = F(" Welcome to the ")),
                        o[3] || (o[3] = h("strong", null, "development", -1)),
                        F(
                          " version of " +
                            X(y(n)) +
                            ". Here, you can get a sneak peek of new features and bug fixes before they go live at ",
                          1
                        ),
                        c(
                          Jn,
                          { to: "https://sudokumaker.app/" },
                          {
                            default: f(
                              () =>
                                o[1] || (o[1] = [F("https://sudokumaker.app/")])
                            ),
                            _: 1,
                          }
                        ),
                        o[4] || (o[4] = F(". ")),
                      ]),
                      o[6] ||
                        (o[6] = h(
                          "p",
                          null,
                          " We recommend using this version with caution—especially when exploring new features, as it is even more experi­mental than the alpha version. Some updates might cause puzzles created here to not open or work as expected. ",
                          -1
                        )),
                      c(Ft, null, {
                        default: f(() => [
                          c(Je),
                          c(
                            te,
                            { onClick: o[0] || (o[0] = (r) => (e.value = !0)) },
                            {
                              default: f(
                                () =>
                                  o[5] ||
                                  (o[5] = [
                                    h(
                                      "span",
                                      { style: { "margin-right": "0.5em" } },
                                      "🫡",
                                      -1
                                    ),
                                    h("span", null, "Got it!", -1),
                                  ])
                              ),
                              _: 1,
                            }
                          ),
                        ]),
                        _: 1,
                      }),
                    ]),
                    _: 1,
                  }
                )),
          ]),
          _: 1,
        })
      );
    },
  }),
  X$ = { class: "message" },
  Y$ = { key: 0 },
  J$ = ["textContent"],
  Q$ = S({
    __name: "ErrorToasts",
    setup(t) {
      const e = j([]);
      return (
        Pt(na, "error", async ({ context: n, error: s }) => {
          await wn();
          const o = Date.now(),
            r = e.value.findIndex((i) => i.message === n);
          let l;
          r > -1
            ? ((l = e.value.splice(r, 1)[0]), l.count++, (l.timestamp = o))
            : (l = { message: n, count: 1, timestamp: o, error: s }),
            e.value.unshift(l),
            setTimeout(() => {
              Pn(e.value, l);
            }, 1e4);
        }),
        (n, s) => (
          d(),
          w(Oe, null, {
            default: f(() => [
              e.value.length > 0
                ? (d(),
                  w(
                    be,
                    { key: 0, class: "ErrorToasts", vertical: "", gap: "" },
                    {
                      default: f(() => [
                        (d(!0),
                        C(
                          Z,
                          null,
                          se(
                            e.value,
                            (o) => (
                              d(),
                              w(
                                be,
                                { key: o.timestamp, class: "entry", gap: "" },
                                {
                                  default: f(() => [
                                    c(Vo, { inline: "" }),
                                    h("div", X$, [
                                      o.count > 1
                                        ? (d(),
                                          C(
                                            "span",
                                            Y$,
                                            "×" + X(o.count) + " ",
                                            1
                                          ))
                                        : z("", !0),
                                      F(" " + X(o.message) + " ", 1),
                                      o.error
                                        ? (d(),
                                          C(
                                            "pre",
                                            { key: 1, textContent: X(o.error) },
                                            null,
                                            8,
                                            J$
                                          ))
                                        : z("", !0),
                                      s[0] || (s[0] = h("hr", null, null, -1)),
                                      s[1] ||
                                        (s[1] = F(
                                          " Check your browser's developer console for more info. "
                                        )),
                                    ]),
                                  ]),
                                  _: 2,
                                },
                                1024
                              )
                            )
                          ),
                          128
                        )),
                      ]),
                      _: 1,
                    }
                  ))
                : z("", !0),
            ]),
            _: 1,
          })
        )
      );
    },
  }),
  e7 = B(Q$, [["__scopeId", "data-v-0d6b31e0"]]);
function t7(t = {}) {
  const {
    immediate: e = !1,
    onNeedRefresh: n,
    onOfflineReady: s,
    onRegistered: o,
    onRegisteredSW: r,
    onRegisterError: l,
  } = t;
  let i, a, u;
  const p = async (g = !0) => {
    await a, await (u == null ? void 0 : u());
  };
  async function m() {
    if ("serviceWorker" in navigator) {
      if (
        ((i = await Md(async () => {
          const { Workbox: g } = await import(
            "./workbox-window.prod.es5-D5gOYdM7.js"
          );
          return { Workbox: g };
        }, [])
          .then(
            ({ Workbox: g }) => new g("/sw.js", { scope: "/", type: "classic" })
          )
          .catch((g) => {
            l == null || l(g);
          })),
        !i)
      )
        return;
      u = async () => {
        await (i == null ? void 0 : i.messageSkipWaiting());
      };
      {
        let g = !1;
        const v = () => {
          (g = !0),
            i == null ||
              i.addEventListener("controlling", ($) => {
                $.isUpdate && window.location.reload();
              }),
            n == null || n();
        };
        i.addEventListener("installed", ($) => {
          typeof $.isUpdate > "u"
            ? typeof $.isExternal < "u"
              ? $.isExternal
                ? v()
                : !g && (s == null || s())
              : $.isExternal
              ? window.location.reload()
              : !g && (s == null || s())
            : $.isUpdate || s == null || s();
        }),
          i.addEventListener("waiting", v),
          i.addEventListener("externalwaiting", v);
      }
      i.register({ immediate: e })
        .then((g) => {
          r ? r("/sw.js", g) : o == null || o(g);
        })
        .catch((g) => {
          l == null || l(g);
        });
    }
  }
  return (a = m()), p;
}
function n7(t = {}) {
  const {
      immediate: e = !0,
      onNeedRefresh: n,
      onOfflineReady: s,
      onRegistered: o,
      onRegisteredSW: r,
      onRegisterError: l,
    } = t,
    i = j(!1),
    a = j(!1);
  return {
    updateServiceWorker: t7({
      immediate: e,
      onNeedRefresh() {
        (i.value = !0), n == null || n();
      },
      onOfflineReady() {
        (a.value = !0), s == null || s();
      },
      onRegistered: o,
      onRegisteredSW: r,
      onRegisterError: l,
    }),
    offlineReady: a,
    needRefresh: i,
  };
}
const s7 = { key: 0, class: "ReloadPrompt" },
  o7 = { class: "message" },
  r7 = S({
    __name: "ReloadPrompt",
    setup(t) {
      const { needRefresh: e, updateServiceWorker: n } = n7({ immediate: !0 }),
        s = "Sudoku Maker";
      async function o() {
        e.value = !1;
      }
      return (r, l) =>
        y(e)
          ? (d(),
            C("div", s7, [
              h("div", o7, [
                l[1] || (l[1] = F(" 🚀 ")),
                h("span", null, [
                  F(" A new version of " + X(y(s)) + " is available. ", 1),
                  h(
                    "button",
                    {
                      class: "refresh",
                      onClick: l[0] || (l[0] = (i) => y(n)()),
                    },
                    " Click here to refresh. "
                  ),
                ]),
                h("button", { class: "close", onClick: o }, [c(Ks)]),
              ]),
            ]))
          : z("", !0);
    },
  }),
  l7 = B(r7, [["__scopeId", "data-v-5561e175"]]),
  i7 = { style: { width: "0", height: "0" } },
  a7 = { id: "darkModeFilter" },
  u7 = ["values"],
  c7 = S({
    __name: "SharedSvg",
    setup(t) {
      const e = b(() => {
        const o = 0.6330749999999999,
          r = (0.0159 - 0.86) * 0.875,
          l = 0.86;
        return `${o} ${r} ${r} 0 ${l}  ${r} ${o} ${r} 0 ${l}  ${r} ${r} ${o} 0 ${l}  0 0 0 1 0`;
      });
      return (n, s) => (
        d(),
        C("svg", i7, [
          h("filter", a7, [
            h(
              "feColorMatrix",
              { in: "SourceGraphic", type: "matrix", values: e.value },
              null,
              8,
              u7
            ),
          ]),
        ])
      );
    },
  }),
  d7 = { class: "NotFound" },
  p7 = {
    viewBox: "0 0 100 32",
    width: "200px",
    style: { "font-family": "Arial, sans-serif" },
  },
  f7 = S({
    __name: "NotFound",
    setup(t) {
      return (e, n) => (
        d(),
        C("div", d7, [
          (d(),
          C(
            "svg",
            p7,
            n[0] ||
              (n[0] = [
                Ro(
                  '<path d="M31 16h57m-14-14l14 14l-14 14" fill="none" stroke="#888" data-v-99661caa></path><circle cx="16" cy="16" r="15" stroke="#888" fill="none" data-v-99661caa></circle><text x="16" y="26" font-size="30" text-anchor="middle" stroke="var(--mainBgColor)" fill="var(--mainTextColor)" paint-order="stroke" data-v-99661caa>4</text><text x="48" y="26" font-size="30" text-anchor="middle" stroke="var(--mainBgColor)" fill="var(--mainTextColor)" paint-order="stroke" data-v-99661caa>0</text><text x="80" y="26" font-size="30" text-anchor="middle" stroke="var(--mainBgColor)" fill="var(--mainTextColor)" paint-order="stroke" data-v-99661caa>4</text>',
                  5
                ),
              ])
          )),
          n[1] ||
            (n[1] = h("p", null, "Sorry, that page does not exist. 😕", -1)),
          n[2] ||
            (n[2] = h("p", null, [h("a", { href: "/" }, "Go to app")], -1)),
        ])
      );
    },
  }),
  h7 = B(f7, [["__scopeId", "data-v-99661caa"]]),
  m7 = S({
    __name: "AppShell",
    setup(t) {
      const n = b(() => Sr.value === "app");
      return (s, o) => (
        d(),
        C(
          Z,
          null,
          [
            n.value
              ? (d(), w(U$, { key: 0 }))
              : y(Sr) === "404"
              ? (d(), w(h7, { key: 1 }))
              : z("", !0),
            y(!1) && n.value ? (d(), w(K$, { key: 2 })) : z("", !0),
            n.value ? (d(), w(c7, { key: 3 })) : z("", !0),
            c(e7),
            c(l7),
            c(W$),
            c(q$),
          ],
          64
        )
      );
    },
  });
async function g7() {
  if (document.location.pathname !== "/") {
    Sr.value = "404";
    return;
  }
  const t = ln.createDefault(jo(), "", ee.defaultAuthorName);
  t.allConstraints.push(ks({ type: _.Givens, spec: t.spec })),
    t.allConstraints.push(ks({ type: _.Regions, spec: t.spec })),
    await ri(t);
  const e = new Os(),
    n = document.location.toString();
  if (e.urlContainsProject(n))
    try {
      const s = e.loadFromUrl(n);
      await ri(s);
    } catch (s) {
      s instanceof ii && s.cause === li.FutureVersion
        ? await Rs(
            "The puzzle you are trying to open is created with a newer version of Sudoku Maker. Please update Sudoku Maker first, then try again."
          )
        : s instanceof ii && s.cause === li.UnsupportedVersion
        ? await Rs("The puzzle you are trying to open is not supported.")
        : await Rs(
            "The puzzle you are trying to open is corrupted or not supported."
          );
    }
  Sr.value = "app";
}
function v7(t, e) {
  window[t] = e;
}
const y7 = S({
  components: { GeometrySizeInput: hn },
  props: { thickness: { type: Number, required: !0 } },
  emits: { input: (t, e) => !0 },
  methods: {
    updateThickness(t, e) {
      this.$emit("input", t, e);
    },
  },
});
function C7(t, e, n, s, o, r) {
  const l = H("GeometrySizeInput");
  return (
    d(),
    w(
      l,
      {
        class: "LineThicknessInput",
        label: "Line thickness",
        max: 0.5,
        value: t.thickness,
        onInput: t.updateThickness,
      },
      null,
      8,
      ["value", "onInput"]
    )
  );
}
const pl = B(y7, [["render", C7]]),
  w7 = S({
    __name: "ArrowStyleControls",
    props: { value: {} },
    emits: ["update:value"],
    setup(t, { emit: e }) {
      const n = t,
        s = e;
      function o(r, l) {
        s("update:value", bn(ue(n.value), r), l);
      }
      return (r, l) => (
        d(),
        w(
          be,
          { vertical: "", gap: "" },
          {
            default: f(() => [
              l[3] || (l[3] = h("h3", null, "Arrow style", -1)),
              c(
                Cn,
                {
                  color: r.value.color,
                  label: "Color",
                  onInput: l[0] || (l[0] = (i, a) => o({ color: i }, a)),
                },
                null,
                8,
                ["color"]
              ),
              c(
                pl,
                {
                  thickness: r.value.thickness,
                  label: "Thickness",
                  onInput: l[1] || (l[1] = (i, a) => o({ thickness: i }, a)),
                },
                null,
                8,
                ["thickness"]
              ),
              c(
                Fr,
                {
                  radius: r.value.headSize,
                  label: "Head size",
                  onInput: l[2] || (l[2] = (i, a) => o({ headSize: i }, a)),
                },
                null,
                8,
                ["radius"]
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  ef = S({
    __name: "BasicShapeStyleControls",
    props: { label: {}, value: {} },
    emits: ["update:value"],
    setup(t, { emit: e }) {
      const n = t,
        s = e;
      function o(r, l) {
        s("update:value", bn(ue(n.value), r), l);
      }
      return (r, l) => (
        d(),
        w(
          be,
          { vertical: "", gap: "" },
          {
            default: f(() => [
              h("h3", null, X(r.label), 1),
              c(
                hn,
                {
                  value: r.value.size,
                  label: "Size",
                  onInput: l[0] || (l[0] = (i, a) => o({ size: i }, a)),
                },
                null,
                8,
                ["value"]
              ),
              c(dl, null, {
                default: f(() => [
                  c(
                    Cn,
                    {
                      color: r.value.fill,
                      label: "Fill color",
                      onInput: l[1] || (l[1] = (i, a) => o({ fill: i }, a)),
                    },
                    null,
                    8,
                    ["color"]
                  ),
                  c(
                    Cn,
                    {
                      color: r.value.stroke.color,
                      label: "Stroke color",
                      onInput:
                        l[2] ||
                        (l[2] = (i, a) =>
                          o(
                            {
                              stroke: {
                                color: i,
                                thickness: r.value.stroke.thickness,
                              },
                            },
                            a
                          )),
                    },
                    null,
                    8,
                    ["color"]
                  ),
                ]),
                _: 1,
              }),
              c(
                pl,
                {
                  thickness: r.value.stroke.thickness,
                  label: "Stroke thickness",
                  onInput:
                    l[3] ||
                    (l[3] = (i, a) =>
                      o(
                        {
                          stroke: { thickness: i, color: r.value.stroke.color },
                        },
                        a
                      )),
                },
                null,
                8,
                ["thickness"]
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  });
class b7 {
  constructor(e) {
    L(this, "selection", new Set());
    L(this, "entities", new Map());
    L(this, "idsPerCell", new Map());
    this.helpers = e;
    const { width: n, height: s } = e.cellIds.spec.size;
    for (let o = 0; o < s; o++)
      for (let r = 0; r < n; r++)
        this.idsPerCell.set(e.cellIds.getIdFromCoords({ x: r, y: o }), []);
  }
  getEntityIdsPerCell(e) {
    return this.idsPerCell.get(e);
  }
  getEntitiesPerCell(e, n) {
    return this.getEntityIdsPerCell(e)
      .map((s) => this.entities.get(s))
      .filter((s) => s.type === n);
  }
  deleteEntity(e) {
    const n = this.entities.get(e);
    for (const s of n.cells) _t(this.getEntityIdsPerCell(s), [e]);
    this.entities.delete(e), this.selection.delete(e);
  }
  select(e) {
    this.selection.clear(), this.selection.add(e);
  }
  selectAll() {
    this.selection = new Set([...this.entities.keys()]);
  }
  addEntity(e) {
    this.entities.set(e.id, e);
    for (const n of e.cells) this.getEntityIdsPerCell(n).push(e.id);
  }
  updateEntityCells(e, n) {
    const s = this.entities.get(e);
    if (s) {
      for (const o of s.cells) _t(this.getEntityIdsPerCell(o), [e]);
      s.cells = [...n];
      for (const o of s.cells) this.getEntityIdsPerCell(o).push(e);
    }
  }
}
class k7 extends b7 {
  constructor() {
    super(...arguments);
    L(this, "bulbs", new Map());
    L(this, "arrows", new Map());
  }
  setFromConstraint(n) {
    for (const s of [...this.entities.keys()]) this.deleteEntity(s);
    for (const s of n) {
      const o = this.createBulb(s.bulbCells);
      for (const r of s.arrows) this.createArrow(o, r);
    }
  }
  equalsConstraint(n) {
    if (this.bulbs.size !== n.length) return !1;
    const s = new uo(n.map((i) => i.bulbCells)),
      o = new uo([...this.bulbs.values()].map((i) => [...i.cells]));
    for (let i = 0; i < s.length; i++) if (!o.includes(s[i])) return !1;
    const r = new uo(
        ...n
          .map((i) => i.arrows)
          .flat(1)
          .filter((i) => i.length > 1)
      ),
      l = new uo(
        ...[...this.arrows.values()]
          .filter((i) => i.cells.length > 1)
          .map((i) => [...i.cells])
      );
    if (r.length !== l.length) return !1;
    for (let i = 0; i < r.length; i++) if (!l.includes(r[i])) return !1;
    return !0;
  }
  getSelectionConfig() {
    const n = [];
    for (const s of this.bulbs.values())
      if (this.selection.has(s.id))
        n.push({
          bulbCells: [...s.cells],
          arrows: s.arrowIds
            .map((o) => this.arrows.get(o))
            .filter((o) => o.cells.length > 1)
            .map((o) => [...o.cells]),
        });
      else {
        const o = s.arrowIds
          .filter((r) => this.selection.has(r))
          .map((r) => this.arrows.get(r));
        o.length > 0 &&
          n.push({
            bulbCells: [...s.cells],
            arrows: o
              .filter((r) => r.cells.length > 1)
              .map((r) => [...r.cells]),
          });
      }
    return n;
  }
  getNewConstraintConfig() {
    const n = [];
    for (const s of this.bulbs.values()) {
      const o = s.arrowIds
          .map((l) => this.arrows.get(l))
          .filter((l) => l.cells.length > 1),
        r = { bulbCells: [...s.cells], arrows: o.map((l) => [...l.cells]) };
      n.push(r);
    }
    return n;
  }
  getArrowsPerCell(n) {
    return this.getEntitiesPerCell(n, "arrow");
  }
  getBulbAndArrowsAt(n) {
    const s = this.getEntitiesPerCell(n, "bulb").at(0);
    if (!s) return { bulb: void 0, arrows: new Set() };
    const o = new Set();
    for (const r of s.arrowIds) o.add(this.arrows.get(r));
    return { bulb: s, arrows: o };
  }
  createBulb(n) {
    const s = { id: fe(), type: "bulb", cells: n.slice(), arrowIds: [] };
    return this.bulbs.set(s.id, s), this.addEntity(s), s.id;
  }
  createArrow(n, s) {
    const o = { id: fe(), type: "arrow", cells: s.slice(), bulbId: n };
    return (
      this.arrows.set(o.id, o),
      this.bulbs.get(n).arrowIds.push(o.id),
      this.addEntity(o),
      o.id
    );
  }
  addToBulb(n, s) {
    const o = this.bulbs.get(n);
    o.cells.push(s),
      o.cells.sort((r, l) => r - l),
      this.getEntityIdsPerCell(s).push(n);
    for (const r of o.arrowIds) {
      const l = this.entities.get(r);
      let i = l.cells;
      for (let a = 0; a < l.cells.length - 1; a++)
        if (o.cells.includes(i[a]) && !o.cells.includes(i[a + 1])) {
          i = l.cells.slice(a);
          break;
        }
      this.updateArrow(l.id, i);
    }
  }
  removeFromBulb(n, s) {
    const o = this.bulbs.get(n),
      r = o.cells[0],
      l = o.cells.at(-1);
    if (r === s) {
      Pn(this.getEntityIdsPerCell(s), n), o.cells.shift();
      for (const i of o.arrowIds) {
        const a = this.arrows.get(i);
        a.cells[0] === s && this.updateArrow(i, [o.cells[0], ...a.cells]);
      }
    } else if (l === s) {
      Pn(this.getEntityIdsPerCell(s), n), o.cells.pop();
      for (const i of o.arrowIds) {
        const a = this.arrows.get(i);
        a.cells[0] === s &&
          this.updateArrow(a.id, [o.cells.at(-1), ...a.cells]);
      }
    }
    for (const i of [...o.arrowIds])
      this.arrows.get(i).cells.length === 1 && this.deleteEntity(i);
  }
  updateArrow(n, s) {
    this.updateEntityCells(n, s);
  }
  deleteEntity(n) {
    if (this.arrows.has(n)) {
      const s = this.arrows.get(n),
        o = this.bulbs.get(s.bulbId);
      Pn(o.arrowIds, n),
        this.arrows.delete(n),
        super.deleteEntity(n),
        o.arrowIds.length === 0 && this.deleteEntity(o.id);
    } else if (this.bulbs.has(n)) {
      const s = this.bulbs.get(n);
      for (const o of s.arrowIds) this.arrows.delete(o), super.deleteEntity(o);
      this.bulbs.delete(n), super.deleteEntity(n);
    }
  }
  isValidArrowPosition(n, s) {
    const o = this.arrows.get(n);
    if (
      !o ||
      !this.helpers.geometry.getCellsAreKingsMoveApart(o.cells.at(-1), s)
    )
      return !1;
    const r = this.getEntitiesPerCell(s, "bulb").at(0);
    return (r == null ? void 0 : r.id) !== o.bulbId || r.cells.at(-1) !== s;
  }
}
class us {
  constructor() {
    L(this, "action", "");
  }
  end() {}
}
class _7 extends us {
  constructor(n) {
    super();
    L(this, "movingHead", !1);
    L(this, "initialClickPosition");
    L(this, "moved", !1);
    this.state = n;
  }
  start(n) {
    if (n.cellId === void 0) return !1;
    const s = this.state.getEntitiesPerCell(n.cellId, "bulb"),
      o = this.state
        .getEntitiesPerCell(n.cellId, "arrow")
        .filter((r) => r.cells.slice(1).includes(n.cellId));
    for (const r of o)
      if (this.state.selection.has(r.id))
        return this.handleSelectArrow(r, n.cellId), !0;
    return o.length > 0
      ? (this.handleSelectArrow(o[0], n.cellId), !0)
      : s.length > 0
      ? (this.handleCreateArrow(n.cellId), !0)
      : (this.handleCreateBulb(n.cellId), !0);
  }
  update(n) {
    if (n.outside || !this.movingHead || !al(n)) return;
    const s = this.getSelectedArrow();
    !s ||
      s.cells.length === 0 ||
      (s.cells.at(-2) === n.cellId
        ? (this.state.updateArrow(s.id, s.cells.slice(0, s.cells.length - 1)),
          (this.moved = !0))
        : this.state.isValidArrowPosition(s.id, n.cellId) &&
          (this.state.updateArrow(s.id, [...s.cells, n.cellId]),
          (this.moved = !0)),
      this.moved && s && (this.state.selection = new Set([s.id])));
  }
  end() {
    if (!this.moved && this.initialClickPosition !== void 0) {
      const s = this.state.getArrowsPerCell(this.initialClickPosition);
      for (let o = 0; o < s.length; o++) {
        const r = s[o];
        if (this.state.selection.has(r.id)) {
          const l = (o + 1) % s.length;
          this.state.select(s[l].id);
          return;
        }
      }
    }
    if (!this.movingHead) return;
    const n = this.getSelectedArrow();
    n && n.cells.length === 1 && this.state.deleteEntity(n.id);
  }
  getSelectedArrow() {
    return this.state.entities.get(
      [...this.state.selection].filter((n) => this.state.arrows.has(n))[0]
    );
  }
  handleSelectArrow(n, s) {
    this.state.selection.has(n.id) && (this.initialClickPosition = s),
      this.state.select(n.id),
      (this.movingHead = n.cells.at(-1) === s);
  }
  handleCreateArrow(n) {
    const { bulb: s } = this.state.getBulbAndArrowsAt(n);
    if (!s) {
      this.handleCreateBulb(n);
      return;
    }
    const o = this.state.createArrow(s.id, [n]);
    (this.state.selection = new Set([s.id, o])), (this.movingHead = !0);
  }
  handleCreateBulb(n) {
    const s = this.state.createBulb([n]),
      o = this.state.createArrow(s, [n]);
    (this.state.selection = new Set([s, o])), (this.movingHead = !0);
  }
}
class $7 extends us {
  constructor(n) {
    super();
    L(this, "previousPosition");
    this.state = n;
  }
  start(n) {
    if (n.outside) return !1;
    this.previousPosition = n.cellId;
    const s = this.state.getEntitiesPerCell(n.cellId, "bulb");
    for (const o of s)
      if (this.state.selection.has(o.id)) return this.handleUpdateBulb(o), !0;
    return s[0]
      ? (this.handleUpdateBulb(s[0]), !0)
      : (this.state.selection.clear(), !0);
  }
  handleUpdateBulb(n) {
    if (
      this.previousPosition !== n.cells[0] &&
      this.previousPosition !== n.cells.at(-1)
    ) {
      this.state.selection.clear();
      return;
    }
    this.state.select(n.id);
  }
  getSelectedBulb() {
    return this.state.entities.get([...this.state.selection][0]);
  }
  update(n) {
    if (n.cellId === void 0 || n.cellId === this.previousPosition) return;
    const s = this.getSelectedBulb();
    if (s) {
      if (this.tryReduceBulb(s, n.cellId)) {
        this.previousPosition = n.cellId;
        return;
      }
      s.cells.length >= this.getMaxBulbLength() ||
        (al(n) &&
          (s.cells.includes(n.cellId) ||
            (this.isValidBulbPosition(s, n.cellId) &&
              (this.state.addToBulb(s.id, n.cellId),
              (this.previousPosition = n.cellId)))));
    }
  }
  tryReduceBulb(n, s) {
    const o = this.previousPosition;
    return n.cells.length === 1 || !n.cells.includes(o) || !n.cells.includes(s)
      ? !1
      : o === n.cells[0] && s === n.cells[1]
      ? (this.state.removeFromBulb(n.id, n.cells[0]), !0)
      : o === n.cells.at(-1) && s === n.cells.at(-2)
      ? (this.state.removeFromBulb(n.id, n.cells.at(-1)), !0)
      : !1;
  }
  isValidBulbPosition(n, s) {
    if (this.state.getEntitiesPerCell(s, "bulb").length > 0) return !1;
    const r = [...n.cells, s].sort((i, a) => i - a),
      { helpers: l } = this.state;
    for (let i = 0; i < r.length - 1; i++) {
      const a = Ze(
        l.cellIds.getCoordsFromId(r[i + 1]),
        l.cellIds.getCoordsFromId(r[i])
      );
      if (Math.abs(a.x) > 1 || Math.abs(a.y) > 1) return !1;
    }
    return !0;
  }
  getMaxBulbLength() {
    return this.state.helpers.geometry.spec.type === Ie.Custom
      ? 1e3
      : this.state.helpers.geometry.spec.maxDigit > 6
      ? 3
      : 2;
  }
}
class tf extends us {
  constructor(n, s) {
    super();
    L(this, "getId");
    L(this, "isDeleting", !1);
    (this.state = n), (this.getId = s);
  }
  start(n) {
    const s = n.cellId && this.getId(n.cellId);
    return s
      ? (this.state.selection.has(s)
          ? (this.state.selection.delete(s), (this.isDeleting = !0))
          : this.state.selection.add(s),
        !0)
      : !1;
  }
  update(n) {
    const s = n.cellId && this.getId(n.cellId);
    s &&
      (this.isDeleting
        ? this.state.selection.delete(s)
        : this.state.selection.add(s));
  }
}
class S7 extends tf {
  constructor(e) {
    super(e, (n) => this.state.getEntityIdsPerCell(n)[0]);
  }
}
class I7 extends us {
  constructor(e) {
    super(), (this.state = e);
  }
  start(e) {
    return this.update(e), this.state.selection.clear(), !0;
  }
  update(e) {
    if (e.cellId !== void 0)
      for (const n of this.state.getEntityIdsPerCell(e.cellId))
        this.state.deleteEntity(n);
  }
}
function Vn(t) {
  const { onDelete: e, onSelectAll: n, onInput: s } = t;
  e && ot("delete", e),
    n && ot("selectAll", n),
    s && ot("input", s),
    x7(t),
    D7(t);
}
function x7(t) {
  let e;
  const {
    onPointerAction: n,
    onPointerDown: s,
    onPointerUp: o,
    onPointerMove: r,
    onHover: l,
    onHoverEnd: i,
    onDragStart: a,
    onDragMove: u,
    onDragEnd: p,
  } = t;
  Pt(nt, "pointerDown", (m) => {
    m.pointerType === "mouse" &&
      (s == null || s(m),
      n == null || n(m),
      i == null || i(m),
      a == null || a(m),
      (e = m));
  }),
    Pt(nt, "pointerMove", (m) => {
      m.pointerType === "mouse" &&
        (r == null || r(m), e ? u == null || u(m) : l == null || l(m));
    }),
    Pt(nt, "pointerUp", (m) => {
      m.pointerType === "mouse" &&
        (o == null || o(m), e && (p == null || p(m)), (e = void 0));
    });
}
function D7(t) {
  let e = "idle",
    n;
  const {
    touchMoveIsHover: s,
    onPointerAction: o,
    onPointerDown: r,
    onPointerUp: l,
    onPointerMove: i,
    onHover: a,
    onHoverEnd: u,
    onDragStart: p,
    onDragMove: m,
    onDragEnd: g,
  } = t;
  Pt(nt, "pointerCancel", () => {
    e = "idle";
  }),
    Pt(nt, "pointerDown", (v) => {
      v.pointerType === "touch" &&
        ((e = "touched"), (n = v), s && (a == null || a(v)));
    }),
    Pt(nt, "pointerMove", (v) => {
      v.pointerType !== "touch" ||
        !n ||
        (e === "touched" &&
        Di.getDistance(
          { x: v.originalEvent.clientX, y: v.originalEvent.clientY },
          { x: n.originalEvent.clientX, y: n.originalEvent.clientY }
        ) > 5
          ? (r == null || r(n),
            i == null || i(v),
            (e = "dragging"),
            s ? a == null || a(v) : (p == null || p(n), m == null || m(v)))
          : e === "dragging" &&
            (i == null || i(v), s ? a == null || a(v) : m == null || m(v)));
    }),
    Pt(nt, "pointerUp", (v) => {
      v.pointerType === "touch" &&
        (s
          ? o == null || o(v)
          : (u == null || u(v),
            e === "touched" && (p == null || p(n)),
            g == null || g(v)),
        l == null || l(v),
        (e = "idle"),
        (n = void 0));
    });
}
const Jo = S({
    emits: {
      input: (t) => !0,
      delete: () => !0,
      "pointer-down": (t) => !0,
      "pointer-move": (t) => !0,
      "pointer-up": (t) => !0,
      "pointer-action": (t) => !0,
      hover: (t) => !0,
      "hover-end": (t) => !0,
      "drag-start": (t) => !0,
      "drag-move": (t) => !0,
      "drag-end": (t) => !0,
      "select-all": () => !0,
    },
    setup(t, { emit: e }) {
      Vn({
        onDelete: () => e("delete"),
        onSelectAll: () => e("select-all"),
        onInput: (n) => e("input", n.string),
        onPointerDown: (n) => e("pointer-down", n),
        onPointerUp: (n) => e("pointer-up", n),
        onPointerAction: (n) => e("pointer-action", n),
        onPointerMove: (n) => e("pointer-move", n),
        onHover: (n) => e("hover", n),
        onHoverEnd: (n) => e("hover-end", n),
        onDragStart: (n) => e("drag-start", n),
        onDragMove: (n) => e("drag-move", n),
        onDragEnd: (n) => e("drag-end", n),
      });
    },
    render() {
      return null;
    },
  }),
  jn = S({
    props: {
      mode: { type: Object, default: () => ({}) },
      currentValue: { type: String, default: void 0 },
    },
    emits: { update: (t) => !0 },
    setup(t, { emit: e }) {
      const n = fe();
      return (
        ae(
          () => t.currentValue,
          (s) => {
            ye.setCurrentValue(s || "");
          },
          { immediate: !0 }
        ),
        ae(
          () => t.mode,
          (s) => {
            ye.setInputMode(s, n);
          },
          { immediate: !0 }
        ),
        ot("input", (s) => {
          e("update", s.string);
        }),
        () => null
      );
    },
  }),
  ct = S({
    __name: "EditorRendererWrapper",
    props: { layer: { type: String, default: oe.Default } },
    setup(t) {
      const e = t,
        { project: n } = ke(),
        s = b(() => new Ld(n.value.spec));
      gi(et, s);
      const o = j(!1);
      Xt(() => {
        wn(() => {
          o.value = !0;
        });
      });
      const r = b(() => `.editorContainer-${e.layer}`);
      return (l, i) =>
        o.value
          ? (d(),
            w(sc, { key: 0, to: r.value }, [G(l.$slots, "default")], 8, ["to"]))
          : z("", !0);
    },
  }),
  M7 = S({
    props: {
      points: { type: Array, required: !0 },
      startArrow: { type: Boolean, default: !1 },
      endArrow: { type: Boolean, default: !1 },
      color: { type: String, default: "#000000" },
      lineWidth: { type: Number, default: 0.05 },
      size: { type: Number, default: 0.5 },
    },
    computed: {
      rgba() {
        return Gt(this.color);
      },
      albedo() {
        return Us(this.rgba);
      },
      opacity() {
        return this.rgba.alpha;
      },
      from() {
        return this.points[0];
      },
      to() {
        return this.points[this.points.length - 1];
      },
      fromDirection() {
        return bo(Ze(this.points[1], this.points[0]));
      },
      toDirection() {
        return bo(
          Ze(
            this.points[this.points.length - 1],
            this.points[this.points.length - 2]
          )
        );
      },
      actualFrom() {
        return this.startArrow
          ? Qn(this.from, this.fromDirection, Math.SQRT1_2 * this.lineWidth)
          : this.from;
      },
      actualTo() {
        return this.endArrow
          ? Qn(this.to, this.toDirection, -Math.SQRT1_2 * this.lineWidth)
          : this.to;
      },
      linePath() {
        const t = [];
        t.push(`M${this.actualFrom.x} ${this.actualFrom.y}`);
        for (let e = 1; e < this.points.length - 1; e++)
          t.push(`L${this.points[e].x} ${this.points[e].y}`);
        return t.push(`L${this.actualTo.x} ${this.actualTo.y}`), t.join("");
      },
      headPath() {
        const t = [];
        if (this.endArrow) {
          const e = Ll(this.toDirection, this.size),
            n = en(e, -1.25 * Math.PI),
            s = en(e, 1.25 * Math.PI);
          t.push(`M${this.actualTo.x + n.x} ${this.actualTo.y + n.y}`),
            t.push(`L${this.actualTo.x} ${this.actualTo.y}`),
            t.push(`L${this.actualTo.x + s.x} ${this.actualTo.y + s.y}`);
        }
        if (this.startArrow) {
          const e = Ll(this.fromDirection, this.size),
            n = en(e, -1.25 * Math.PI),
            s = en(e, 1.25 * Math.PI);
          t.push(`M${this.actualFrom.x - n.x} ${this.actualFrom.y - n.y}`),
            t.push(`L${this.actualFrom.x} ${this.actualFrom.y}`),
            t.push(`L${this.actualFrom.x - s.x} ${this.actualFrom.y - s.y}`);
        }
        return t.join("");
      },
    },
  }),
  A7 = ["stroke-width", "stroke", "opacity"],
  P7 = ["d"],
  L7 = ["d"];
function E7(t, e, n, s, o, r) {
  return (
    d(),
    C(
      "g",
      {
        class: "ArrowShape",
        "stroke-width": t.lineWidth,
        stroke: t.albedo,
        opacity: t.opacity,
        fill: "none",
      },
      [
        h("path", { d: t.linePath, "stroke-linejoin": "round" }, null, 8, P7),
        t.headPath
          ? (d(),
            C(
              "path",
              { key: 0, d: t.headPath, "stroke-dasharray": "none" },
              null,
              8,
              L7
            ))
          : z("", !0),
      ],
      8,
      A7
    )
  );
}
const Qo = B(M7, [["render", E7]]);
function F7({ segments: t }, e) {
  const n = [];
  let s = [];
  for (let r = 0; r < t.length; r++)
    t[r].type === Rd.Move && (s.length > 0 && n.push(s), (s = [])),
      s.push(t[r].point);
  s.length > 0 && n.push(s);
  let o = "";
  for (const r of n) o += B7(r, e / 2);
  return o;
}
function B7(t, e) {
  const n = [];
  for (let l = 0; l < t.length - 1; l++) {
    const i = mt.from(Ze(t[l + 1], t[l]));
    i.magnitudeSqr < 1e-5 ? ((i.x = 1), (i.y = 0)) : i.normalize(),
      n.push({ x: i.y * e, y: -i.x * e });
  }
  const s = [],
    o = [];
  for (let l = 0; l < t.length; l++) {
    const i = n[l - 1],
      a = n[l];
    if (l === 0) s.push([ft(t[l], a)]), o.push([Ze(t[l], a)]);
    else if (l === t.length - 1) s.push([ft(t[l], i)]), o.push([Ze(t[l], i)]);
    else if (-i.x * a.y + i.y * a.x < 0) {
      s.push([ft(t[l], i), ft(t[l], a)]);
      const u = 1 / (Math.cos(kr(i, a)) + 1),
        p = Qn(t[l], ft(i, a), -u);
      o.push([p]);
    } else {
      const u = 1 / (Math.cos(kr(i, a)) + 1),
        p = Qn(t[l], ft(i, a), u);
      s.push([p]), o.push([Ze(t[l], a), Ze(t[l], i)]);
    }
  }
  let r = "";
  for (let l = 0; l < t.length - 1; l++)
    l === 0
      ? ((r += `M${o[0][0].x} ${o[0][0].y}`),
        (r += `A${e} ${e}, 0, 0, 1, ${s[0][0].x} ${s[0][0].y}`))
      : s[l].length > 1 &&
        (r += `A${e} ${e}, 0, 0, 1, ${s[l][1].x} ${s[l][1].y}`),
      (r += `L${s[l + 1][0].x} ${s[l + 1][0].y}`);
  for (let l = t.length - 1; l > 0; l--)
    l === t.length - 1
      ? (r += `A${e} ${e}, 0, 0, 1, ${o[l][0].x} ${o[l][0].y}`)
      : o[l].length > 1 &&
        (r += `A${e} ${e}, 0, 0, 1, ${o[l][1].x} ${o[l][1].y}`),
      (r += `L${o[l - 1][0].x} ${o[l - 1][0].y}`);
  return (r += "z"), r;
}
const z7 = ["d", "stroke", "fill", "stroke-width"],
  nf = S({
    __name: "BulbWithArrows",
    props: {
      bulbCells: {},
      arrows: {},
      bulbStyle: {},
      arrowStyle: {},
      tipOffset: {},
    },
    setup(t) {
      const e = t,
        { helpers: n } = Qe(et).value,
        s = b(() => {
          const r = new Od(),
            l =
              e.bulbCells.length === 1
                ? [e.bulbCells[0], e.bulbCells[0]]
                : e.bulbCells;
          for (let i = 0; i < l.length; i++)
            i === 0
              ? r.moveTo(n.cellIds.getCellCenterFromId(l[i]))
              : r.lineTo(n.cellIds.getCellCenterFromId(l[i]));
          return F7(r, e.bulbStyle.size);
        }),
        o = b(() =>
          e.arrows.map((r) => {
            const l = jd + (e.tipOffset || 0);
            return Z3(
              r,
              e.bulbStyle.size / 2,
              e.bulbStyle.stroke.thickness,
              n,
              l
            );
          })
        );
      return (r, l) => (
        d(),
        C("g", null, [
          h(
            "path",
            {
              d: s.value,
              stroke: r.bulbStyle.stroke.color,
              fill: r.bulbStyle.fill,
              "stroke-width": r.bulbStyle.stroke.thickness,
            },
            null,
            8,
            z7
          ),
          (d(!0),
          C(
            Z,
            null,
            se(
              o.value,
              (i, a) => (
                d(),
                w(
                  Qo,
                  {
                    key: a,
                    points: i,
                    "end-arrow": "",
                    size: r.arrowStyle.headSize,
                    color: r.arrowStyle.color,
                    "line-width": r.arrowStyle.thickness,
                  },
                  null,
                  8,
                  ["points", "size", "color", "line-width"]
                )
              )
            ),
            128
          )),
        ])
      );
    },
  }),
  sf = S({
    __name: "ArrowsWithBulbsRenderer",
    props: { bulbsWithArrows: {}, style: {} },
    setup(t) {
      return (e, n) => (
        d(!0),
        C(
          Z,
          null,
          se(
            e.bulbsWithArrows,
            (s, o) => (
              d(),
              w(
                nf,
                {
                  key: o,
                  "bulb-cells": s.bulbCells,
                  arrows: s.arrows,
                  "bulb-style": e.style.bulb,
                  "arrow-style": e.style.arrow,
                },
                null,
                8,
                ["bulb-cells", "arrows", "bulb-style", "arrow-style"]
              )
            )
          ),
          128
        )
      );
    },
  }),
  R7 = S({
    components: {
      InputListener: jn,
      BasicShapeStyleControls: ef,
      ArrowStyleControls: w7,
      EditorEvents: Jo,
      EditorFormBase: yt,
      BulbWithArrowsVue: nf,
      ArrowsWithBulbsRenderer: sf,
      EditorRendererWrapper: ct,
      FormButton: te,
    },
    props: {
      context: { type: Object, required: !0 },
      bulbsWithArrows: { type: Array, required: !0 },
      style: { type: Object, required: !0 },
    },
    data() {
      return {
        action: "editArrows",
        actionId: fe(),
        brush: null,
        state: new k7(this.context.helpers),
      };
    },
    computed: {
      selectionOutlineSize() {
        return on.value;
      },
      selectionColor() {
        return ee.selectionColor;
      },
      hasBulbs() {
        return this.bulbsWithArrows.length > 0;
      },
      selectedBulbsWithArrows() {
        return this.state.getSelectionConfig();
      },
      inputMode() {
        return { deleteButton: this.selectedBulbsWithArrows.length > 0 };
      },
    },
    watch: {
      bulbsWithArrows: {
        immediate: !0,
        handler(t) {
          this.state.equalsConstraint(t) ||
            ((this.brush = null),
            this.clearSelection(),
            this.state.setFromConstraint(t));
        },
      },
      hasBulbs(t) {
        t || (this.action = "editArrows");
      },
    },
    methods: {
      clearSelection() {
        this.state.selection = new Set();
      },
      onArrowStyleUpdate(t, e) {
        this.context.updateConstraintAppearance(
          { arrow: t },
          "update:arrowStyle",
          e
        );
      },
      onBulbStyleUpdate(t, e) {
        this.context.updateConstraintAppearance(
          { bulb: t },
          "update:bulbStyle",
          e
        );
      },
      onPointerDown(t) {
        if (t.cellId !== void 0) {
          if (ye.isSelecting()) {
            (this.brush = new S7(this.state)),
              this.brush.start(t) || (this.brush = null);
            return;
          }
          switch (((this.actionId = fe()), this.action)) {
            case "editBulbs":
              if (!this.hasBulbs) return;
              (this.brush = new $7(this.state)),
                this.brush.start(t) || (this.brush = null);
              break;
            case "editArrows":
              (this.brush = new _7(this.state)),
                this.brush.start(t) || (this.brush = null);
              break;
            case "delete":
              if (!this.hasBulbs) return;
              (this.brush = new I7(this.state)),
                this.brush.start(t) || (this.brush = null);
              break;
          }
          this.update();
        }
      },
      onPointerMove(t) {
        this.brush && (this.brush.update(t), this.update());
      },
      onPointerUp() {
        var t;
        (t = this.brush) == null || t.end(), this.update(), (this.brush = null);
      },
      update() {
        if (!this.brush || this.state.equalsConstraint(this.bulbsWithArrows))
          return;
        const t = this.state.getNewConstraintConfig();
        this.context.updateConstraint(
          { bulbsWithArrows: t },
          "update",
          this.actionId
        );
      },
      onDelete() {
        if (this.state.selection.size === 0) return;
        for (const e of this.state.selection) this.state.deleteEntity(e);
        if (this.state.equalsConstraint(this.bulbsWithArrows)) return;
        const t = this.state.getNewConstraintConfig();
        this.context.updateConstraint(
          { bulbsWithArrows: t },
          "delete",
          this.actionId
        );
      },
      onSelectAll() {
        this.state.selectAll();
      },
    },
  });
function O7(t, e, n, s, o, r) {
  const l = H("ArrowStyleControls"),
    i = H("BasicShapeStyleControls"),
    a = H("FormButton"),
    u = H("EditorFormBase"),
    p = H("BulbWithArrowsVue"),
    m = H("ArrowsWithBulbsRenderer"),
    g = H("EditorRendererWrapper"),
    v = H("InputListener"),
    $ = H("EditorEvents");
  return (
    d(),
    C(
      Z,
      null,
      [
        c(
          u,
          { class: "ArrowEditor", context: t.context },
          {
            properties: f(() => [G(t.$slots, "properties")]),
            appearance: f(() => [
              c(
                l,
                {
                  value: t.style.arrow,
                  "onUpdate:value": t.onArrowStyleUpdate,
                },
                null,
                8,
                ["value", "onUpdate:value"]
              ),
              c(
                i,
                {
                  label: "Bulb style",
                  value: t.style.bulb,
                  "onUpdate:value": t.onBulbStyleUpdate,
                },
                null,
                8,
                ["value", "onUpdate:value"]
              ),
              G(t.$slots, "appearance"),
            ]),
            buttons: f(() => [
              c(
                a,
                {
                  active: t.action === "editArrows",
                  toggleable: "",
                  onClick: e[0] || (e[0] = (k) => (t.action = "editArrows")),
                },
                {
                  default: f(() => e[3] || (e[3] = [F(" Edit arrows ")])),
                  _: 1,
                },
                8,
                ["active"]
              ),
              c(
                a,
                {
                  active: t.action === "editBulbs",
                  toggleable: "",
                  disabled: !t.hasBulbs,
                  onClick: e[1] || (e[1] = (k) => (t.action = "editBulbs")),
                },
                {
                  default: f(() => e[4] || (e[4] = [F(" Edit bulbs ")])),
                  _: 1,
                },
                8,
                ["active", "disabled"]
              ),
              c(
                a,
                {
                  active: t.action === "delete",
                  toggleable: "",
                  disabled: !t.hasBulbs,
                  onClick: e[2] || (e[2] = (k) => (t.action = "delete")),
                },
                { default: f(() => e[5] || (e[5] = [F(" Delete ")])), _: 1 },
                8,
                ["active", "disabled"]
              ),
            ]),
            _: 3,
          },
          8,
          ["context"]
        ),
        c(g, null, {
          default: f(() => [
            (d(!0),
            C(
              Z,
              null,
              se(
                t.selectedBulbsWithArrows,
                (k, M) => (
                  d(),
                  w(
                    p,
                    {
                      key: M,
                      "bulb-cells": k.bulbCells,
                      arrows: k.arrows,
                      "arrow-style": {
                        color: t.selectionColor,
                        thickness:
                          t.style.arrow.thickness + t.selectionOutlineSize * 2,
                        headSize:
                          t.style.arrow.headSize + t.selectionOutlineSize,
                      },
                      "bulb-style": {
                        size: t.style.bulb.size,
                        fill: t.style.bulb.fill,
                        stroke: {
                          color: t.selectionColor,
                          thickness:
                            t.style.bulb.stroke.thickness +
                            t.selectionOutlineSize * 2,
                        },
                      },
                      "tip-offset": -0.707107 * t.selectionOutlineSize * 2,
                    },
                    null,
                    8,
                    [
                      "bulb-cells",
                      "arrows",
                      "arrow-style",
                      "bulb-style",
                      "tip-offset",
                    ]
                  )
                )
              ),
              128
            )),
            c(
              m,
              { "bulbs-with-arrows": t.bulbsWithArrows, style: We(t.style) },
              null,
              8,
              ["bulbs-with-arrows", "style"]
            ),
          ]),
          _: 1,
        }),
        c(v, { mode: t.inputMode }, null, 8, ["mode"]),
        c(
          $,
          {
            onDragStart: t.onPointerDown,
            onDragMove: t.onPointerMove,
            onDragEnd: t.onPointerUp,
            onDelete: t.onDelete,
            onSelectAll: t.onSelectAll,
          },
          null,
          8,
          ["onDragStart", "onDragMove", "onDragEnd", "onDelete", "onSelectAll"]
        ),
      ],
      64
    )
  );
}
const N7 = B(R7, [["render", O7]]),
  T7 = {
    class: "ArrowPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  V7 = ["fill", "stroke"],
  j7 = ["stroke"],
  U7 = S({
    __name: "ArrowPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", T7, [
          h(
            "circle",
            {
              cx: "5",
              cy: "15",
              r: "4",
              fill: e.constraint.style.bulb.fill,
              stroke: e.constraint.style.bulb.stroke.color,
            },
            null,
            8,
            V7
          ),
          h(
            "path",
            {
              d: "M7.4 12.6L19 1M14 1h5v5",
              fill: "none",
              stroke: e.constraint.style.arrow.color,
            },
            null,
            8,
            j7
          ),
        ])
      );
    },
  });
_e({
  type: _.Arrow,
  label: "Arrows",
  preview: U7,
  renderers: (t) => [
    {
      layer: oe.Default,
      component: c(
        sf,
        { bulbsWithArrows: t.bulbsWithArrows, style: t.style },
        null
      ),
    },
  ],
  editor: xe({
    editor: { component: N7, props: (t) => sn(t, "bulbsWithArrows", "style") },
  }),
});
const da = S({
  __name: "LineStyleControls",
  props: { value: {} },
  emits: ["update:value"],
  setup(t, { emit: e }) {
    const n = t,
      s = e;
    function o(r, l) {
      s("update:value", bn(ue(n.value), r), l);
    }
    return (r, l) => (
      d(),
      w(
        be,
        { vertical: "", gap: "" },
        {
          default: f(() => [
            l[2] || (l[2] = h("h3", null, "Line style", -1)),
            c(
              Cn,
              {
                color: r.value.color,
                label: "Color",
                onInput: l[0] || (l[0] = (i, a) => o({ color: i }, a)),
              },
              null,
              8,
              ["color"]
            ),
            c(
              pl,
              {
                thickness: r.value.thickness,
                label: "Thickness",
                onInput: l[1] || (l[1] = (i, a) => o({ thickness: i }, a)),
              },
              null,
              8,
              ["thickness"]
            ),
          ]),
          _: 1,
        }
      )
    );
  },
});
function ju(t) {
  return ue(t.lines).filter((e) => e.length > 1);
}
function Uu(t, e) {
  for (let n = 0; n < t.length; n++) {
    if (t[n] < e[n]) return -1;
    if (t[n] > e[n]) return 1;
  }
  return 0;
}
function H7(t, e) {
  if (t.length !== e.length) return !1;
  const n = t.slice().sort(Uu),
    s = e.slice().sort(Uu);
  return Ce(n, s);
}
function lo(t, e) {
  return t.lines.filter((n) => n.includes(e));
}
function W7(t, e, n) {
  for (const s of t.lines)
    for (let o = 0; o < s.length - 1; o++)
      if ((s[o] === e && s[o + 1] === n) || (s[o] === n && s[o + 1] === e))
        return !0;
  return !1;
}
function Z7(t, e) {
  const n = e.slice(1, e.length - 1);
  for (const s of t.lines)
    if (n.includes(s[0]) || n.includes(s.at(-1))) return !0;
  for (let s = 0; s < e.length - 1; s++) if (W7(t, e[s], e[s + 1])) return !0;
  return !1;
}
class Br {
  constructor(e) {
    L(this, "items");
    e ? (this.items = [...new Set(e)]) : (this.items = []);
  }
  get size() {
    return this.items.length;
  }
  has(e) {
    return !!this.items.find((n) => Ce(e, n));
  }
  add(e) {
    this.has(e) || this.items.push(e);
  }
  delete(e) {
    const n = this.items.findIndex((s) => Ce(e, s));
    n > -1 && this.items.splice(n, 1);
  }
  clear() {
    this.items.length = 0;
  }
  [Symbol.iterator]() {
    return this.items[Symbol.iterator]();
  }
}
const G7 = ["d", "stroke", "stroke-width"],
  q7 = ["transform"],
  Fo = S({
    __name: "LineWithEndPointsRenderer",
    props: { lines: {}, style: {} },
    setup(t) {
      const e = t,
        { helpers: n } = Qe(et).value,
        s = b(() =>
          e.lines.map((u) => u.map((p) => n.cellIds.getCoordsFromId(p)))
        ),
        o = b(() => {
          const u = new Br(),
            p = new Br();
          for (const m of s.value)
            for (let g = 0; g < m.length; g++)
              i(m, g) && (u.has(m[g]) ? p.add(m[g]) : u.add(m[g]));
          return p;
        }),
        r = b(() => {
          let u = "";
          for (const p of s.value)
            for (let m = 0; m < p.length; m++)
              if (m === 0) {
                const g = p[m].x + 0.5,
                  v = p[m].y + 0.5;
                u += `M${g} ${v}`;
              } else u += a(p, m);
          return u;
        }),
        l = b(() => {
          const u = new Set();
          for (const p of e.lines) u.add(p[0]), u.add(p[p.length - 1]);
          return [...u].map((p) => n.cellIds.getCoordsFromId(p));
        });
      function i(u, p) {
        if (p === 0 || p === u.length - 1) return !1;
        const m = Math.abs(u[p - 1].x - u[p + 1].x),
          g = Math.abs(u[p - 1].y - u[p + 1].y);
        return m > 0 && g > 0;
      }
      function a(u, p) {
        if (o.value.has(u[p]) && i(u, p)) {
          const { x: m, y: g } = u[p - 1],
            { x: v, y: $ } = u[p],
            { x: k, y: M } = u[p + 1],
            P = ft(u[p], { x: 0.5, y: 0.5 }),
            x = P.x - Math.sign(v - m) * e.style.lines.thickness * 3,
            A = P.y - Math.sign($ - g) * e.style.lines.thickness * 3,
            O = P.x + Math.sign(k - v) * e.style.lines.thickness * 3,
            V = P.y + Math.sign(M - $) * e.style.lines.thickness * 3;
          return `L${x} ${A}Q${P.x} ${P.y},${O} ${V}`;
        } else {
          const m = u[p].x + 0.5,
            g = u[p].y + 0.5;
          return `L${m} ${g}`;
        }
      }
      return (u, p) => (
        d(),
        C(
          Z,
          null,
          [
            h(
              "path",
              {
                d: r.value,
                fill: "none",
                stroke: u.style.lines.color,
                "stroke-width": u.style.lines.thickness,
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
              },
              null,
              8,
              G7
            ),
            (d(!0),
            C(
              Z,
              null,
              se(
                l.value,
                (m, g) => (
                  d(),
                  C(
                    "g",
                    {
                      key: g,
                      transform: `translate(${m.x + 0.5} ${m.y + 0.5})`,
                    },
                    [G(u.$slots, "default")],
                    8,
                    q7
                  )
                )
              ),
              128
            )),
          ],
          64
        )
      );
    },
  }),
  pa = S({
    __name: "LineWithEndPointsEditor",
    props: { context: {}, lines: {}, style: {}, endPointStyleLabel: {} },
    setup(t) {
      const e = t,
        n = j(fe()),
        s = j("add"),
        o = j({ lines: [], selection: new Set() }),
        r = j(),
        l = j(!1),
        i = j(-1),
        a = b(() => o.value.lines.filter((I) => ho(o.value.selection, I)));
      ae(
        () => e.lines,
        (I) => {
          H7(
            I,
            o.value.lines.filter((U) => U.length > 1)
          ) || ((o.value.lines = ue(I)), u());
        },
        { deep: !0, immediate: !0 }
      );
      function u() {
        o.value.selection.clear();
      }
      function p(I, U) {
        e.context.updateConstraintAppearance(
          { lines: I },
          "update:lineStyle",
          U
        );
      }
      function m(I, U) {
        e.context.updateConstraintAppearance(
          { endPoints: I },
          "update:endPointsStyle",
          U
        );
      }
      function g(I) {
        if (I.cellId !== void 0) {
          if (((n.value = fe()), ye.isSelecting())) {
            A(I.cellId);
            return;
          }
          switch (s.value) {
            case "add": {
              V(I.cellId) || lo(o.value, I.cellId).length === 0
                ? ((r.value = [I.cellId]),
                  (l.value = !0),
                  o.value.lines.push(r.value),
                  (o.value.selection = new Set(r.value)),
                  (i.value = I.cellId))
                : (l.value = !1);
              break;
            }
            case "edit": {
              const U = lo(o.value, I.cellId);
              if (U.length === 0)
                (r.value = [I.cellId]),
                  (l.value = !0),
                  o.value.lines.push(r.value),
                  (o.value.selection = new Set(r.value)),
                  (i.value = I.cellId);
              else {
                const D = U[0];
                (r.value = D),
                  I.cellId === D[0]
                    ? ((l.value = !0), r.value.reverse())
                    : (l.value = I.cellId === D.at(-1)),
                  (o.value.selection = new Set([I.cellId])),
                  (i.value = I.cellId);
              }
              break;
            }
            case "delete":
              x(
                o.value.lines.filter((U) => U.includes(I.cellId)),
                n.value
              );
              break;
          }
        }
      }
      function v(I) {
        if (!I.pointerDown || I.cellId === void 0) return;
        if (s.value === "delete") {
          x(
            o.value.lines.filter((D) => D.includes(I.cellId)),
            n.value
          );
          return;
        }
        if (!l.value || I.cellId === i.value || !r.value || !al(I)) return;
        const U = lo(o.value, I.cellId);
        if (U.length === 0) {
          if (!O(r.value, I.cellId)) return;
          P(), (i.value = I.cellId);
        } else if (U.includes(r.value) && I.cellId === r.value.at(-2))
          r.value.pop(),
            (o.value.selection = new Set([I.cellId])),
            P(),
            (i.value = I.cellId);
        else
          for (const D of U)
            if (D !== r.value && (D[0] === I.cellId || D.at(-1) === I.cellId)) {
              O(r.value, I.cellId), P(), (r.value = void 0);
              return;
            }
      }
      function $() {
        r.value && r.value.length === 1 && _t(o.value.lines, [r.value]);
      }
      function k() {
        x(o.value.lines.filter((I) => ho(o.value.selection, I)));
      }
      function M() {
        o.value.selection = new Set(o.value.lines.flat());
      }
      function P() {
        e.context.updateConstraint({ lines: ju(o.value) }, "update", n.value);
      }
      function x(I, U) {
        (o.value.lines = o.value.lines.filter((D) => !I.includes(D))),
          u(),
          e.context.updateConstraint({ lines: ju(o.value) }, "delete", U);
      }
      function A(I) {
        let U = !1;
        const D = lo(o.value, I);
        for (const N of D)
          ho(o.value.selection, N) && ((U = !0), Ur(o.value.selection, N));
        U || o.value.selection.add(I);
      }
      function O(I, U) {
        const { helpers: D } = e.context,
          N = [
            ...ea(
              D.cellIds.getCoordsFromId(I.at(-1)),
              D.cellIds.getCoordsFromId(U)
            ),
          ].map((E) => D.cellIds.getIdFromCoords(E));
        if (Z7(o.value, N)) return !1;
        for (const E of N) I.includes(E) || I.push(E);
        return !0;
      }
      function V(I) {
        for (const U of lo(o.value, I))
          if (U[0] === I || U.at(-1) === I) return !0;
        return !1;
      }
      return (I, U) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              yt,
              { class: "BetweenLineEditor", context: I.context },
              {
                properties: f(() => [G(I.$slots, "properties")]),
                appearance: f(() => [
                  c(
                    da,
                    { value: I.style.lines, "onUpdate:value": p },
                    null,
                    8,
                    ["value"]
                  ),
                  c(
                    ef,
                    {
                      label: I.endPointStyleLabel,
                      value: I.style.endPoints,
                      "onUpdate:value": m,
                    },
                    null,
                    8,
                    ["label", "value"]
                  ),
                  G(I.$slots, "appearance"),
                ]),
                buttons: f(() => [
                  c(
                    te,
                    {
                      active: s.value === "add",
                      toggleable: "",
                      onClick: U[0] || (U[0] = (D) => (s.value = "add")),
                    },
                    { default: f(() => U[3] || (U[3] = [F(" Add ")])), _: 1 },
                    8,
                    ["active"]
                  ),
                  c(
                    te,
                    {
                      active: s.value === "edit",
                      toggleable: "",
                      disabled: o.value.lines.length === 0,
                      onClick: U[1] || (U[1] = (D) => (s.value = "edit")),
                    },
                    { default: f(() => U[4] || (U[4] = [F(" Edit ")])), _: 1 },
                    8,
                    ["active", "disabled"]
                  ),
                  c(
                    te,
                    {
                      active: s.value === "delete",
                      toggleable: "",
                      disabled: o.value.lines.length === 0,
                      onClick: U[2] || (U[2] = (D) => (s.value = "delete")),
                    },
                    {
                      default: f(() => U[5] || (U[5] = [F(" Delete ")])),
                      _: 1,
                    },
                    8,
                    ["active", "disabled"]
                  ),
                ]),
                _: 3,
              },
              8,
              ["context"]
            ),
            c(ct, null, {
              default: f(() => [
                c(
                  Fo,
                  {
                    lines: a.value,
                    style: We({
                      lines: {
                        thickness: I.style.lines.thickness + y(on) * 2,
                        color: y(ee).selectionColor,
                      },
                    }),
                  },
                  {
                    default: f(() => [
                      G(I.$slots, "selection", { selectionOutlineSize: y(on) }),
                    ]),
                    _: 3,
                  },
                  8,
                  ["lines", "style"]
                ),
                c(
                  Fo,
                  { lines: o.value.lines, style: We(I.style) },
                  { default: f(() => [G(I.$slots, "default")]), _: 3 },
                  8,
                  ["lines", "style"]
                ),
              ]),
              _: 3,
            }),
            c(y(jn), { mode: { deleteButton: a.value.length > 0 } }, null, 8, [
              "mode",
            ]),
            c(y(Jo), {
              onDragStart: g,
              onDragMove: v,
              onDragEnd: $,
              onDelete: k,
              onSelectAll: M,
            }),
          ],
          64
        )
      );
    },
  }),
  K7 = {
    class: "BetweenLinePreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  X7 = ["fill", "stroke"],
  Y7 = ["stroke"],
  J7 = S({
    __name: "BetweenLinePreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", K7, [
          h(
            "g",
            {
              fill: e.constraint.style.endPoints.fill,
              stroke: e.constraint.style.endPoints.stroke.color,
            },
            n[0] ||
              (n[0] = [
                h("circle", { cx: "4", cy: "4", r: "3" }, null, -1),
                h("circle", { cx: "16", cy: "16", r: "3" }, null, -1),
              ]),
            8,
            X7
          ),
          h(
            "path",
            {
              d: "M6.4 6.4l2.1 2.1M13.6 13.6l-2.1-2.1",
              stroke: e.constraint.style.lines.color,
            },
            null,
            8,
            Y7
          ),
          n[1] ||
            (n[1] = h(
              "path",
              {
                d: "M4.5 5.8H4V3l-.4.3a3 3 0 0 1-.5.3V3c.3 0 .5-.2.7-.4l.4-.5h.3v3.6ZM14.9 17l.4-.1.2.4.4.1h.4l.2-.3.2-.4a2.2 2.2 0 0 0 0-.6 1 1 0 0 1-.8.4 1 1 0 0 1-.8-.3c-.2-.2-.3-.5-.3-.8 0-.4.1-.7.3-1 .3-.1.5-.3.9-.3a1.2 1.2 0 0 1 1 .8l.2 1c0 .4 0 .8-.2 1 0 .3-.2.6-.4.7l-.7.2a1 1 0 0 1-.7-.2 1 1 0 0 1-.3-.7Zm1.8-1.7c0-.2 0-.4-.2-.6a.6.6 0 0 0-.5-.2c-.2 0-.4 0-.5.2-.2.2-.2.4-.2.7 0 .2 0 .4.2.5.1.2.3.2.5.2s.4 0 .5-.2l.2-.6ZM10 11.6v-.8H8.6v-.4L10.1 8h.4v2.3h.5v.4h-.5v.8h-.4Zm0-1.2V8.8l-1 1.6h1Z",
                fill: "#000",
              },
              null,
              -1
            )),
        ])
      );
    },
  });
function Q7(t) {
  return (
    typeof t == "function" ||
    (Object.prototype.toString.call(t) === "[object Object]" && !Nt(t))
  );
}
function Hu(t) {
  return {
    default: () => [
      c(
        "circle",
        {
          r: t.style.endPoints.size / 2,
          stroke: t.style.endPoints.stroke.color,
          "stroke-width": t.style.endPoints.stroke.thickness,
          fill: t.style.endPoints.fill,
        },
        null
      ),
    ],
    selection: ({ selectionOutlineSize: e }) => [
      c(
        "circle",
        {
          r: (t.style.endPoints.size + t.style.endPoints.stroke.thickness) / 2,
          stroke: ee.selectionColor,
          "stroke-width": e * 2,
          "paint-order": "stroke",
          fill: "#fff",
        },
        null
      ),
    ],
  };
}
_e({
  type: _.BetweenLines,
  label: "Between lines",
  preview: J7,
  renderers: (t) => {
    let e;
    return [
      {
        layer: oe.Default,
        component: c(
          Fo,
          { lines: t.lines, style: t.style },
          Q7((e = Hu(t))) ? e : { default: () => [e] }
        ),
      },
    ];
  },
  editor: xe({
    editor: {
      component: pa,
      props: (t) => ({
        lines: t.lines,
        endPointStyleLabel: "Circle style",
        style: t.style,
      }),
      slots: Hu,
    },
  }),
});
class eS extends us {
  constructor(e) {
    super(), (this.state = e);
  }
  start({ cellId: e }) {
    return this.updateImpl(e);
  }
  update({ cellId: e }) {
    this.updateImpl(e);
  }
  updateImpl(e) {
    return e === void 0
      ? !1
      : (this.state.getArrayAndLinkedIndexAt(e) || this.state.groups.push([e]),
        this.state.selection.add(e),
        !0);
  }
}
class tS extends us {
  constructor(e) {
    super(), (this.state = e);
  }
  start(e) {
    return this.update(e), (this.state.selection = new Set()), !0;
  }
  update({ cellId: e }) {
    e !== void 0 && this.state.removeCell(e);
  }
}
class nS extends us {
  constructor(n) {
    super();
    L(this, "dragStartPosition", { x: 0, y: 0 });
    L(this, "dragStartCells", []);
    L(this, "createdArrayAndCloneIndices", []);
    this.state = n;
  }
  start({ cellId: n }) {
    return (
      (n === void 0 || !this.state.selection.has(n)) &&
        (this.state.selection = new Set()),
      n === void 0 || this.state.getArrayAndLinkedIndexAt(n) === void 0
        ? !1
        : ((this.dragStartPosition =
            this.state.helpers.cellIds.getCoordsFromId(n)),
          this.state.selection.add(n),
          (this.createdArrayAndCloneIndices = []),
          !0)
    );
  }
  update({ cellId: n }) {
    n !== void 0 &&
      (this.createdArrayAndCloneIndices.length === 0
        ? this.createCloneFromSelection(n)
        : this.moveSelection(n));
  }
  createCloneFromSelection(n) {
    const { helpers: s } = this.state,
      o = Ze(s.cellIds.getCoordsFromId(n), this.dragStartPosition);
    if (!this.state.validOffset(this.state.selection, o)) return !1;
    const r = [],
      l = [];
    for (const i of this.state.selection) {
      const a = s.cellIds.getIdFromCoords(ft(s.cellIds.getCoordsFromId(i), o));
      if (this.state.getArrayAndLinkedIndexAt(a)) return;
      r.push(i), l.push(a);
    }
    (this.dragStartPosition = s.cellIds.getCoordsFromId(n)),
      (this.dragStartCells = []),
      (this.createdArrayAndCloneIndices = []),
      (this.state.selection = new Set(l));
    for (let i = 0; i < r.length; i++) {
      const a = r[i],
        u = l[i],
        { arrayIndex: p } = this.state.getArrayAndLinkedIndexAt(a);
      this.state.groups[p].push(u),
        this.dragStartCells.push(u),
        this.createdArrayAndCloneIndices.push({
          arrayIndex: p,
          linkIndex: this.state.groups[p].length - 1,
        });
    }
    return !0;
  }
  moveSelection(n) {
    const { helpers: s } = this.state,
      o = Ze(s.cellIds.getCoordsFromId(n), this.dragStartPosition);
    if (!this.state.validOffset(this.dragStartCells, o)) return;
    const r = [];
    for (const l of this.dragStartCells) {
      const i = s.cellIds.getIdFromCoords(ft(s.cellIds.getCoordsFromId(l), o)),
        a = this.state.getArrayAndLinkedIndexAt(i);
      if (a && !this.createdArrayAndCloneIndices.some((u) => Ce(u, a))) return;
      r.push(i);
    }
    for (let l = 0; l < this.createdArrayAndCloneIndices.length; l++) {
      const { arrayIndex: i, linkIndex: a } =
        this.createdArrayAndCloneIndices[l];
      this.state.groups[i][a] = r[l];
    }
    this.state.selection = new Set(r);
  }
}
class sS extends us {
  constructor(n) {
    super();
    L(this, "previousIndex", 0);
    this.state = n;
  }
  start({ cellId: n }) {
    return (
      (n === void 0 || !this.state.selection.has(n)) &&
        (this.state.selection = new Set()),
      n === void 0 || this.state.getArrayAndLinkedIndexAt(n) === void 0
        ? !1
        : (this.state.selection.add(n), (this.previousIndex = n), !0)
    );
  }
  update({ cellId: n }) {
    n === void 0 || n === this.previousIndex || this.moveSelection(n);
  }
  moveSelection(n) {
    const { helpers: s } = this.state,
      o = Ze(
        s.cellIds.getCoordsFromId(n),
        s.cellIds.getCoordsFromId(this.previousIndex)
      ),
      r = [...this.state.selection]
        .map((i) => this.state.getArrayAndLinkedIndexAt(i))
        .filter((i) => i);
    if (!this.state.validOffset(this.state.selection, o)) return;
    const l = [];
    for (const i of this.state.selection) {
      const a = s.cellIds.getIdFromCoords(ft(s.cellIds.getCoordsFromId(i), o)),
        u = this.state.getArrayAndLinkedIndexAt(a);
      if (u && !r.some((p) => Ce(p, u))) return;
      l.push(a);
    }
    this.state.selection = new Set();
    for (let i = 0; i < r.length; i++) {
      const { arrayIndex: a, linkIndex: u } = r[i],
        p = l[i];
      this.state.selection.add(p), (this.state.groups[a][u] = p);
    }
    this.previousIndex = n;
  }
}
class oS extends tf {
  constructor(e) {
    super(e, (n) => this.state.getCells().find((s) => s === n));
  }
}
class rS {
  constructor(e) {
    L(this, "selection", new Set());
    L(this, "groups", []);
    this.helpers = e;
  }
  setFromConstraint(e) {
    this.groups = ue(e);
  }
  equalsConstraint(e) {
    return Ce(this.groups, e);
  }
  getCells() {
    return this.groups.flat();
  }
  getSelectedCells() {
    const e = this.getCells();
    return [...this.selection].filter((n) => e.includes(n));
  }
  getSelectedLinkedCells() {
    const e = [];
    for (const n of this.groups)
      if (ho(this.selection, n))
        for (const s of n) this.selection.has(s) || e.push(s);
    return e;
  }
  removeCell(e) {
    this.removeCells([e]);
  }
  removeCells(e) {
    this.groups = this.groups.map((n) => mn(n, e)).filter((n) => n.length > 0);
  }
  getArrayAndLinkedIndexAt(e) {
    for (let n = 0; n < this.groups.length; n++) {
      const s = this.groups[n].indexOf(e);
      if (s > -1) return { arrayIndex: n, linkIndex: s };
    }
  }
  validOffset(e, n) {
    for (const s of e) {
      const o = ft(this.helpers.cellIds.getCoordsFromId(s), n);
      if (!this.helpers.cellIds.areValidCoords(o)) return !1;
    }
    return !0;
  }
}
const lS = S({
  components: {
    InputListener: jn,
    EditorEvents: Jo,
    CellSymbolRenderer: is,
    EditorFormBase: yt,
    Highlight: Zo,
    ArrowShape: Qo,
    EditorRendererWrapper: ct,
    FormButton: te,
  },
  props: {
    context: { type: Object, required: !0 },
    groups: { type: Array, required: !0 },
    layer: { type: String, default: oe.Background },
    linkName: { type: String, default: "Link" },
  },
  data() {
    return {
      action: "add",
      actionId: fe(),
      brush: null,
      state: new rS(this.context.helpers),
    };
  },
  computed: {
    hasShape() {
      return this.groups.flat().length > 0;
    },
    selectedCells() {
      return this.state.getSelectedCells();
    },
    cells() {
      return this.state.groups.flat();
    },
    arrows() {
      const { helpers: t } = this.context,
        e = this.state,
        n = [];
      for (const s of e.groups) {
        const o = t.cellIds.getCellCenterFromId(s[0]);
        for (let r = 1; r < s.length; r++) {
          const l = t.cellIds.getCellCenterFromId(s[r]);
          n.push({ from: o, to: l });
        }
      }
      return n;
    },
    selectionColor() {
      return ee.selectionColor;
    },
    linkedSelectionColor() {
      const t = Gt(ee.selectionColor) || {
        red: 0,
        green: 0,
        blue: 0,
        alpha: 1,
      };
      return (t.alpha *= 0.5), Hs(t);
    },
    linkedSelection() {
      return this.state.getSelectedLinkedCells();
    },
  },
  watch: {
    groups: {
      immediate: !0,
      handler(t) {
        Ce(this.state.groups, t) ||
          (this.clearSelection(),
          (this.brush = null),
          this.state.setFromConstraint(t));
      },
    },
    hasShape(t) {
      t || (this.action = "add");
    },
    action(t) {
      t === "add" && this.clearSelection();
    },
  },
  methods: {
    clearSelection() {
      this.state.selection = new Set();
    },
    startBrush(t, e) {
      (this.brush = t),
        this.brush.start(e) ? this.update() : (this.brush = null);
    },
    onPointerDown(t) {
      if (t.cellId === void 0) return;
      const e = this.state;
      if (ye.isSelecting()) {
        this.startBrush(new oS(e), t);
        return;
      }
      switch (((this.actionId = fe()), this.action)) {
        case "add":
          this.startBrush(new eS(e), t);
          break;
        case "clone":
          if (!this.hasShape) return;
          this.startBrush(new nS(e), t);
          break;
        case "move":
          if (!this.hasShape) return;
          this.startBrush(new sS(e), t);
          break;
        case "delete":
          if (!this.hasShape) return;
          this.startBrush(new tS(e), t);
          break;
      }
    },
    onPointerMove(t) {
      this.brush && (this.brush.update(t), this.update());
    },
    onPointerUp() {
      var t;
      (t = this.brush) == null || t.end(), this.update(), (this.brush = null);
    },
    onSelectAll() {
      this.state.selection = new Set(this.groups.flat());
    },
    update() {
      this.state.equalsConstraint(this.groups) ||
        this.context.updateConstraint(
          { groups: this.state.groups },
          "update",
          this.actionId
        );
    },
    onDelete() {
      if (this.state.selection.size === 0) return;
      const t = this.groups;
      this.state.removeCells(this.state.selection);
      const e = this.state.groups;
      Ce(e, t) || this.context.updateConstraint({ groups: e }, "delete");
    },
  },
});
function iS(t, e, n, s, o, r) {
  const l = H("FormButton"),
    i = H("EditorFormBase"),
    a = H("CellSymbolRenderer"),
    u = H("Highlight"),
    p = H("ArrowShape"),
    m = H("EditorRendererWrapper"),
    g = H("InputListener"),
    v = H("EditorEvents");
  return (
    d(),
    C(
      Z,
      null,
      [
        c(
          i,
          { class: "LinkedCellsEditor", context: t.context },
          os(
            {
              properties: f(() => [G(t.$slots, "properties", {}, void 0, !0)]),
              buttons: f(() => [
                c(
                  l,
                  {
                    active: t.action === "add",
                    toggleable: "",
                    onClick: e[0] || (e[0] = ($) => (t.action = "add")),
                  },
                  { default: f(() => e[4] || (e[4] = [F(" Add ")])), _: 1 },
                  8,
                  ["active"]
                ),
                c(
                  l,
                  {
                    active: t.action === "clone",
                    toggleable: "",
                    disabled: !t.hasShape,
                    onClick: e[1] || (e[1] = ($) => (t.action = "clone")),
                  },
                  { default: f(() => [F(X(t.linkName), 1)]), _: 1 },
                  8,
                  ["active", "disabled"]
                ),
                c(
                  l,
                  {
                    active: t.action === "move",
                    toggleable: "",
                    disabled: !t.hasShape,
                    onClick: e[2] || (e[2] = ($) => (t.action = "move")),
                  },
                  { default: f(() => e[5] || (e[5] = [F(" Move ")])), _: 1 },
                  8,
                  ["active", "disabled"]
                ),
                c(
                  l,
                  {
                    active: t.action === "delete",
                    toggleable: "",
                    disabled: !t.hasShape,
                    onClick: e[3] || (e[3] = ($) => (t.action = "delete")),
                  },
                  { default: f(() => e[6] || (e[6] = [F(" Delete ")])), _: 1 },
                  8,
                  ["active", "disabled"]
                ),
              ]),
              _: 2,
            },
            [
              t.$slots.appearance
                ? {
                    name: "appearance",
                    fn: f(() => [G(t.$slots, "appearance", {}, void 0, !0)]),
                    key: "0",
                  }
                : void 0,
            ]
          ),
          1032,
          ["context"]
        ),
        c(
          m,
          { layer: t.layer },
          {
            default: f(() => [
              c(
                a,
                { cells: t.cells },
                {
                  default: f(() => [G(t.$slots, "default", {}, void 0, !0)]),
                  _: 3,
                },
                8,
                ["cells"]
              ),
              c(
                u,
                { selection: t.linkedSelection, color: t.linkedSelectionColor },
                null,
                8,
                ["selection", "color"]
              ),
              c(
                u,
                { selection: t.selectedCells, color: t.selectionColor },
                null,
                8,
                ["selection", "color"]
              ),
              (d(!0),
              C(
                Z,
                null,
                se(
                  t.arrows,
                  ($, k) => (
                    d(),
                    w(
                      p,
                      {
                        key: k,
                        points: [$.from, $.to],
                        size: 0.2,
                        "start-arrow": "",
                        "end-arrow": "",
                      },
                      null,
                      8,
                      ["points"]
                    )
                  )
                ),
                128
              )),
            ]),
            _: 3,
          },
          8,
          ["layer"]
        ),
        c(g, { mode: { deleteButton: t.state.selection.size > 0 } }, null, 8, [
          "mode",
        ]),
        c(
          v,
          {
            onDragStart: t.onPointerDown,
            onDragMove: t.onPointerMove,
            onDragEnd: t.onPointerUp,
            onSelectAll: t.onSelectAll,
            onDelete: t.onDelete,
          },
          null,
          8,
          ["onDragStart", "onDragMove", "onDragEnd", "onSelectAll", "onDelete"]
        ),
      ],
      64
    )
  );
}
const aS = B(lS, [
    ["render", iS],
    ["__scopeId", "data-v-c11ceace"],
  ]),
  uS = {
    class: "ClonePreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  cS = ["fill"],
  dS = S({
    __name: "ClonePreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", uS, [
          h(
            "path",
            {
              d: "M1 6v-5h6v3h3v5h-7v-3zM10 16v-5h6v3h3v5h-7v-3z",
              fill: e.constraint.style.color,
              stroke: "#000",
            },
            null,
            8,
            cS
          ),
          n[0] ||
            (n[0] = h(
              "g",
              { fill: "none", stroke: "#000" },
              [
                h("path", {
                  d: "M6.8 13.5 8.3 15l-1.5 1.5",
                  "stroke-linejoin": "miter",
                  "stroke-miterlimit": "10",
                }),
                h("path", { d: "M3 11v4h5.3" }),
              ],
              -1
            )),
        ])
      );
    },
  }),
  pS = ["fill"],
  zr = S({
    __name: "CellBackgroundRenderer",
    props: {
      cells: { type: Array, required: !0 },
      color: { type: String, required: !0 },
    },
    setup(t) {
      return (e, n) => (
        d(),
        w(
          is,
          { cells: t.cells },
          {
            default: f(() => [
              h(
                "rect",
                {
                  x: "-0.5",
                  y: "-0.5",
                  width: "1",
                  height: "1",
                  fill: t.color,
                },
                null,
                8,
                pS
              ),
            ]),
            _: 1,
          },
          8,
          ["cells"]
        )
      );
    },
  });
_e({
  type: _.Clone,
  label: "Clones",
  preview: dS,
  renderers: (t) => [
    {
      layer: oe.Default,
      component: c(zr, { cells: t.groups.flat(), color: t.style.color }, null),
    },
  ],
  editor: xe({
    editor: {
      component: aS,
      props: (t) => ({ groups: t.groups, linkName: "Clone" }),
      slots: (t) => ({
        default() {
          return [
            c(
              "rect",
              {
                x: "-0.5",
                y: "-0.5",
                width: "1",
                height: "1",
                fill: t.style.color,
              },
              null
            ),
          ];
        },
      }),
    },
    appearanceForm: {
      props: (t) => ({
        properties: [
          {
            type: "color",
            name: "color",
            label: "Color",
            value: t.style.color,
          },
        ],
      }),
    },
  }),
});
const fS = S({
    __name: "CageStyleControls",
    props: { value: {} },
    emits: ["update:value"],
    setup(t, { emit: e }) {
      const n = t,
        s = e;
      function o(r, l) {
        s("update:value", bn(ue(n.value), r), l);
      }
      return (r, l) => (
        d(),
        w(
          be,
          { vertical: "", gap: "" },
          {
            default: f(() => [
              l[2] || (l[2] = h("h3", null, "Cage style", -1)),
              c(dl, null, {
                default: f(() => [
                  c(
                    Cn,
                    {
                      color: r.value.cage.color,
                      label: "Cage color",
                      onInput:
                        l[0] || (l[0] = (i, a) => o({ cage: { color: i } }, a)),
                    },
                    null,
                    8,
                    ["color"]
                  ),
                  c(
                    Cn,
                    {
                      color: r.value.text.color,
                      label: "Text color",
                      onInput:
                        l[1] || (l[1] = (i, a) => o({ text: { color: i } }, a)),
                    },
                    null,
                    8,
                    ["color"]
                  ),
                ]),
                _: 1,
              }),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  hS = S({
    components: { FormButton: te },
    props: {
      mode: { type: String, default: "add" },
      canDelete: { type: Boolean, default: !0 },
    },
    emits: { "update:mode": (t) => !0 },
    watch: {
      canDelete(t, e) {
        !t && t !== e && this.$emit("update:mode", "add");
      },
    },
  });
function mS(t, e, n, s, o, r) {
  const l = H("FormButton");
  return (
    d(),
    C(
      Z,
      null,
      [
        c(
          l,
          {
            active: t.mode === "add",
            toggleable: "",
            onClick: e[0] || (e[0] = (i) => t.$emit("update:mode", "add")),
          },
          { default: f(() => e[2] || (e[2] = [F(" Add/Edit ")])), _: 1 },
          8,
          ["active"]
        ),
        c(
          l,
          {
            active: t.mode === "delete",
            toggleable: "",
            disabled: !t.canDelete,
            onClick: e[1] || (e[1] = (i) => t.$emit("update:mode", "delete")),
          },
          { default: f(() => e[3] || (e[3] = [F(" Delete ")])), _: 1 },
          8,
          ["active", "disabled"]
        ),
      ],
      64
    )
  );
}
const Ds = B(hS, [["render", mS]]);
function of(t) {
  const e = j("add"),
    n = j(new Set()),
    s = j(fe()),
    o = j(!1),
    r = j(!1),
    l = j(void 0),
    i = b(() => e.value === "delete"),
    a = b(() => t.cages.value.filter((E) => He.hasSome(n.value, E.cells)));
  t.disabled &&
    ae(t.disabled, (E) => {
      E && (n.value = new Set());
    }),
    ae(t.cages, () => {
      t.cages.value.length === 0 && (e.value = "add");
    });
  function u() {
    n.value.clear();
  }
  function p(E) {
    const R = t.cages.value.map((W) =>
      He.hasSome(n.value, W.cells) ? { value: E, cells: W.cells } : W
    );
    Ce(R, t.cages.value) || t.updateConstraint(R, "update", s.value);
  }
  function m(E) {
    const R = t.cages.value,
      W = t.cages.value.filter((T) => !T.cells.some((Y) => E.has(Y)));
    W.length !== R.length && (t.updateConstraint(W, "delete", s.value), u());
  }
  Vn({
    onSelectAll: k,
    onDelete: $,
    onInput: M,
    onDragStart: g,
    onDragMove: v,
  });
  function g(E) {
    var R;
    if (!((R = t.disabled) != null && R.value)) {
      if (E.cellId === void 0) {
        u();
        return;
      }
      if (((s.value = fe()), ye.isSelecting())) {
        const W = P(E.cellId);
        W &&
          (He.hasSome(n.value, W.cells)
            ? He.deleteAll(n.value, W.cells)
            : n.value.add(E.cellId));
        return;
      }
      (l.value = E.cellId),
        i.value ? x(E.cellId) : ((o.value = !0), (r.value = !1), A(E));
    }
  }
  function v({ cellId: E }) {
    var R;
    if (
      !(((R = t.disabled) != null && R.value) || E === void 0 || E === l.value)
    )
      if (i.value) x(E);
      else {
        const W = [...n.value][0],
          T = W !== void 0 && P(W);
        if (!T) return;
        const Y = P(E);
        if ((o.value && ((r.value = T === Y), (o.value = !1)), r.value)) {
          if (!Y) return;
          l.value !== void 0 && U(T, l.value) && (n.value = new Set([E]));
        } else I(T, E);
        l.value = E;
      }
  }
  function $() {
    var E;
    ((E = t.disabled) != null && E.value) || m(n.value);
  }
  function k() {
    var E;
    ((E = t.disabled) != null && E.value) ||
      (n.value = new Set(t.cages.value.map((R) => R.cells[0])));
  }
  function M(E) {
    var R;
    ((R = t.disabled) != null && R.value) || p(E.string);
  }
  function P(E) {
    return t.cages.value.find((R) => R.cells.includes(E));
  }
  function x(E) {
    P(E) && m(new Set([E]));
  }
  function A(E) {
    const R = E.cellId;
    let W = P(R);
    if (!W) {
      W = { value: D([R], ""), cells: [R] };
      const T = t.cages.value.concat(W);
      t.updateConstraint(T, "add", s.value);
    }
    n.value = new Set([W.cells[0]]);
  }
  function O(E, R) {
    const W = t.helpers,
      T = W.cellIds.getCoordsFromId(R);
    return E.cells.some((Y) => xi(W.cellIds.getCoordsFromId(Y), T) === 1);
  }
  function V(E, R) {
    if (E.cells.length === 1) return !1;
    const W = Lt.withoutAll(E.cells, [R]),
      T = new Set([W[0]]),
      Y = new Set();
    for (; T.size > 0; ) {
      const J = He.takeOne(T);
      Y.add(J);
      for (const re of W)
        !Y.has(re) &&
          t.helpers.geometry.getManhattanDistanceBetweenCells(J, re) === 1 &&
          T.add(re);
    }
    return Y.size === W.length;
  }
  function I(E, R) {
    if (!O(E, R)) return;
    const W = E.cells;
    let T = E.cells.slice();
    const Y = P(R);
    if (
      (Y && Y === E) ||
      (Y ? (T = [...new Set([...T, ...Y.cells])]) : T.push(R),
      T.length > oc(t.maxSize || 1 / 0))
    )
      return;
    const J = D(T, E.value, W),
      re = t.cages.value.map((ce) =>
        Ce(ce, E) ? { value: J, cells: T.sort((ge, de) => ge - de) } : ce
      );
    Y && Lt.remove(re, [Y]), t.updateConstraint(re, "add", s.value);
  }
  function U(E, R) {
    if (!V(E, R)) return !1;
    const W = E.cells,
      T = Lt.withoutAll(W, [R]),
      Y = D(T, E.value, W),
      J = t.cages.value.map((re) => (re === E ? { value: Y, cells: T } : re));
    return t.updateConstraint(J, "reduce", s.value), !0;
  }
  function D(E, R, W) {
    let T;
    if (R === "") T = N(E);
    else {
      const Y = W ? R === N(W) : !1,
        J = N(E);
      T = Y ? J : R;
    }
    return T;
  }
  function N(E) {
    if (t.defaultValue === void 0) return "";
    if (typeof t.defaultValue == "string") return t.defaultValue;
    const R = E.map((W) => t.project.cells[W].value);
    return t.defaultValue(R);
  }
  return { mode: e, selectedCages: a, deselect: u };
}
function er(t) {
  const e = fe();
  ae(
    t.inputMode,
    (n) => {
      ye.setInputMode(n, e);
    },
    { immediate: !0 }
  ),
    t.selectedValue &&
      ae(t.selectedValue, (n) => {
        ye.setCurrentValue(n || "");
      });
}
const gS = ["transform", "fill", "opacity"],
  vS = ["font-size"],
  rf = S({
    __name: "CageValue",
    props: {
      value: {},
      cell: {},
      fontSize: { default: 0.2 },
      fill: { default: "#000000" },
    },
    setup(t) {
      const e = t,
        { helpers: n } = Qe(et).value,
        s = b(() => {
          const { x: i, y: a } = n.cellIds.getCoordsFromId(e.cell);
          return `translate(${i + 0.045} ${a + 0.036}) scale(0.02)`;
        }),
        o = b(() => Gt(e.fill)),
        r = b(() => Us(o.value)),
        l = b(() => o.value.alpha);
      return (i, a) => (
        d(),
        C(
          "g",
          {
            transform: s.value,
            "stroke-width": "3",
            stroke: "#fff",
            fill: r.value,
            opacity: l.value,
          },
          [
            h(
              "text",
              {
                "font-size": i.fontSize * 50,
                y: "1",
                "stroke-linejoin": "round",
                "paint-order": "stroke",
                "dominant-baseline": "hanging",
              },
              X(i.value),
              9,
              vS
            ),
          ],
          8,
          gS
        )
      );
    },
  });
function lf(t) {
  return Math.min(...t.cells);
}
const fl = S({
    __name: "CageRenderer",
    props: {
      style: {
        type: Object,
        default() {
          return { cage: { color: "#000" }, text: { color: "#000" } };
        },
      },
      cages: { type: Array, required: !0 },
    },
    setup(t) {
      const e = t,
        n = b(() =>
          e.cages
            .filter((s) => s.value)
            .map((s) => ({ location: lf(s), text: s.value }))
        );
      return (s, o) => (
        d(),
        C("g", null, [
          (d(!0),
          C(
            Z,
            null,
            se(
              t.cages,
              (r, l) => (
                d(),
                w(
                  Vs,
                  {
                    key: `cage${l}`,
                    cells: r.cells,
                    "stroke-color": t.style.cage.color,
                    "stroke-width": 0.025,
                    offset: 0.08,
                    "stroke-dasharray": "0.1 0.06",
                  },
                  null,
                  8,
                  ["cells", "stroke-color"]
                )
              )
            ),
            128
          )),
          (d(!0),
          C(
            Z,
            null,
            se(
              n.value,
              ({ location: r, text: l }, i) => (
                d(),
                w(
                  rf,
                  {
                    key: `value${i}`,
                    cell: r,
                    value: l,
                    fill: t.style.text.color,
                  },
                  null,
                  8,
                  ["cell", "value", "fill"]
                )
              )
            ),
            128
          )),
        ])
      );
    },
  }),
  fa = S({
    __name: "CageEditor",
    props: {
      context: {},
      cages: {},
      style: {},
      defaultValue: { type: [String, Function], default: "" },
      maxSize: { default: 1 / 0 },
      inputMode: { default: void 0 },
    },
    setup(t) {
      const e = t,
        { mode: n, selectedCages: s } = of({
          cages: _a(() => e.cages),
          defaultValue: e.defaultValue,
          maxSize: _a(() => e.maxSize),
          project: e.context.project,
          helpers: e.context.helpers,
          updateConstraint: (i, a, u) => {
            e.context.updateConstraint({ cages: i }, a, u);
          },
        }),
        o = b(() =>
          s.value.length === 0
            ? {}
            : { ...e.inputMode, deleteButton: s.value.length > 0 }
        ),
        r = b(() => {
          var i;
          return ((i = s.value[0]) == null ? void 0 : i.value) || "";
        });
      er({ inputMode: o, selectedValue: r });
      function l(i, a) {
        e.context.updateConstraintAppearance(i, "update:cageStyle", a);
      }
      return (i, a) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              yt,
              { class: "KillerCagesEditor", context: i.context },
              {
                properties: f(() => [G(i.$slots, "properties")]),
                appearance: f(() => [
                  c(fS, { value: i.style, "onUpdate:value": l }, null, 8, [
                    "value",
                  ]),
                  G(i.$slots, "appearance"),
                ]),
                buttons: f(() => [
                  c(
                    Ds,
                    {
                      mode: y(n),
                      "onUpdate:mode":
                        a[0] || (a[0] = (u) => (Rn(n) ? (n.value = u) : null)),
                      "can-delete": i.cages.length > 0,
                    },
                    null,
                    8,
                    ["mode", "can-delete"]
                  ),
                ]),
                _: 3,
              },
              8,
              ["context"]
            ),
            c(
              ct,
              { layer: y(oe).Grid },
              {
                default: f(() => [
                  (d(!0),
                  C(
                    Z,
                    null,
                    se(
                      y(s),
                      (u, p) => (
                        d(),
                        C("g", { key: p }, [
                          c(
                            Vs,
                            {
                              cells: u.cells,
                              offset: 0.08,
                              "stroke-color": y(ee).selectionColor,
                              "stroke-width": 0.025 + y(on),
                            },
                            null,
                            8,
                            ["cells", "stroke-color", "stroke-width"]
                          ),
                        ])
                      )
                    ),
                    128
                  )),
                  c(fl, { cages: i.cages, style: We(i.style) }, null, 8, [
                    "cages",
                    "style",
                  ]),
                  (d(!0),
                  C(
                    Z,
                    null,
                    se(
                      y(s),
                      (u, p) => (
                        d(),
                        C("g", { key: p }, [
                          c(
                            rf,
                            {
                              cell: y(lf)(u),
                              value: u.value,
                              fill: i.style.text.color,
                            },
                            null,
                            8,
                            ["cell", "value", "fill"]
                          ),
                        ])
                      )
                    ),
                    128
                  )),
                ]),
                _: 1,
              },
              8,
              ["layer"]
            ),
          ],
          64
        )
      );
    },
  }),
  yS = {
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-miterlimit": "1.5",
  },
  CS = ["fill"],
  wS = ["stroke"],
  ha = S({
    __name: "CagesPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", yS, [
          h(
            "path",
            {
              d: "M2.23 5.08h-.56V1.57a3.72 3.72 0 0 1-1.1.66V1.7c.31-.15.58-.32.81-.53.23-.2.4-.4.49-.6h.35v4.5Zm4.3-.53v.53H3.57c0-.13.01-.26.06-.38A2 2 0 0 1 4 4.1c.17-.2.41-.42.72-.68.5-.4.82-.72 1-.95.16-.23.25-.46.25-.66 0-.22-.08-.4-.23-.56a.85.85 0 0 0-.61-.22.86.86 0 0 0-.64.24.9.9 0 0 0-.24.66l-.57-.06c.04-.42.18-.74.44-.97.25-.22.6-.33 1.02-.33.43 0 .77.12 1.02.36s.38.53.38.89c0 .18-.04.35-.11.53-.08.17-.2.35-.37.55-.17.19-.45.45-.85.79a9.6 9.6 0 0 0-.64.56 2 2 0 0 0-.23.3h2.2Z",
              fill: e.constraint.style.text.color,
            },
            null,
            8,
            CS
          ),
          h(
            "path",
            {
              d: "M8 1h11v18H1V6.2",
              fill: "none",
              stroke: e.constraint.style.cage.color,
              "stroke-dasharray": "1.5,2,0,0",
            },
            null,
            8,
            wS
          ),
          G(e.$slots, "default"),
        ])
      );
    },
  });
_e({
  type: _.CosmeticCage,
  label: "Cosmetic cages",
  preview: ha,
  ignoredBySolver: !0,
  renderers: (t) => [
    {
      layer: oe.Default,
      component: c(fl, { cages: t.cages, style: t.style }, null),
    },
  ],
  editor: xe({
    editor: {
      component: fa,
      props: (t) => ({
        cages: t.cages,
        inputMode: { ...Zs(), type: Ke.CosmeticText },
        style: t.style,
      }),
    },
  }),
});
const wt = 10;
function af(t, e) {
  const n = b(() => {
      const r = [],
        l = 1 / e.resolution;
      for (let i = -wt; i <= t.size.width + wt; i += l)
        r.push([
          { x: i, y: -wt },
          { x: i, y: t.size.height + wt },
        ]);
      for (let i = -wt; i <= t.size.height + wt; i += l)
        r.push([
          { y: i, x: -wt },
          { y: i, x: t.size.width + wt },
        ]);
      return r;
    }),
    s = ({ x: r, y: l }) => {
      const { snapTo: i, resolution: a } = e,
        u = Object.values(i).every((v) => !v);
      let p = 1 / 0,
        m;
      const g = (v) => {
        const $ = Wr({ x: r, y: l }, v);
        $ < p && ((m = v), (p = $));
      };
      if (
        ((u || i.center) &&
          g({
            x: (Math.round(r * a - 0.5) + 0.5) / a,
            y: (Math.round(l * a - 0.5) + 0.5) / a,
          }),
        i.edge)
      ) {
        const v = xt(r * a, 1),
          $ = xt(l * a, 1),
          k = Math.floor(r * a),
          M = Math.floor(l * a);
        (v < 0.5 && $ < v) || (v >= 0.5 && $ < 1 - v)
          ? g({ x: (k + 0.5) / a, y: M / a })
          : (v < 0.5 && 1 - $ < v) || (v >= 0.5 && 1 - $ < 1 - v)
          ? g({ x: (k + 0.5) / a, y: (M + 1) / a })
          : v < 0.5
          ? g({ x: k / a, y: (M + 0.5) / a })
          : g({ x: (k + 1) / a, y: (M + 0.5) / a });
      }
      if (
        (i.corner && g({ x: Math.round(r * a) / a, y: Math.round(l * a) / a }),
        !(
          m.x <= -wt ||
          m.x >= t.size.width + wt ||
          m.y <= -wt ||
          m.y >= t.size.height + wt
        ))
      )
        return m;
    },
    o = ({ x: r, y: l }) => {
      const { snapTo: i, resolution: a } = e;
      let u = xt(r * a, 1),
        p = xt(l * a, 1);
      return i.center && !i.corner
        ? u < 0.5
          ? Math.abs(p - 0.5) < u
          : Math.abs(p - 0.5) < 1 - u
        : i.corner && !i.center
        ? ((u = (u + 0.5) % 1),
          (p = (p + 0.5) % 1),
          u < 0.5 ? Math.abs(p - 0.5) < u : Math.abs(p - 0.5) < 1 - u)
        : u < 0.25 || u > 0.75
        ? p < 0.25 || p > 0.75
        : p > 0.25 && p < 0.75;
    };
  return {
    state: e,
    gridLines: n,
    getPlaceablePosition(r) {
      return Ue(s({ x: r.pointerX, y: r.pointerY }));
    },
    isAligned({ x: r, y: l }) {
      const { snapTo: i, resolution: a } = e,
        u = xt(r * a, 1),
        p = xt(l * a, 1),
        m = Jt(u, 0) || Jt(u, 1),
        g = Jt(p, 0) || Jt(p, 1);
      return (
        (i.corner && m && g) ||
        (i.center && Jt(u, 0.5) && Jt(p, 0.5)) ||
        (i.edge && Jt(u, 0.5) && g) ||
        (i.edge && m && Jt(p, 0.5))
      );
    },
    isNiceOffset(r) {
      return o({ x: r.pointerX, y: r.pointerY });
    },
  };
}
function uf(t) {
  return {
    left: Math.ceil(Math.min(wt, t.left + 0.85)),
    right: Math.ceil(Math.min(wt, t.right + 0.85)),
    top: Math.ceil(Math.min(wt, t.top + 0.85)),
    bottom: Math.ceil(Math.min(wt, t.bottom + 0.85)),
  };
}
const bS = S({
    components: { TooltipIndicator: dt, FormControlLabel: ut, CheckBox: at },
    props: {
      value: { type: Object, required: !0 },
      options: { type: Array, required: !0 },
      flex: { type: Boolean, default: !1 },
    },
    emits: { "update:value": (t) => !0 },
    methods: {
      onClick(t, e) {
        this.$emit("update:value", { ...this.value, [t]: e });
      },
    },
  }),
  kS = ["innerHTML"];
function _S(t, e, n, s, o, r) {
  const l = H("CheckBox"),
    i = H("TooltipIndicator"),
    a = H("FormControlLabel");
  return (
    d(),
    C(
      "div",
      { class: Ae(["CheckboxList", { flex: t.flex }]) },
      [
        (d(!0),
        C(
          Z,
          null,
          se(
            t.options,
            (u) => (
              d(),
              w(
                a,
                { key: u.value },
                {
                  default: f(() => [
                    c(
                      l,
                      {
                        checked: t.value[u.value],
                        "onUpdate:checked": (p) => t.onClick(u.value, p),
                      },
                      null,
                      8,
                      ["checked", "onUpdate:checked"]
                    ),
                    h("span", null, [
                      F(X(u.label) + " ", 1),
                      u.tooltip
                        ? (d(),
                          w(
                            i,
                            { key: 0 },
                            {
                              default: f(() => [
                                h(
                                  "span",
                                  { innerHTML: u.tooltip },
                                  null,
                                  8,
                                  kS
                                ),
                              ]),
                              _: 2,
                            },
                            1024
                          ))
                        : z("", !0),
                    ]),
                  ]),
                  _: 2,
                },
                1024
              )
            )
          ),
          128
        )),
      ],
      2
    )
  );
}
const $S = B(bS, [
    ["render", _S],
    ["__scopeId", "data-v-f4213b1d"],
  ]),
  cf = S({
    __name: "GridControls",
    props: {
      grid: {},
      snapToOptions: { default: () => ({ center: !0, edge: !0, corner: !0 }) },
    },
    setup(t) {
      const e = t,
        n = b(() => e.grid),
        s = b(() => {
          const o = [];
          return (
            e.snapToOptions.center &&
              o.push({ value: "center", label: "Centers" }),
            e.snapToOptions.edge && o.push({ value: "edge", label: "Edges" }),
            e.snapToOptions.corner &&
              o.push({ value: "corner", label: "Corners" }),
            o
          );
        });
      return (o, r) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              ve,
              { label: "Snap to" },
              {
                default: f(() => [
                  c(
                    $S,
                    {
                      value: n.value.snapTo,
                      "onUpdate:value":
                        r[0] || (r[0] = (l) => (n.value.snapTo = l)),
                      options: s.value,
                      flex: "",
                    },
                    null,
                    8,
                    ["value", "options"]
                  ),
                ]),
                _: 1,
              }
            ),
            c(
              ve,
              { label: "Grid resolution" },
              {
                default: f(() => [
                  c(
                    Ht,
                    {
                      value: n.value.resolution,
                      "onUpdate:value":
                        r[1] || (r[1] = (l) => (n.value.resolution = l)),
                      min: 1,
                      max: 10,
                    },
                    null,
                    8,
                    ["value"]
                  ),
                ]),
                _: 1,
              }
            ),
            c(ut, null, {
              default: f(() => [
                c(
                  at,
                  {
                    checked: n.value.display,
                    "onUpdate:checked":
                      r[2] || (r[2] = (l) => (n.value.display = l)),
                  },
                  null,
                  8,
                  ["checked"]
                ),
                r[3] || (r[3] = h("span", null, "Display grid", -1)),
              ]),
              _: 1,
            }),
          ],
          64
        )
      );
    },
  });
function SS(t, e) {
  return {
    gridState: Xr(t, "internal", () => {
      const { resolution: s, includeCenters: o, includeCorners: r } = IS(e);
      return {
        grid: {
          snapTo: { center: o, edge: !1, corner: r },
          display: !0,
          resolution: s,
        },
      };
    }).grid,
  };
}
function IS(t) {
  const e = t.flat();
  for (let n = 1; n <= 10; n++) {
    let s = 0,
      o = 0;
    for (const r of e)
      Math.abs(Math.round(r.x * n) - r.x * n) < 1e-5 &&
      Math.abs(Math.round(r.y * n) - r.y * n) < 1e-5
        ? s++
        : Math.abs(Math.round(r.x * n - 0.5) - (r.x * n - 0.5)) < 1e-5 &&
          Math.abs(Math.round(r.y * n - 0.5) - (r.y * n - 0.5)) < 1e-5 &&
          o++;
    if (s + o === e.length)
      return {
        resolution: n,
        includeCenters: e.length === 0 || o > 0,
        includeCorners: e.length === 0 || s > 0,
      };
  }
  return { resolution: 10, includeCenters: !0, includeCorners: !0 };
}
function xS(t, e) {
  const n = b(() => new Ut(t.lines, hr)),
    s = b(() => {
      const p = new Ut(t.lines, hr);
      for (const m of p.getPoints())
        if (e.isAligned(m))
          for (const g of p.getPointsAdjacentTo(m))
            e.isAligned(g) && p.removeEdge(m, g);
      return p;
    }),
    o = b(() => s.value.toArrays()),
    r = b(() => l.value.toArrays()),
    l = b(() => {
      const p = new Ut(t.lines, hr);
      for (const m of o.value)
        for (let g = 0; g < m.length - 1; g++) p.removeEdge(m[g], m[g + 1]);
      return p;
    }),
    i = b(() => r.value.length === 0);
  function a(p) {
    return n.value.getComponentsContainingPoints(p);
  }
  function u(p) {
    return l.value.getComponentsContainingPoints(p);
  }
  return {
    allLinesGraph: n,
    selectableLines: r,
    unselectableLines: o,
    canDeleteLines: i,
    getLinesAt: a,
    getSelectableLinesAt: u,
  };
}
const DS = S({
    props: {
      paths: { type: Array, required: !0 },
      lineWidth: { type: Number, default: 0.16 },
      color: { type: String, default: "#dddddd" },
    },
    computed: {
      path() {
        let t = "";
        for (const e of this.paths) {
          if (e.length === 1) {
            t += this.getDotPath(e[0]);
            continue;
          }
          for (let n = 0; n < e.length; n++) {
            if (n === e.length - 1 && e[0] === e[n]) {
              t += "Z";
              break;
            }
            const s = e[n].x,
              o = e[n].y;
            t += n === 0 ? `M${s} ${o}` : `L${s} ${o}`;
          }
        }
        return t;
      },
    },
    methods: {
      getDotPath(t) {
        const e = t.x,
          n = t.y;
        return `M${e} ${n}L${e} ${n}`;
      },
    },
  }),
  MS = ["d", "stroke", "stroke-width"];
function AS(t, e, n, s, o, r) {
  return (
    d(),
    C(
      "path",
      {
        d: t.path,
        fill: "none",
        stroke: t.color,
        "stroke-width": t.lineWidth,
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
      },
      null,
      8,
      MS
    )
  );
}
const df = B(DS, [["render", AS]]),
  Bs = S({
    __name: "LineRenderer",
    props: { lines: {}, style: {} },
    setup(t) {
      return (e, n) => (
        d(),
        w(
          df,
          {
            paths: e.lines,
            color: e.style.color,
            "line-width": e.style.thickness,
          },
          null,
          8,
          ["paths", "color", "line-width"]
        )
      );
    },
  }),
  PS = { key: 0, opacity: "0.25" },
  LS = ["x1", "y1", "x2", "y2", "stroke-width"],
  ES = { opacity: "0.24" },
  FS = S({
    __name: "CosmeticLineEditor",
    props: { context: {}, lines: {}, style: {} },
    setup(t) {
      const e = t,
        n = [
          { value: "", label: "Auto" },
          { value: oe.Default, label: "Below grid" },
          { value: oe.Foreground, label: "Above grid" },
        ],
        s = SS(e.context.constraint.id, e.lines),
        o = Xr(e.context.constraint.id, "margins", () => ({
          value: { left: 1, right: 1, top: 1, bottom: 1 },
        }));
      function r() {
        const q = Xd(e.lines, e.style, e.context.project.spec);
        o.value = uf(q);
      }
      const l = j(!0);
      ae(
        () => [l.value, e.lines, e.style],
        () => {
          l.value && r();
        },
        { immediate: !0 }
      );
      const i = af(e.context.project.spec, s.gridState),
        {
          state: a,
          gridLines: u,
          getPlaceablePosition: p,
          isNiceOffset: m,
        } = i,
        {
          allLinesGraph: g,
          selectableLines: v,
          unselectableLines: $,
          canDeleteLines: k,
          getLinesAt: M,
          getSelectableLinesAt: P,
        } = xS(e, i),
        x = j("add"),
        A = j("none"),
        O = j(!1),
        V = j([]),
        I = j(fe()),
        U = j(),
        D = b(() => e.style.layer || Gi(e.lines)),
        N = b(() => x.value === "delete"),
        E = j([]),
        R = b(() => e.style.thickness + on.value * 2),
        W = b(() => P(V.value).toArrays()),
        T = b(() => {
          if (O.value) return [[V.value[0]]];
        });
      function Y() {
        V.value = [];
      }
      function J(q, le) {
        e.context.updateConstraintAppearance(q, "update:lineStyle", le);
      }
      function re(q) {
        const le = q;
        e.context.updateConstraintAppearance({ layer: le }, "update:lineStyle");
      }
      Vn({
        onDragStart: ce,
        onDragMove: ge,
        onDragEnd: de,
        onDelete: ze,
        onSelectAll: Qs,
      });
      function ce(q) {
        l.value = !1;
        const le = p(q);
        if (le)
          if (((I.value = fe()), ye.isSelecting())) {
            const De = P([le]);
            V.value.some((Ps) => De.hasPoint(Ps))
              ? _t(V.value, De.getPoints())
              : V.value.push(le),
              (U.value = le),
              (A.value = "none");
          } else
            N.value
              ? (Y(), Un([le]), (A.value = "erase"))
              : (M([le]).isEmpty() && (O.value = !0),
                (V.value = [le]),
                (U.value = le),
                (A.value = "determine"));
      }
      function ge(q) {
        if (A.value === "none") return;
        const le = p(q);
        if (A.value === "erase") {
          le && Un([le]);
          return;
        }
        if (!U.value || !le || Ce(le, U.value) || !m(q)) return;
        const De = g.value.hasEdge(le, y(U.value));
        A.value === "determine" &&
          ((A.value = De ? "removeEdges" : "addEdges"),
          A.value === "removeEdges" && (E.value = [[U.value]])),
          A.value === "removeEdges" && De
            ? Q(le)
            : A.value === "addEdges" && !De
            ? ne(le)
            : De && (U.value = le);
      }
      function de() {
        (A.value = "none"), (E.value = []), (O.value = !1), (l.value = !0);
      }
      function ze() {
        Un(V.value);
      }
      function Qs() {
        V.value = g.value.getPoints();
      }
      function eo() {
        return g.value.clone();
      }
      function Un(q) {
        const De = [...P(q).getEdges()];
        if (De.length === 0) return;
        const Ct = eo();
        for (const Ps of De) Ct.removeEdge(Ps[0], Ps[1]);
        e.context.updateConstraint({ lines: Ct.toArrays() }, "delete", I.value);
      }
      function ne(q) {
        const le = U.value,
          De = Ze(le, q);
        if (Math.abs(De.x) > 1 || Math.abs(De.y) > 1) {
          U.value = q;
          return;
        }
        const Ct = eo().addEdge(le, q);
        e.context.updateConstraint({ lines: Ct.toArrays() }, "add", I.value),
          (O.value = !1),
          (U.value = q);
      }
      function Q(q) {
        const le = eo()
          .removeEdge(U.value, q)
          .removeEdge(q, U.value)
          .toArrays();
        e.context.updateConstraint({ lines: le }, "delete", I.value),
          V.value.push(q),
          _t(V.value, [U.value]);
        const De = E.value.at(-1);
        De.length === 1 ? De.push(q) : E.value.push([De[1], q]), (U.value = q);
      }
      return (q, le) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              yt,
              { class: "LineEditor", context: q.context },
              {
                properties: f(() => [
                  c(
                    cf,
                    {
                      grid: y(a),
                      "snap-to-options": { center: !0, corner: !0, edge: !1 },
                    },
                    null,
                    8,
                    ["grid"]
                  ),
                  y($).length > 0
                    ? (d(),
                      w(
                        lt,
                        { key: 0 },
                        {
                          default: f(
                            () =>
                              le[1] ||
                              (le[1] = [
                                F(
                                  " Change grid resolution and/or snap-to settings to modify the lines which are grayed out. "
                                ),
                              ])
                          ),
                          _: 1,
                        }
                      ))
                    : z("", !0),
                ]),
                appearance: f(() => [
                  c(da, { value: q.style, "onUpdate:value": J }, null, 8, [
                    "value",
                  ]),
                  c(
                    ve,
                    { label: "Layer" },
                    {
                      default: f(() => [
                        c(
                          qs,
                          {
                            "model-value": q.style.layer || "",
                            "dropdown-align": "left",
                            options: n,
                            "onUpdate:modelValue": re,
                          },
                          null,
                          8,
                          ["model-value"]
                        ),
                      ]),
                      _: 1,
                    }
                  ),
                ]),
                buttons: f(() => [
                  c(
                    Ds,
                    {
                      mode: x.value,
                      "onUpdate:mode":
                        le[0] || (le[0] = (De) => (x.value = De)),
                      "can-delete": !y(k),
                    },
                    null,
                    8,
                    ["mode", "can-delete"]
                  ),
                ]),
                _: 1,
              },
              8,
              ["context"]
            ),
            c(
              ct,
              { layer: y(oe).Grid },
              {
                default: f(() => [
                  y(a).display
                    ? (d(),
                      C("g", PS, [
                        (d(!0),
                        C(
                          Z,
                          null,
                          se(
                            y(u),
                            (De, Ct) => (
                              d(),
                              C(
                                "line",
                                {
                                  key: Ct,
                                  x1: De[0].x,
                                  y1: De[0].y,
                                  x2: De[1].x,
                                  y2: De[1].y,
                                  stroke: "#000",
                                  "stroke-width": y(Sp),
                                },
                                null,
                                8,
                                LS
                              )
                            )
                          ),
                          128
                        )),
                      ]))
                    : z("", !0),
                ]),
                _: 1,
              },
              8,
              ["layer"]
            ),
            c(
              ct,
              { layer: D.value },
              {
                default: f(() => [
                  T.value
                    ? (d(),
                      w(
                        Bs,
                        {
                          key: 0,
                          lines: T.value,
                          style: We({
                            color: y(ee).selectionColor,
                            thickness: R.value,
                          }),
                        },
                        null,
                        8,
                        ["lines", "style"]
                      ))
                    : z("", !0),
                  c(
                    Bs,
                    {
                      lines: W.value,
                      style: We({
                        color: y(ee).selectionColor,
                        thickness: R.value,
                      }),
                    },
                    null,
                    8,
                    ["lines", "style"]
                  ),
                  h("g", ES, [
                    c(
                      Bs,
                      {
                        lines: y($),
                        style: We({
                          thickness: q.style.thickness,
                          color: "#000",
                        }),
                      },
                      null,
                      8,
                      ["lines", "style"]
                    ),
                  ]),
                  c(Bs, { lines: y(v), style: We(q.style) }, null, 8, [
                    "lines",
                    "style",
                  ]),
                  c(
                    Bs,
                    {
                      lines: E.value,
                      style: We({ color: "#ff0000cc", thickness: R.value }),
                    },
                    null,
                    8,
                    ["lines", "style"]
                  ),
                ]),
                _: 1,
              },
              8,
              ["layer"]
            ),
            c(y(jn), { mode: { deleteButton: W.value.length > 0 } }, null, 8, [
              "mode",
            ]),
          ],
          64
        )
      );
    },
  }),
  BS = { viewBox: "0 0 20 11", xmlns: "http://www.w3.org/2000/svg" },
  zS = ["stroke"],
  pf = S({
    __name: "LinePreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", BS, [
          h(
            "path",
            {
              d: "M1 1L10 10L19 1",
              stroke: e.constraint.style.color,
              fill: "none",
            },
            null,
            8,
            zS
          ),
        ])
      );
    },
  });
_e({
  type: _.CosmeticLine,
  label: "Cosmetic lines",
  preview: pf,
  ignoredBySolver: !0,
  gridUnbound: !0,
  margins: (t, e) => Xd(t.lines, t.style, e),
  renderers: (t) => [
    {
      layer: t.style.layer || Gi(t.lines),
      component: c(Bs, { lines: t.lines, style: t.style }, null),
    },
  ],
  editor: xe({
    editor: {
      component: FS,
      props: (t) => ({ lines: t.lines, style: t.style }),
    },
  }),
});
const RS = S({
    components: { NumberInput: Ht, FormRow: ve },
    props: {
      value: { type: Number, required: !0 },
      label: { type: String, default: "Angle" },
      min: { type: Number, default: 0 },
      max: { type: Number, default: 360 },
    },
    emits: { input: (t, e) => !0 },
    data() {
      return { controlId: fe() };
    },
    methods: {
      updateValue(t) {
        this.$emit("input", t, this.controlId);
      },
    },
  }),
  OS = ["min", "max", "value"];
function NS(t, e, n, s, o, r) {
  const l = H("NumberInput"),
    i = H("FormRow");
  return (
    d(),
    w(
      i,
      { class: "AngleInput", label: `${t.label}:` },
      {
        default: f(() => [
          h(
            "input",
            {
              class: "slider",
              type: "range",
              min: t.min,
              max: t.max,
              value: t.value,
              step: 45,
              onInput:
                e[0] || (e[0] = (a) => t.updateValue(Number(a.target.value))),
            },
            null,
            40,
            OS
          ),
          c(
            l,
            {
              value: t.value,
              min: t.min,
              max: t.max,
              compact: "",
              "onUpdate:value": t.updateValue,
            },
            null,
            8,
            ["value", "min", "max", "onUpdate:value"]
          ),
        ]),
        _: 1,
      },
      8,
      ["label"]
    )
  );
}
const TS = B(RS, [
    ["render", NS],
    ["__scopeId", "data-v-5cb53b50"],
  ]),
  VS = ["transform"],
  hl = S({
    __name: "EraseShape",
    props: { x: {}, y: {}, scale: { default: 1 } },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "path",
          {
            d: "M-1-1L1 1M1-1L-1 1",
            stroke: "#f008",
            "stroke-width": "0.6",
            transform: `translate(${e.x} ${e.y}) scale(${Math.max(
              0.15,
              e.scale
            )})`,
          },
          null,
          8,
          VS
        )
      );
    },
  });
function ml(t) {
  const e = j("add"),
    n = j(),
    s = b(() => e.value === "delete"),
    o = b(() => e.value === "add");
  return (
    Vn({
      touchMoveIsHover: !0,
      onHover(l) {
        n.value = t.getPlaceablePosition(l);
      },
      onDragStart(l) {
        (n.value = t.getPlaceablePosition(l)),
          s.value && n.value && t.deleteAt(n.value);
      },
      onDragMove(l) {
        (n.value = t.getPlaceablePosition(l)),
          s.value && n.value && t.deleteAt(n.value);
      },
      onPointerAction: (l) => {
        if (((n.value = t.getPlaceablePosition(l)), n.value === void 0)) {
          t.deselect();
          return;
        }
        s.value
          ? (t.deselect(), t.deleteAt(n.value), (n.value = void 0))
          : t.createOrSelectClue(n.value, ye.isSelecting());
      },
      onDelete() {
        t.deleteSelectedClues();
      },
      onSelectAll() {
        t.selectAll();
      },
      onInput(l) {
        t.updateClueValue(l.string);
      },
    }),
    Pt(nt, "blur", () => {
      n.value = void 0;
    }),
    Pt(nt, "zoomPan", () => {
      n.value = void 0;
    }),
    { position: n, pointerAction: e, deleting: s, placing: o }
  );
}
function di(t) {
  const e = xt(t.x, 1),
    n = xt(t.y, 1);
  return e < 0.25 || e > 0.75 || n < 0.25 || n > 0.75
    ? oe.Foreground
    : oe.Default;
}
function jS(t, e, n) {
  if (n.type === t) return n;
  const s = e
    .slice()
    .reverse()
    .find((o) => o.params.type === t);
  switch (t) {
    case pe.Text:
      return s
        ? s.params
        : {
            type: pe.Text,
            text: "",
            size: 0.25,
            angle: 0,
            strokeWidth: 0.02,
            stroke: "#ffffff",
            fill: "#000000",
          };
    case pe.Rectangle:
      return s
        ? s.params
        : {
            type: pe.Rectangle,
            width: 0.5,
            height: 0.5,
            angle: 0,
            strokeWidth: 0.02,
            stroke: "#000000",
            fill: "#ffffff",
          };
    case pe.Ellipse:
      return s
        ? s.params
        : {
            type: pe.Ellipse,
            rx: 0.4,
            ry: 0.4,
            angle: 0,
            strokeWidth: 0.02,
            stroke: "#000000",
            fill: "#ffffff",
          };
    case pe.Arrow:
      return s
        ? s.params
        : {
            type: pe.Arrow,
            length: 0.25,
            headSize: 0.125,
            angle: 0,
            strokeWidth: 0.02,
            stroke: "#000000",
            fill: "#ffffff",
          };
  }
}
function US(t, e) {
  const n = Wr(t, e.position);
  switch (e.params.type) {
    case pe.Rectangle:
      if (n < (e.params.width + e.params.height) / 4) return !0;
      break;
    case pe.Ellipse:
      if (n < (e.params.rx + e.params.ry) / 2) return !0;
      break;
    case pe.Text:
      if (n < e.params.size) return !0;
      break;
    case pe.Arrow:
      if (n < e.params.length / 2) return !0;
      break;
  }
  return n < 0.08;
}
function io(t, e) {
  for (let n = e.length - 1; n >= 0; n--) if (US(t, e[n])) return e[n];
}
function HS(t) {
  const e = t.params;
  switch (e.type) {
    case pe.Rectangle:
      return e.width === 0 || e.height === 0;
    case pe.Ellipse:
      return e.rx === 0 || e.ry === 0;
    case pe.Text:
      return e.size === 0 || e.text === "" || e.text.match(/^\s+$/);
    case pe.Arrow:
      return e.length === 0 && e.headSize === 0;
  }
}
var Tt = ((t) => (
  (t[(t.Auto = 0)] = "Auto"),
  (t[(t.Default = oe.Default)] = "Default"),
  (t[(t.AboveGrid = oe.Foreground)] = "AboveGrid"),
  t
))(Tt || {});
const WS = [
  { value: 0, label: "Automatic" },
  { value: Tt.Default, label: "Below grid" },
  { value: Tt.AboveGrid, label: "Above grid" },
];
function ZS(t, e) {
  const n = Xr(t.constraint.id, "internal", () => {
      var u;
      return {
        grid: {
          snapTo: { center: !0, edge: !0, corner: !0 },
          display: !0,
          resolution: GS(e),
        },
        showStyle: ((u = t.initParams) == null ? void 0 : u.showStyle) || !1,
        symbol: qS(e),
      };
    }),
    {
      state: s,
      gridLines: o,
      getPlaceablePosition: r,
    } = af(t.project.spec, n.grid),
    l = b({
      set(u) {
        n.symbol.params = u;
      },
      get() {
        return n.symbol.params;
      },
    }),
    i = b({
      set(u) {
        n.symbol.layer = u;
      },
      get() {
        return n.symbol.layer;
      },
    }),
    a = b({
      set(u) {
        n.showStyle = u;
      },
      get() {
        return n.showStyle;
      },
    });
  return {
    editorGridState: s,
    gridLines: o,
    getPlaceablePosition: r,
    dirtyParams: l,
    layerOption: i,
    showStyle: a,
  };
}
function GS(t) {
  for (let e = 2; e < 20; e += 2)
    if (
      t.every(
        (n) =>
          Math.abs(Math.round(n.position.x * e) - n.position.x * e) < 1e-5 &&
          Math.abs(Math.round(n.position.y * e) - n.position.y * e) < 1e-5
      )
    )
      return e / 2;
  return 10;
}
function qS(t) {
  const e = t.at(-1);
  return e
    ? { layer: KS(e), params: e.params }
    : {
        layer: Tt.Auto,
        params: {
          type: pe.Ellipse,
          rx: 0.4,
          ry: 0.4,
          angle: 0,
          fill: "#ffffff",
          stroke: "#000000",
          strokeWidth: 0.02,
        },
      };
}
function KS(t) {
  return Ce(t.layer, di(t.position))
    ? Tt.Auto
    : t.layer === oe.Foreground
    ? Tt.AboveGrid
    : Tt.Default;
}
const XS = ["transform"],
  YS = ["rx", "ry", "fill", "stroke", "stroke-width"],
  JS = ["x", "y", "width", "height", "fill", "stroke", "stroke-width"],
  yr = S({
    __name: "CosmeticSymbolRenderer",
    props: { symbols: {}, selected: {} },
    setup(t) {
      return (e, n) => (
        d(!0),
        C(
          Z,
          null,
          se(e.symbols, ({ position: s, params: o }, r) => {
            var l;
            return (
              d(),
              C(
                "g",
                {
                  key: r,
                  transform: `translate(${s.x} ${s.y}) rotate(${o.angle})`,
                },
                [
                  o.type === "ellipse"
                    ? (d(),
                      C(
                        "ellipse",
                        {
                          key: 0,
                          rx: o.rx,
                          ry: o.ry,
                          fill: o.fill,
                          stroke: o.stroke,
                          "stroke-width": o.strokeWidth,
                        },
                        null,
                        8,
                        YS
                      ))
                    : o.type === "rectangle"
                    ? (d(),
                      C(
                        "rect",
                        {
                          key: 1,
                          x: -o.width / 2,
                          y: -o.height / 2,
                          width: o.width,
                          height: o.height,
                          fill: o.fill,
                          stroke: o.stroke,
                          "stroke-width": o.strokeWidth,
                        },
                        null,
                        8,
                        JS
                      ))
                    : o.type === "text"
                    ? (d(),
                      w(
                        kn,
                        {
                          key: 2,
                          value: o.text.replace(/ /g, " ") || "",
                          "font-size": o.size,
                          fill: o.fill,
                          stroke: o.stroke,
                          "stroke-width": o.strokeWidth,
                          "paint-order": "stroke",
                          "show-caret":
                            (l = e.selected) == null ? void 0 : l.has(s),
                        },
                        null,
                        8,
                        [
                          "value",
                          "font-size",
                          "fill",
                          "stroke",
                          "stroke-width",
                          "show-caret",
                        ]
                      ))
                    : o.type === "arrow"
                    ? (d(),
                      w(
                        Qo,
                        {
                          key: 3,
                          "line-width": o.strokeWidth,
                          color: o.stroke,
                          "end-arrow": "",
                          size: o.headSize,
                          points: [
                            { x: -o.length / 2, y: 0 },
                            { x: o.length / 2, y: 0 },
                          ],
                        },
                        null,
                        8,
                        ["line-width", "color", "size", "points"]
                      ))
                    : z("", !0),
                ],
                8,
                XS
              )
            );
          }),
          128
        )
      );
    },
  });
function ar(t, e) {
  return {
    width: Math.abs(t.width * Math.cos(e) - t.height * Math.sin(e)),
    height: Math.abs(t.width * Math.sin(e) + t.height * Math.cos(e)),
  };
}
function ff(t, e) {
  let n = 0,
    s = 0,
    o = e.size.width,
    r = e.size.height;
  for (const l of t) {
    const i = QS(l);
    (n = Math.min(n, l.position.x - i.width / 2)),
      (o = Math.max(o, l.position.x + i.width / 2)),
      (s = Math.min(s, l.position.y - i.height / 2)),
      (r = Math.max(r, l.position.y + i.height / 2));
  }
  return {
    left: -n,
    right: o - e.size.width,
    top: -s,
    bottom: r - e.size.height,
  };
}
function QS(t) {
  switch (t.params.type) {
    case pe.Rectangle:
      return ar(
        {
          width: t.params.width + t.params.strokeWidth,
          height: t.params.height + t.params.strokeWidth,
        },
        t.params.angle
      );
    case pe.Ellipse:
      return ar(
        {
          width: t.params.rx * 2 + t.params.strokeWidth,
          height: t.params.ry * 2 + t.params.strokeWidth,
        },
        t.params.angle
      );
    case pe.Text: {
      const e = t.params.size * Math.max(1, t.params.text.length) * 0.6;
      return ar({ width: e, height: t.params.size }, t.params.angle);
    }
    case pe.Arrow: {
      const e =
        2 * Math.SQRT1_2 * (t.params.headSize + t.params.strokeWidth / 2);
      return ar({ width: t.params.length, height: e }, t.params.angle);
    }
  }
}
const eI = { key: 0, opacity: "0.25" },
  tI = ["x1", "y1", "x2", "y2", "stroke-width"],
  nI = { key: 0, opacity: "0.5" },
  sI = S({
    __name: "CosmeticSymbolEditor",
    props: { context: {}, symbols: {} },
    setup(t) {
      const e = t,
        n = [oe.Background, oe.Default, oe.Foreground];
      function s(ne) {
        return ne.filter((Q) => !HS(Q));
      }
      const {
          editorGridState: o,
          gridLines: r,
          getPlaceablePosition: l,
          dirtyParams: i,
          layerOption: a,
          showStyle: u,
        } = ZS(e.context, e.symbols),
        p = j(!1),
        m = b(() => e.symbols.length > 0);
      function g(ne) {
        i.value = jS(ne, e.symbols, i.value);
      }
      const v = Xr(e.context.constraint.id, "margins", () => ({
        value: $(e.symbols),
      }));
      ae(
        () => e.symbols,
        () => {
          v.value = $(e.symbols);
        }
      );
      function $(ne) {
        return uf(ff(ne, e.context.project.spec));
      }
      function k(ne) {
        const Q = on.value,
          { params: q } = ne;
        switch (q.type) {
          case pe.Ellipse:
            return {
              position: ne.position,
              layer: ne.layer,
              params: {
                type: q.type,
                rx: q.rx + (q.strokeWidth + Q) / 2,
                ry: q.ry + (q.strokeWidth + Q) / 2,
                angle: q.angle,
                strokeWidth: Q,
                stroke: ee.selectionColor,
                fill: "#0000",
              },
            };
          case pe.Arrow:
            return {
              position: ft(
                ne.position,
                en({ x: (Q * (Math.SQRT2 - 1)) / 2, y: 0 }, wi(q.angle))
              ),
              layer: ne.layer,
              params: {
                type: q.type,
                length: q.length + (1 + Math.SQRT2) * Q,
                headSize: q.headSize + Q,
                angle: q.angle,
                strokeWidth: q.strokeWidth + Q * 2,
                stroke: ee.selectionColor,
                fill: "#0000",
              },
            };
          case pe.Rectangle:
            return {
              position: ne.position,
              layer: ne.layer,
              params: {
                type: q.type,
                width: q.width + q.strokeWidth + Q,
                height: q.height + q.strokeWidth + Q,
                angle: q.angle,
                strokeWidth: Q,
                stroke: ee.selectionColor,
                fill: "#0000",
              },
            };
          case pe.Text:
            return {
              position: ne.position,
              layer: ne.layer,
              params: {
                type: pe.Text,
                text: q.text,
                size: q.size,
                angle: q.angle,
                strokeWidth: 2 * Q + q.strokeWidth,
                stroke: ee.selectionColor,
                fill: "transparent",
              },
            };
        }
      }
      function M(ne, Q) {
        switch (ne) {
          case Tt.Auto:
            return di(Q);
          case Tt.AboveGrid:
            return oe.Foreground;
          default:
            return oe.Default;
        }
      }
      const P = j(new Br()),
        x = b(() => e.symbols.filter((ne) => P.value.has(ne.position))),
        A = b(() => {
          for (const ne of x.value)
            if (ne.params.type === pe.Text) return ne.params.text;
          return "";
        }),
        O = b(() => {
          const ne = { ...Xc(), deleteButton: x.value.length > 0 };
          return (
            x.value.filter((q) => q.params.type === pe.Text).length > 0 &&
              (ne.type = Ke.CosmeticText),
            ne
          );
        });
      function V() {
        P.value.clear();
      }
      function I(ne) {
        if ((P.value.add(ne.position), P.value.size === 1))
          switch (((i.value = ue(ne.params)), ne.layer)) {
            case di(ne.position):
              a.value = Tt.Auto;
              break;
            case oe.Foreground:
              a.value = Tt.AboveGrid;
              break;
            case oe.Default:
              a.value = Tt.Default;
              break;
            default:
              a.value = Tt.Auto;
          }
      }
      ae(
        () => e.symbols,
        (ne) => {
          for (const Q of P.value)
            ne.some((q) => Ce(q.position, Q)) || P.value.delete(Q);
        }
      );
      function U() {
        P.value.clear();
        for (const ne of e.symbols) I(ne);
      }
      function D(ne, Q = !1) {
        let q = io(ne, e.symbols);
        if (!q) {
          (q = { position: ne, layer: M(a.value, ne), params: ue(i.value) }),
            !p.value && q.params.type === pe.Text && (q.params.text = "");
          const le = [...e.symbols, q];
          e.context.updateConstraintAppearance({ symbols: le }, "add");
        }
        Q || V(), x.value.includes(q) ? P.value.delete(q.position) : I(q);
      }
      function N(ne) {
        i.value.type === pe.Text && (i.value.text = ne);
        const Q = x.value.filter((le) => le.params.type === pe.Text);
        if (Q.every((le) => le.params.text === ne)) return;
        const q = ue(e.symbols);
        for (const le of Q) {
          const De = q.find((Ct) => Ce(Ct.position, le.position));
          De && (De.params.text = ne);
        }
        e.context.updateConstraintAppearance({ symbols: q }, "update");
      }
      function E(ne, Q, q) {
        const le = i.value;
        if (!(ne in le) || ((le[ne] = Q), P.value.size === 0)) return;
        const De = e.symbols.map((Ct) => {
          if (!(ne in Ct.params) || !P.value.has(Ct.position)) return Ct;
          const Ps = { ...Ct.params, [ne]: Q };
          return { position: Ct.position, layer: Ct.layer, params: Ps };
        });
        e.context.updateConstraintAppearance({ symbols: De }, "update", q);
      }
      function R(ne) {
        if (((a.value = ne), P.value.size === 0)) return;
        const Q = e.symbols.map((q) =>
          P.value.has(q.position) ? { ...q, layer: M(a.value, q.position) } : q
        );
        e.context.updateConstraintAppearance({ symbols: Q }, "update");
      }
      function W(ne, Q) {
        const q = ne - i.value.angle;
        i.value.angle = ne;
        const le = e.symbols.map((De) =>
          P.value.has(De.position)
            ? {
                position: De.position,
                layer: De.layer,
                params: { ...De.params, angle: De.params.angle + q },
              }
            : De
        );
        e.context.updateConstraintAppearance({ symbols: le }, "update", Q);
      }
      function T(ne) {
        const Q = s(mn(e.symbols, ne));
        e.context.updateConstraintAppearance({ symbols: Q }, "delete");
      }
      function Y(ne) {
        const Q = io(ne, e.symbols);
        Q && T([Q]);
      }
      function J() {
        T(x.value);
      }
      const {
          position: re,
          pointerAction: ce,
          deleting: ge,
          placing: de,
        } = ml({
          createOrSelectClue: D,
          deselect: V,
          selectAll: U,
          updateClueValue: N,
          deleteAt: Y,
          deleteSelectedClues: J,
          getClueAt: (ne) => io(ne, e.symbols),
          getPlaceablePosition: l,
        }),
        ze = b(() =>
          e.symbols.map((ne) =>
            ne.params.type === pe.Text
              ? {
                  position: ne.position,
                  layer: ne.layer,
                  params: { ...ne.params, text: ne.params.text },
                }
              : ne
          )
        ),
        Qs = b(() => x.value.map((ne) => k(ne))),
        eo = b(() => {
          if (ge.value || !re.value || io(re.value, e.symbols)) return [];
          const ne = ue(i.value);
          return (
            ne.type === pe.Text &&
              (ne.text === "" || !p.value) &&
              (ne.text = "Abc"),
            [{ position: re.value, layer: oe.Foreground, params: ne }]
          );
        }),
        Un = b(() => {
          if (!ge.value || !re.value) return;
          const ne = io(re.value, e.symbols);
          if (!ne) return;
          let Q;
          switch (ne.params.type) {
            case pe.Ellipse:
              Q = Math.max(ne.params.rx, ne.params.ry);
              break;
            case pe.Rectangle:
              Q = Math.max(ne.params.width / 2, ne.params.height / 2);
              break;
            case pe.Text:
              Q = ne.params.size * 0.75;
              break;
            case pe.Arrow:
              Q = Math.max(ne.params.length / 2, ne.params.headSize);
              break;
          }
          return { x: ne.position.x, y: ne.position.y, scale: Q };
        });
      return (ne, Q) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              yt,
              {
                class: "CornerGeometryEditor",
                context: ne.context,
                "show-style-controls": y(u),
                onToggleStyleControls: Q[17] || (Q[17] = (q) => (u.value = q)),
              },
              {
                properties: f(() => [
                  c(Yt, null, {
                    default: f(() => [
                      c(
                        te,
                        {
                          toggleable: "",
                          active: y(i).type === y(pe).Ellipse,
                          onClick: Q[0] || (Q[0] = (q) => g(y(pe).Ellipse)),
                        },
                        {
                          default: f(() => Q[18] || (Q[18] = [F(" Circle ")])),
                          _: 1,
                        },
                        8,
                        ["active"]
                      ),
                      c(
                        te,
                        {
                          toggleable: "",
                          active: y(i).type === y(pe).Rectangle,
                          onClick: Q[1] || (Q[1] = (q) => g(y(pe).Rectangle)),
                        },
                        {
                          default: f(
                            () => Q[19] || (Q[19] = [F(" Rectangle ")])
                          ),
                          _: 1,
                        },
                        8,
                        ["active"]
                      ),
                      c(
                        te,
                        {
                          toggleable: "",
                          active: y(i).type === y(pe).Text,
                          onClick: Q[2] || (Q[2] = (q) => g(y(pe).Text)),
                        },
                        {
                          default: f(() => Q[20] || (Q[20] = [F(" Text ")])),
                          _: 1,
                        },
                        8,
                        ["active"]
                      ),
                      c(
                        te,
                        {
                          toggleable: "",
                          active: y(i).type === y(pe).Arrow,
                          onClick: Q[3] || (Q[3] = (q) => g(y(pe).Arrow)),
                        },
                        {
                          default: f(() => Q[21] || (Q[21] = [F(" Arrow ")])),
                          _: 1,
                        },
                        8,
                        ["active"]
                      ),
                    ]),
                    _: 1,
                  }),
                  y(i).type === y(pe).Text
                    ? (d(),
                      w(
                        ut,
                        { key: 0 },
                        {
                          default: f(() => [
                            c(
                              at,
                              {
                                checked: p.value,
                                "onUpdate:checked":
                                  Q[4] || (Q[4] = (q) => (p.value = q)),
                              },
                              null,
                              8,
                              ["checked"]
                            ),
                            Q[22] ||
                              (Q[22] = h(
                                "span",
                                null,
                                "Re-use last set value",
                                -1
                              )),
                          ]),
                          _: 1,
                        }
                      ))
                    : z("", !0),
                  c(cf, { grid: y(o) }, null, 8, ["grid"]),
                ]),
                appearance: f(() => [
                  y(i).type === y(pe).Rectangle
                    ? (d(),
                      w(
                        hn,
                        {
                          key: 0,
                          label: "Width",
                          value: y(i).width,
                          onInput:
                            Q[5] || (Q[5] = (q, le) => E("width", q, le)),
                        },
                        null,
                        8,
                        ["value"]
                      ))
                    : z("", !0),
                  y(i).type === y(pe).Rectangle
                    ? (d(),
                      w(
                        hn,
                        {
                          key: 1,
                          label: "Height",
                          value: y(i).height,
                          onInput:
                            Q[6] || (Q[6] = (q, le) => E("height", q, le)),
                        },
                        null,
                        8,
                        ["value"]
                      ))
                    : z("", !0),
                  y(i).type === y(pe).Ellipse
                    ? (d(),
                      w(
                        Fr,
                        {
                          key: 2,
                          label: "Radius 1",
                          radius: y(i).rx,
                          onInput: Q[7] || (Q[7] = (q, le) => E("rx", q, le)),
                        },
                        null,
                        8,
                        ["radius"]
                      ))
                    : z("", !0),
                  y(i).type === y(pe).Ellipse
                    ? (d(),
                      w(
                        Fr,
                        {
                          key: 3,
                          label: "Radius 2",
                          radius: y(i).ry,
                          onInput: Q[8] || (Q[8] = (q, le) => E("ry", q, le)),
                        },
                        null,
                        8,
                        ["radius"]
                      ))
                    : z("", !0),
                  y(i).type === y(pe).Text
                    ? (d(),
                      w(
                        hn,
                        {
                          key: 4,
                          label: "Size",
                          value: y(i).size,
                          onInput: Q[9] || (Q[9] = (q, le) => E("size", q, le)),
                        },
                        null,
                        8,
                        ["value"]
                      ))
                    : z("", !0),
                  y(i).type === y(pe).Arrow
                    ? (d(),
                      w(
                        hn,
                        {
                          key: 5,
                          label: "Length",
                          value: y(i).length,
                          onInput:
                            Q[10] || (Q[10] = (q, le) => E("length", q, le)),
                        },
                        null,
                        8,
                        ["value"]
                      ))
                    : z("", !0),
                  y(i).type === y(pe).Arrow
                    ? (d(),
                      w(
                        hn,
                        {
                          key: 6,
                          label: "Arrow size",
                          value: y(i).headSize,
                          onInput:
                            Q[11] || (Q[11] = (q, le) => E("headSize", q, le)),
                        },
                        null,
                        8,
                        ["value"]
                      ))
                    : z("", !0),
                  c(
                    TS,
                    {
                      value: y(i).angle,
                      onInput: Q[12] || (Q[12] = (q, le) => W(q, le)),
                    },
                    null,
                    8,
                    ["value"]
                  ),
                  c(dl, null, {
                    default: f(() => [
                      c(
                        Cn,
                        {
                          label: "Fill color",
                          color: y(i).fill,
                          onInput:
                            Q[13] || (Q[13] = (q, le) => E("fill", q, le)),
                        },
                        null,
                        8,
                        ["color"]
                      ),
                      c(
                        Cn,
                        {
                          label: "Stroke color",
                          color: y(i).stroke,
                          onInput:
                            Q[14] || (Q[14] = (q, le) => E("stroke", q, le)),
                        },
                        null,
                        8,
                        ["color"]
                      ),
                    ]),
                    _: 1,
                  }),
                  c(
                    pl,
                    {
                      label: "Stroke width",
                      thickness: y(i).strokeWidth,
                      onInput:
                        Q[15] || (Q[15] = (q, le) => E("strokeWidth", q, le)),
                    },
                    null,
                    8,
                    ["thickness"]
                  ),
                  c(
                    ve,
                    { label: "Layer" },
                    {
                      default: f(() => [
                        c(
                          qs,
                          {
                            "model-value": y(a),
                            "dropdown-align": "left",
                            options: y(WS),
                            "onUpdate:modelValue": R,
                          },
                          null,
                          8,
                          ["model-value", "options"]
                        ),
                      ]),
                      _: 1,
                    }
                  ),
                ]),
                buttons: f(() => [
                  c(
                    Ds,
                    {
                      mode: y(ce),
                      "onUpdate:mode":
                        Q[16] ||
                        (Q[16] = (q) => (Rn(ce) ? (ce.value = q) : null)),
                      "can-delete": m.value,
                    },
                    null,
                    8,
                    ["mode", "can-delete"]
                  ),
                ]),
                _: 1,
              },
              8,
              ["context", "show-style-controls"]
            ),
            c(
              ct,
              { layer: y(oe).Grid },
              {
                default: f(() => [
                  y(o).display
                    ? (d(),
                      C("g", eI, [
                        (d(!0),
                        C(
                          Z,
                          null,
                          se(
                            y(r),
                            (q, le) => (
                              d(),
                              C(
                                "line",
                                {
                                  key: le,
                                  x1: q[0].x,
                                  y1: q[0].y,
                                  x2: q[1].x,
                                  y2: q[1].y,
                                  stroke: "#000",
                                  "stroke-width": y(Sp),
                                },
                                null,
                                8,
                                tI
                              )
                            )
                          ),
                          128
                        )),
                      ]))
                    : z("", !0),
                ]),
                _: 1,
              },
              8,
              ["layer"]
            ),
            (d(),
            C(
              Z,
              null,
              se(n, (q) =>
                c(
                  ct,
                  { key: q, layer: q },
                  {
                    default: f(() => [
                      c(
                        yr,
                        { symbols: Qs.value.filter((le) => le.layer === q) },
                        null,
                        8,
                        ["symbols"]
                      ),
                      c(
                        yr,
                        {
                          symbols: ze.value.filter((le) => le.layer === q),
                          selected: P.value,
                        },
                        null,
                        8,
                        ["symbols", "selected"]
                      ),
                      y(de)
                        ? (d(),
                          C("g", nI, [
                            c(
                              yr,
                              {
                                symbols: eo.value.filter(
                                  (le) => le.layer === q
                                ),
                              },
                              null,
                              8,
                              ["symbols"]
                            ),
                          ]))
                        : z("", !0),
                    ]),
                    _: 2,
                  },
                  1032,
                  ["layer"]
                )
              ),
              64
            )),
            c(
              ct,
              { layer: y(oe).Foreground },
              {
                default: f(() => [
                  Un.value
                    ? (d(),
                      w(
                        hl,
                        {
                          key: 0,
                          x: Un.value.x,
                          y: Un.value.y,
                          scale: Un.value.scale,
                        },
                        null,
                        8,
                        ["x", "y", "scale"]
                      ))
                    : z("", !0),
                ]),
                _: 1,
              },
              8,
              ["layer"]
            ),
            c(y(jn), { "current-value": A.value, mode: O.value }, null, 8, [
              "current-value",
              "mode",
            ]),
          ],
          64
        )
      );
    },
  }),
  oI = {
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-miterlimit": "1.5",
  },
  rI = S({
    __name: "CosmeticsPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "svg",
          oI,
          n[0] ||
            (n[0] = [
              Ro(
                '<path d="M5.5 5.457h9v9.086h-9zM1 5.457h18M1 14.543h18M5.5 1v18M14.5 1v18" fill="none" stroke="#000"></path><circle cx="14.5" cy="10" r="2.5"></circle><path d="M5.5 7.5 3 10l2.5 2.5L8 10 5.5 7.5Z" fill="#ffd000" stroke="#000"></path><path d="M10 4.651c.421-1.28 1.263-1.28 1.684-.88.421.4.421 1.2 0 2-.295.6-1.052 1.2-1.684 1.6-.632-.4-1.389-1-1.684-1.6-.421-.8-.421-1.6 0-2 .421-.4 1.263-.4 1.684.88Z" fill="#ff83fb"></path><path d="M10 2.909a1.924 1.924 0 0 0-.513-.272 1.817 1.817 0 0 0-1.86.409c-.671.638-.868 1.904-.203 3.179.368.736 1.267 1.501 2.041 1.991a1 1 0 0 0 1.07 0c.776-.491 1.676-1.258 2.042-1.995.664-1.271.467-2.537-.204-3.175a1.817 1.817 0 0 0-1.86-.409 1.924 1.924 0 0 0-.513.272Zm0 1.742c.421-1.28 1.263-1.28 1.684-.88.421.4.421 1.2 0 2-.295.6-1.052 1.2-1.684 1.6-.632-.4-1.389-1-1.684-1.6-.421-.8-.421-1.6 0-2 .421-.4 1.263-.4 1.684.88Z"></path><path d="m10 12.5.449 1.382h1.453l-1.175.854.449 1.382L10 15.264l-1.176.854.449-1.382-1.175-.854h1.453L10 12.5Z" fill="#00b2ff"></path><path d="M10.951 12.191a1 1 0 0 0-1.902 0l-.225.691h-.726a1 1 0 0 0-.588 1.809l.588.427-.225.691a1 1 0 0 0 1.539 1.118L10 16.5l.588.427a1 1 0 0 0 1.539-1.118l-.225-.691.588-.427a1 1 0 0 0-.588-1.809h-.726l-.225-.691ZM10 12.5l.449 1.382h1.453l-1.175.854.449 1.382L10 15.264l-1.176.854.449-1.382-1.175-.854h1.453L10 12.5Z"></path>',
                7
              ),
            ])
        )
      );
    },
  });
function ur(t, e) {
  const n = e === oe.Default ? [e, void 0] : [e];
  return {
    layer: e,
    component: c(
      yr,
      { symbols: t.symbols.filter((s) => n.includes(s.layer)) },
      null
    ),
  };
}
_e({
  type: _.CosmeticSymbol,
  label: "Cosmetic symbols",
  preview: rI,
  ignoredBySolver: !0,
  gridUnbound: !0,
  margins: (t, e) => ff(t.symbols, e),
  renderers: (t) => [
    ur(t, oe.Background),
    ur(t, oe.Default),
    ur(t, oe.Grid),
    ur(t, oe.Foreground),
  ],
  editor: xe({
    editor: { component: sI, props: (t) => ({ symbols: t.symbols }) },
    updateStyleFunc: (t, e) => {
      t.symbols = ue(e.symbols);
    },
  }),
});
const lI = S({
  components: { FormRow: ve, TextInput: vt },
  props: {
    label: { type: String, required: !0 },
    value: { type: String, required: !0 },
  },
  emits: { "update:value": (t, e) => !0 },
  data() {
    return { actionId: fe(), internalValue: "" };
  },
  watch: {
    value: {
      immediate: !0,
      handler(t) {
        this.internalValue = t;
      },
    },
  },
  methods: {
    onChange(t) {
      this.$emit("update:value", t, this.actionId);
    },
  },
});
function iI(t, e, n, s, o, r) {
  const l = H("TextInput"),
    i = H("FormRow");
  return (
    d(),
    w(
      i,
      { label: `${t.label}:` },
      {
        default: f(() => [
          c(
            l,
            {
              value: t.internalValue,
              "onUpdate:value": e[0] || (e[0] = (a) => (t.internalValue = a)),
              onChange: t.onChange,
            },
            null,
            8,
            ["value", "onChange"]
          ),
          G(t.$slots, "default", {}, void 0, !0),
        ]),
        _: 3,
      },
      8,
      ["label"]
    )
  );
}
const aI = B(lI, [
    ["render", iI],
    ["__scopeId", "data-v-bf1fb427"],
  ]),
  uI = { class: "addTab" },
  cI = { key: 0 },
  dI = S({
    __name: "GroupsTabStrip",
    props: { groups: {}, activeIndex: {} },
    emits: ["update:activeIndex", "add"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = j(),
        r = b(() =>
          n.groups.map((a, u) => ({
            id: u,
            label: n.groups.length < 4 ? `Group ${u + 1}` : String(u + 1),
          }))
        );
      ae(n.groups, () => {
        n.activeIndex >= n.groups.length &&
          s("update:activeIndex", n.groups.length - 1);
      });
      function l(a) {
        s("update:activeIndex", Number(a));
      }
      function i() {
        s("add"),
          wn(() => {
            var a;
            (a = o.value) == null || a.scrollIntoView(n.groups.length - 1);
          });
      }
      return (a, u) => (
        d(),
        w(
          be,
          { class: "GroupsTabStrip" },
          {
            default: f(() => [
              r.value.length > 0
                ? (d(),
                  w(
                    ts,
                    {
                      key: 0,
                      ref_key: "el",
                      ref: o,
                      class: "mainTabs",
                      "active-tab": a.activeIndex,
                      tabs: r.value,
                      compact: "",
                      "onUpdate:activeTab": l,
                    },
                    null,
                    8,
                    ["active-tab", "tabs"]
                  ))
                : z("", !0),
              c(
                ts,
                {
                  class: Ae({ small: r.value.length > 0 }),
                  tabs: [{ id: "add", label: "+" }],
                  "active-tab": "",
                  "onUpdate:activeTab": i,
                },
                {
                  default: f(() => [
                    h("div", uI, [
                      c(es),
                      r.value.length === 0
                        ? (d(), C("span", cI, " Add group "))
                        : z("", !0),
                    ]),
                  ]),
                  _: 1,
                },
                8,
                ["class"]
              ),
            ]),
            _: 1,
          }
        )
      );
    },
  }),
  pI = B(dI, [["__scopeId", "data-v-4ebeee67"]]),
  fI = { key: 0, class: "groupControls" },
  hI = { key: 0 },
  mI = S({
    __name: "RawEditor",
    props: { context: {}, groups: {} },
    setup(t) {
      const e = t,
        n = j([]),
        s = j(0),
        o = b(() => n.value[s.value]),
        r = b(() => mn(n.value, [o.value]).flatMap((x) => x.cells));
      ae(
        () => e.groups,
        () => {
          Ce(n.value, e.groups) ||
            ((n.value = ue(e.groups)), o.value || (s.value = 0));
        },
        { immediate: !0, deep: !0 }
      );
      const l = b(() => {
        var P;
        return (P = n.value[s.value]) == null ? void 0 : P.value;
      });
      function i(P, x) {
        const A = n.value.map((O, V) =>
          V === s.value ? { ...O, value: P } : O
        );
        e.context.updateConstraint({ groups: A }, "custom:updateValue", x);
      }
      function a() {
        n.value.push({ cells: [], value: "" }), (s.value = n.value.length - 1);
      }
      function u() {
        const P = mn(n.value, [o.value]);
        e.context.updateConstraint({ groups: P }, "custom:removeGroup");
      }
      function p(P) {
        return e.context.helpers.cellIds.getCellCenterFromId(P);
      }
      const m = j(fe()),
        g = j(!1);
      Vn({ onDragStart: v, onDragMove: $ });
      function v(P) {
        P.cellId === void 0 ||
          !o.value ||
          ((m.value = fe()),
          (g.value = o.value.cells.includes(P.cellId)),
          k(P.cellId));
      }
      function $(P) {
        P.cellId === void 0 || !o.value || k(P.cellId);
      }
      function k(P) {
        const x = o.value.cells;
        let A = x;
        if (
          (g.value ? (A = mn(x, [P])) : x.includes(P) || (A = x.concat(P)),
          Ce(x, A))
        )
          return;
        const O = n.value.map((V, I) =>
          I === s.value ? { ...V, cells: A } : V
        );
        e.context.updateConstraint(
          { groups: O },
          g.value ? "delete" : "add",
          m.value
        );
      }
      const M = b(() => {
        const P = Gt(ee.selectionColor);
        return Hs({ ...P, alpha: P.alpha * 0.5 });
      });
      return (P, x) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              yt,
              { class: "RawEditor", context: P.context },
              {
                properties: f(() => [
                  c(
                    pI,
                    {
                      "active-index": s.value,
                      "onUpdate:activeIndex":
                        x[0] || (x[0] = (A) => (s.value = A)),
                      groups: n.value,
                      onAdd: a,
                    },
                    null,
                    8,
                    ["active-index", "groups"]
                  ),
                  l.value !== void 0
                    ? (d(),
                      C("div", fI, [
                        c(
                          aI,
                          {
                            label: "Value",
                            value: l.value,
                            "onUpdate:value": i,
                          },
                          {
                            default: f(() => [
                              c(dt, null, {
                                default: f(
                                  () =>
                                    x[1] ||
                                    (x[1] = [
                                      F(
                                        " Use this to assign a value to the selected group if the custom constraint requires it. "
                                      ),
                                    ])
                                ),
                                _: 1,
                              }),
                            ]),
                            _: 1,
                          },
                          8,
                          ["value"]
                        ),
                        c(Jr, { onClick: u }),
                      ]))
                    : z("", !0),
                ]),
                _: 1,
              },
              8,
              ["context"]
            ),
            c(
              ct,
              { layer: y(oe).AboveDigits },
              {
                default: f(() => [
                  o.value
                    ? (d(),
                      C("g", hI, [
                        c(Vs, { cells: r.value, fill: M.value }, null, 8, [
                          "cells",
                          "fill",
                        ]),
                        c(
                          Vs,
                          { cells: o.value.cells, fill: y(ee).selectionColor },
                          null,
                          8,
                          ["cells", "fill"]
                        ),
                        (d(!0),
                        C(
                          Z,
                          null,
                          se(
                            o.value.cells,
                            (A, O) => (
                              d(),
                              w(
                                kn,
                                St({ key: A, value: O, ref_for: !0 }, p(A), {
                                  "font-size": 0.5,
                                  stroke: "#fff",
                                  "stroke-width": "0.05",
                                  "paint-order": "stroke",
                                }),
                                null,
                                16,
                                ["value"]
                              )
                            )
                          ),
                          128
                        )),
                      ]))
                    : z("", !0),
                ]),
                _: 1,
              },
              8,
              ["layer"]
            ),
            c(y(jn)),
          ],
          64
        )
      );
    },
  }),
  gI = B(mI, [["__scopeId", "data-v-cc4f2710"]]),
  vI = S({
    __name: "CustomConstraintEditor",
    props: { context: {}, input: {}, style: {}, definition: {} },
    emits: ["openCustomConstraintEditor"],
    setup(t, { emit: e }) {
      const n = t,
        s = e,
        o = b(() => n.definition.input);
      Xt(() => {
        n.definition.backend.code === "" && s("openCustomConstraintEditor");
      });
      const r = b(() => [
          ...o.value.map((g) => ({ id: g.id, label: g.label })),
        ]),
        l = j("");
      ae(
        r,
        () => {
          r.value.length &&
            !r.value.find((g) => g.id === l.value) &&
            (l.value = r.value[0].id);
        },
        { immediate: !0 }
      );
      const i = b(() => o.value.find((g) => g.id === l.value)),
        a = b(() => {
          const g = i.value;
          return g ? n.input[g.id] || [] : [];
        });
      function u(g, v, $) {
        const k = i.value;
        if (k) {
          switch (k.params.type) {
            case "raw":
              g = g.groups;
              break;
          }
          n.context.updateConstraint({ [k.id]: g }, v, $);
        }
      }
      function p(g, v, $) {
        const k = i.value;
        k && n.context.updateConstraintAppearance({ [k.id]: g }, v, $);
      }
      const m = b(() => ({
        ...n.context,
        updateConstraint: u,
        updateConstraintAppearance: p,
      }));
      return (g, v) => {
        var $;
        return (
          d(),
          C("div", null, [
            (($ = i.value) == null ? void 0 : $.params.type) === "raw"
              ? (d(),
                w(gI, { key: 0, context: m.value, groups: a.value }, null, 8, [
                  "context",
                  "groups",
                ]))
              : (d(),
                w(yt, { key: 1, context: m.value }, null, 8, ["context"])),
          ])
        );
      };
    },
  }),
  yI = B(vI, [["__scopeId", "data-v-f6280045"]]),
  CI = { viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg" },
  wI = S({
    __name: "CustomPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "svg",
          CI,
          n[0] ||
            (n[0] = [
              h(
                "path",
                {
                  d: "M1.07 9.41c.37-.01.67-.1.9-.3.24-.19.4-.45.47-.78.08-.33.12-.9.12-1.7 0-.8.02-1.33.04-1.58.05-.4.13-.73.24-.97.12-.25.27-.44.44-.59.17-.14.4-.26.66-.33.19-.05.48-.07.9-.07h.4v1.13H5c-.5 0-.83.09-.99.26-.16.18-.24.59-.24 1.21 0 1.26-.03 2.05-.08 2.38-.09.52-.24.91-.44 1.19-.21.28-.54.52-.99.74.53.22.91.56 1.15 1.01.24.45.36 1.2.36 2.23 0 .93 0 1.49.03 1.67.03.32.13.55.29.68.15.13.46.2.91.2h.23v1.13h-.4c-.48 0-.82-.04-1.03-.12-.3-.11-.56-.29-.76-.54-.2-.24-.33-.56-.4-.94-.05-.37-.08-1-.09-1.86a9.5 9.5 0 0 0-.12-1.8 1.4 1.4 0 0 0-.47-.78c-.23-.19-.53-.29-.9-.3V9.41ZM18.93 9.41c-.37-.01-.67-.1-.9-.3a1.37 1.37 0 0 1-.47-.78 8.8 8.8 0 0 1-.12-1.7c0-.8-.02-1.33-.04-1.58-.05-.4-.13-.73-.24-.97a1.75 1.75 0 0 0-.44-.59c-.17-.14-.4-.26-.66-.33a3.89 3.89 0 0 0-.9-.07h-.4v1.13H15c.5 0 .83.09.99.26.16.18.24.59.24 1.21 0 1.26.03 2.05.08 2.38.09.52.24.91.44 1.19.21.28.54.52.99.74a2.2 2.2 0 0 0-1.15 1.01 5.1 5.1 0 0 0-.36 2.23c0 .93 0 1.49-.03 1.67-.03.32-.13.55-.29.68-.15.13-.46.2-.91.2h-.23v1.13h.4c.48 0 .82-.04 1.03-.12.3-.11.56-.29.76-.54.2-.24.33-.56.4-.94.05-.37.08-1 .09-1.86 0-.86.04-1.46.12-1.8.08-.32.23-.58.47-.78.23-.19.53-.29.9-.3V9.41ZM7.88 6.97v-.85h.73v.85h-.73Zm-.94 6.83.14-.62c.15.03.27.05.35.05.15 0 .26-.05.34-.15.07-.1.1-.34.1-.74V7.77h.74v4.58c0 .54-.07.91-.2 1.12-.18.27-.48.41-.89.41-.2 0-.39-.03-.58-.08ZM9.45 10.82l.73-.11c.04.29.15.51.34.67.18.15.44.23.78.23s.59-.07.75-.2c.17-.15.25-.3.25-.5 0-.16-.07-.29-.22-.38-.1-.07-.35-.15-.75-.25a6.76 6.76 0 0 1-1.12-.36 1.08 1.08 0 0 1-.64-1c0-.19.04-.37.13-.53.1-.17.21-.3.37-.41.11-.09.27-.16.46-.22a2.5 2.5 0 0 1 1.53.06c.27.1.46.23.58.4.12.17.2.4.25.67l-.72.1a.78.78 0 0 0-.28-.52 1.04 1.04 0 0 0-.67-.19c-.34 0-.58.06-.72.17-.15.1-.22.24-.22.39 0 .1.03.18.1.26.05.08.15.14.27.2l.65.18a9 9 0 0 1 1.1.34c.2.1.36.22.48.4.12.16.18.37.18.62s-.08.48-.22.7c-.14.21-.35.38-.62.5s-.57.17-.92.17c-.56 0-.99-.11-1.29-.35-.3-.23-.48-.58-.56-1.04Z",
                },
                null,
                -1
              ),
            ])
        )
      );
    },
  });
_e({
  type: _.Custom,
  label: (t) => t.definition.name,
  preview: wI,
  editor: xe({
    editor: {
      component: yI,
      props: (t) => ({
        input: t.input,
        style: t.style,
        definition: t.definition,
      }),
    },
    updateFunc: (t, e) => {
      for (const [n, s] of Object.entries(e)) t.input[n] = ue(s);
    },
    updateStyleFunc: (t, e) => {
      for (const [n, s] of Object.entries(e)) t.style[n] = ue(s);
    },
  }),
});
const bI = {
    class: "DiagonalPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "#000",
    fill: "none",
  },
  kI = ["x1", "x2", "stroke-width"],
  _I = ["y1", "y2", "stroke-width"],
  $I = ["stroke"],
  hf = S({
    __name: "DiagonalPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      const e = t,
        n = b(() =>
          e.constraint.type === _.DiagonalPlus
            ? { x1: 1, y1: 19, x2: 19, y2: 1 }
            : { x1: 1, y1: 1, x2: 19, y2: 19 }
        );
      return (s, o) => (
        d(),
        C("svg", bI, [
          o[0] ||
            (o[0] = h(
              "rect",
              { x: "1", y: "1", width: "18", height: "18" },
              null,
              -1
            )),
          (d(),
          C(
            Z,
            null,
            se([3, 6], (r) =>
              h(
                "line",
                {
                  key: r,
                  x1: r * 2 + 1,
                  x2: r * 2 + 1,
                  y1: 1,
                  y2: 19,
                  "stroke-width": r % 3 === 0 ? 1 : 0.25,
                },
                null,
                8,
                kI
              )
            ),
            64
          )),
          (d(),
          C(
            Z,
            null,
            se([3, 6], (r) =>
              h(
                "line",
                {
                  key: r,
                  y1: r * 2 + 1,
                  y2: r * 2 + 1,
                  x1: 1,
                  x2: 19,
                  "stroke-width": r % 3 === 0 ? 1 : 0.25,
                },
                null,
                8,
                _I
              )
            ),
            64
          )),
          h(
            "line",
            St(n.value, { stroke: s.constraint.style.color }),
            null,
            16,
            $I
          ),
        ])
      );
    },
  }),
  SI = S({
    __name: "DiagonalRenderer",
    props: { diagonal: {}, style: {} },
    setup(t) {
      const e = t,
        { spec: n } = Qe(et).value,
        s = b(() => {
          const o = e.style.thickness;
          return e.diagonal === Se.PositiveDiagonal
            ? {
                stroke: e.style.color,
                "stroke-width": o,
                x1: o / 2,
                y1: n.size.height - o / 2,
                x2: n.size.width - o / 2,
                y2: o / 2,
              }
            : {
                stroke: e.style.color,
                "stroke-width": o,
                x1: o / 2,
                y1: o / 2,
                x2: n.size.width - o / 2,
                y2: n.size.height - o / 2,
              };
        });
      return (o, r) => (
        d(), C("line", St(s.value, { "stroke-linecap": "round" }), null, 16)
      );
    },
  });
function mf(t) {
  const e =
    t.type === _.DiagonalPlus ? Se.PositiveDiagonal : Se.NegativeDiagonal;
  return [
    {
      layer: oe.Default,
      component: c(SI, { diagonal: e, style: t.style }, null),
    },
  ];
}
const gf = xe({
  editor: { component: ca },
  appearanceForm: {
    props: (t) => ({
      properties: [
        { type: "color", name: "color", label: "Color", value: t.style.color },
        {
          type: "lineWidth",
          name: "thickness",
          label: "Thickness",
          value: t.style.thickness,
        },
      ],
    }),
  },
});
_e({
  type: _.DiagonalPlus,
  label: "Positive diagonal",
  preview: hf,
  selectable: !1,
  unique: !0,
  renderers: mf,
  editor: gf,
});
_e({
  type: _.DiagonalMinus,
  label: "Negative diagonal",
  preview: hf,
  selectable: !1,
  unique: !0,
  renderers: mf,
  editor: gf,
});
var $n = ((t) => (
  (t[(t.Top = 0)] = "Top"),
  (t[(t.Right = 1)] = "Right"),
  (t[(t.Bottom = 2)] = "Bottom"),
  (t[(t.Left = 3)] = "Left"),
  t
))($n || {});
function II(t, e) {
  return t < 0.5
    ? e < t
      ? 0
      : 1 - e < t
      ? 2
      : 3
    : e < 1 - t
    ? 0
    : 1 - e < 1 - t
    ? 2
    : 1;
}
const xI = ["transform"],
  Bo = S({
    __name: "EdgeRenderer",
    props: { edgeClues: {} },
    setup(t) {
      const e = t,
        { helpers: n } = Qe(et).value,
        s = b(() =>
          e.edgeClues.map((o) => ({
            position: n.edgeIds.getCoordsFromId(o.edge),
            item: o,
          }))
        );
      return (o, r) => (
        d(!0),
        C(
          Z,
          null,
          se(
            s.value,
            (l, i) => (
              d(),
              C(
                "g",
                {
                  key: i,
                  transform: `translate(${l.position.x} ${l.position.y})`,
                },
                [G(o.$slots, "default", St({ ref_for: !0 }, l.item))],
                8,
                xI
              )
            )
          ),
          128
        )
      );
    },
  }),
  DI = ["stroke", "stroke-width", "r"],
  MI = ["transform"],
  ma = S({
    __name: "EdgeGeometryEditor",
    props: {
      context: {},
      edgeClues: {},
      defaultValue: { type: [String, Function], default: "" },
      highlightRadius: { default: 0.16 },
      inputMode: { default: void 0 },
    },
    setup(t) {
      const e = t;
      function n(D) {
        if (typeof e.defaultValue == "string") return e.defaultValue;
        const N = e.context.helpers.geometry.getCellsTouchingEdge(D),
          E = e.context.project.cells[N[0]].value,
          R = e.context.project.cells[N[1]].value;
        return e.defaultValue(E, R);
      }
      function s(D) {
        return e.edgeClues.find((N) => N.edge === D);
      }
      function o(D) {
        if (D.outside) return;
        const N = II(D.offsetX, D.offsetY),
          { width: E, height: R } = e.context.project.spec.size;
        if (
          (D.x === 0 && N === $n.Left) ||
          (D.x === E - 1 && N === $n.Right) ||
          (D.y === 0 && N === $n.Top) ||
          (D.y === R - 1 && N === $n.Bottom)
        )
          return;
        const { helpers: W } = e.context;
        switch (N) {
          case $n.Top:
            return W.edgeIds.getIdFromCoords({ x: D.x + 0.5, y: D.y });
          case $n.Right:
            return W.edgeIds.getIdFromCoords({ x: D.x + 1, y: D.y + 0.5 });
          case $n.Bottom:
            return W.edgeIds.getIdFromCoords({ x: D.x + 0.5, y: D.y + 1 });
          case $n.Left:
            return W.edgeIds.getIdFromCoords({ x: D.x, y: D.y + 0.5 });
        }
      }
      const r = b(() => e.edgeClues.length > 0),
        l = j([]),
        i = b(() =>
          l.value
            .map((D) => e.edgeClues.find((N) => D === N.edge))
            .filter((D) => D)
        ),
        a = b(() => (i.value.length > 0 ? String(i.value[0].value) : void 0));
      function u() {
        l.value = [];
      }
      function p() {
        l.value = e.edgeClues.map((D) => D.edge);
      }
      ae(
        () => e.edgeClues,
        (D) => {
          l.value = l.value.filter((N) => D.some((E) => N === E.edge));
        }
      );
      const m = b(() =>
        i.value.length === 0
          ? {}
          : { ...e.inputMode, deleteButton: i.value.length > 0 }
      );
      er({ inputMode: m, selectedValue: a });
      let g = fe();
      function v(D, N = !1) {
        g = fe();
        let E = s(D);
        E ||
          ((E = { value: n(D), edge: D }),
          e.context.updateConstraint(
            { edgeClues: [...e.edgeClues, E] },
            "add",
            g
          )),
          N || u(),
          l.value.includes(D) ? _t(l.value, [D]) : l.value.push(D);
      }
      function $(D) {
        const N = i.value;
        if (N.every((R) => R.value === D)) return;
        const E = ue(e.edgeClues);
        for (const R of N) {
          const W = E.findIndex((T) => T.edge === R.edge);
          W !== -1 && (E[W].value = D);
        }
        e.context.updateConstraint({ edgeClues: E }, "update", g);
      }
      function k(D) {
        const N = e.edgeClues.slice();
        for (const E of D) {
          const R = N.findIndex((W) => W.edge === E.edge);
          R !== -1 && N.splice(R, 1);
        }
        e.context.updateConstraint({ edgeClues: N }, "delete"), u();
      }
      function M(D) {
        k(e.edgeClues.filter((N) => N.edge === D));
      }
      function P() {
        k(i.value);
      }
      const {
          position: x,
          pointerAction: A,
          deleting: O,
          placing: V,
        } = ml({
          createOrSelectClue: v,
          deselect: u,
          selectAll: p,
          updateClueValue: $,
          deleteAt: M,
          deleteSelectedClues: P,
          getClueAt: s,
          getPlaceablePosition: o,
        }),
        I = b(
          () => x.value && e.context.helpers.edgeIds.getCoordsFromId(x.value)
        ),
        U = b(() => {
          if (
            !(
              !O.value ||
              !x.value ||
              !e.edgeClues.find((D) => D.edge === x.value)
            )
          )
            return e.context.helpers.edgeIds.getCoordsFromId(x.value);
        });
      return (D, N) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              yt,
              { class: "EdgeGeometryEditor", context: D.context },
              os(
                {
                  buttons: f(() => [
                    c(
                      Ds,
                      {
                        mode: y(A),
                        "onUpdate:mode":
                          N[0] ||
                          (N[0] = (E) => (Rn(A) ? (A.value = E) : null)),
                        "can-delete": r.value,
                      },
                      null,
                      8,
                      ["mode", "can-delete"]
                    ),
                  ]),
                  _: 2,
                },
                [
                  D.$slots.description
                    ? {
                        name: "description",
                        fn: f(() => [G(D.$slots, "description")]),
                        key: "0",
                      }
                    : void 0,
                  D.$slots.properties
                    ? {
                        name: "properties",
                        fn: f(() => [G(D.$slots, "properties")]),
                        key: "1",
                      }
                    : void 0,
                  D.$slots.appearance
                    ? {
                        name: "appearance",
                        fn: f(() => [G(D.$slots, "appearance")]),
                        key: "2",
                      }
                    : void 0,
                ]
              ),
              1032,
              ["context"]
            ),
            c(
              ct,
              { layer: y(oe).Foreground },
              {
                default: f(() => [
                  c(
                    Bo,
                    { "edge-clues": i.value },
                    {
                      default: f(() => [
                        h(
                          "circle",
                          {
                            fill: "none",
                            stroke: y(ee).selectionColor,
                            "stroke-width": y(on),
                            r: D.highlightRadius + y(on) / 2,
                          },
                          null,
                          8,
                          DI
                        ),
                      ]),
                      _: 1,
                    },
                    8,
                    ["edge-clues"]
                  ),
                  c(
                    Bo,
                    { "edge-clues": D.edgeClues },
                    {
                      default: f((E) => [G(D.$slots, "default", Vr(Ci(E)))]),
                      _: 3,
                    },
                    8,
                    ["edge-clues"]
                  ),
                  y(V) && I.value
                    ? (d(),
                      C(
                        "g",
                        {
                          key: 0,
                          transform: `translate(${I.value.x} ${I.value.y})`,
                          opacity: "0.3",
                        },
                        [
                          G(D.$slots, "default", {
                            edge: y(x),
                            value: n(y(x)),
                          }),
                        ],
                        8,
                        MI
                      ))
                    : U.value
                    ? (d(),
                      w(
                        hl,
                        {
                          key: 1,
                          x: U.value.x,
                          y: U.value.y,
                          scale: D.highlightRadius,
                        },
                        null,
                        8,
                        ["x", "y", "scale"]
                      ))
                    : z("", !0),
                ]),
                _: 3,
              },
              8,
              ["layer"]
            ),
          ],
          64
        )
      );
    },
  }),
  AI = {
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    "stroke-linecap": "square",
    "stroke-miterlimit": "1.5",
  },
  PI = S({
    __name: "DifferencePreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "svg",
          AI,
          n[0] ||
            (n[0] = [
              h(
                "path",
                { d: "M10 4v12", fill: "none", stroke: "#000" },
                null,
                -1
              ),
              h(
                "circle",
                {
                  cx: "10",
                  cy: "10",
                  r: "4",
                  fill: "#fff",
                  stroke: "#000",
                  "stroke-linecap": "round",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M4.58 11.38v.75H1.74c.03-.29.12-.56.28-.81.15-.26.45-.6.9-1.02.37-.34.6-.57.68-.7a.88.88 0 0 0 .17-.5c0-.17-.05-.31-.14-.4a.55.55 0 0 0-.41-.15c-.17 0-.3.05-.4.15-.1.1-.17.27-.18.5l-.8-.07c.04-.45.2-.77.45-.96.25-.2.57-.3.95-.3.42 0 .75.11.98.34.25.22.36.5.36.84 0 .2-.03.37-.1.55-.07.17-.17.35-.32.54-.1.12-.28.3-.53.54-.27.23-.42.39-.5.46l-.16.24h1.61ZM17.44 12.13h-.82V9.07c-.3.28-.64.48-1.05.61v-.74c.22-.06.45-.2.7-.39.25-.2.42-.42.5-.68h.67v4.26Z",
                },
                null,
                -1
              ),
            ])
        )
      );
    },
  }),
  LI = S({
    components: { FormRow: ve, TextInput: vt },
    props: {
      label: { type: String, required: !0 },
      value: { type: Array, required: !0 },
      digits: {
        type: Array,
        default() {
          return [1, 2, 3, 4, 5, 6, 7, 8, 9];
        },
      },
      default: {
        type: Array,
        default() {
          return [];
        },
      },
    },
    emits: { "update:value": (t, e) => !0 },
    data() {
      return { actionId: fe(), internalValue: "" };
    },
    watch: {
      value: {
        immediate: !0,
        handler(t) {
          this.internalValue = t.slice().sort().join(" ");
        },
      },
    },
    methods: {
      getDigitsFromString(t) {
        const e = t
          .split("")
          .map((n) => Number(n))
          .filter((n) => this.digits.includes(n));
        return [...new Set(e)].sort((n, s) => n - s);
      },
      onChange(t) {
        const e = this.getDigitsFromString(t);
        (this.internalValue = e.join(" ")),
          Ce(e, this.value) || this.$emit("update:value", e, this.actionId);
      },
    },
  });
function EI(t, e, n, s, o, r) {
  const l = H("TextInput"),
    i = H("FormRow");
  return (
    d(),
    w(
      i,
      { label: `${t.label}:` },
      {
        default: f(() => [
          c(
            l,
            {
              value: t.internalValue,
              "onUpdate:value": e[0] || (e[0] = (a) => (t.internalValue = a)),
              onChange: t.onChange,
            },
            null,
            8,
            ["value", "onChange"]
          ),
        ]),
        _: 1,
      },
      8,
      ["label"]
    )
  );
}
const vf = B(LI, [
    ["render", EI],
    ["__scopeId", "data-v-4df661a3"],
  ]),
  FI = S({
    components: {
      DigitSetInput: vf,
      FormControlLabel: ut,
      CheckBox: at,
      TooltipIndicator: dt,
    },
    props: {
      context: { type: Object, required: !0 },
      usedDifferences: { type: Set, required: !0 },
      negative: { type: Array, required: !0 },
      overrideNegativeRatios: { type: Boolean, required: !0 },
    },
    computed: {
      validNegativeDifferences() {
        return [
          ...Ve(
            1,
            this.context.project.spec.maxDigit -
              this.context.project.spec.minDigit
          ),
        ];
      },
      defaultNegativeDifferences() {
        return this.usedDifferences.size === 0
          ? [1]
          : [...this.usedDifferences];
      },
      showNegativeRatioOverride() {
        const t = this.context.constraints.find(
          (n) => n.config.type === _.Ratio
        );
        if (!t || t.config.negative.length === 0) return !1;
        const e = [];
        for (const n of this.usedDifferences) {
          e.push(n + 1);
          for (const s of [2, 3, 4, 5, 6, 7, 8, 9])
            if (n * s <= this.context.project.spec.maxDigit) e.push(s);
            else break;
        }
        return t.config.negative.some((n) => e.includes(n));
      },
    },
    methods: {
      onNegativeInputChange(t, e) {
        this.context.updateConstraint(
          { negative: t },
          "updateNegativeValues",
          e
        );
      },
      updateNegative(t) {
        t
          ? this.context.updateConstraint(
              { negative: this.defaultNegativeDifferences },
              "toggleNegative"
            )
          : this.context.updateConstraint({ negative: [] }, "toggleNegative");
      },
    },
  });
function BI(t, e, n, s, o, r) {
  const l = H("CheckBox"),
    i = H("TooltipIndicator"),
    a = H("FormControlLabel"),
    u = H("DigitSetInput");
  return (
    d(),
    C(
      Z,
      null,
      [
        c(a, null, {
          default: f(() => [
            c(
              l,
              {
                checked: t.negative.length > 0,
                "onUpdate:checked": t.updateNegative,
              },
              null,
              8,
              ["checked", "onUpdate:checked"]
            ),
            h("span", null, [
              e[2] || (e[2] = F(" Negative constraint ")),
              c(i, null, {
                default: f(
                  () =>
                    e[1] ||
                    (e[1] = [
                      F(
                        " All cells not joined with a dot must not have any of the specified differences "
                      ),
                    ])
                ),
                _: 1,
              }),
            ]),
          ]),
          _: 1,
        }),
        t.negative.length > 0
          ? (d(),
            w(
              u,
              {
                key: 0,
                value: t.negative,
                digits: t.validNegativeDifferences,
                default: t.defaultNegativeDifferences,
                label: "Disallowed differences",
                "onUpdate:value": t.onNegativeInputChange,
              },
              null,
              8,
              ["value", "digits", "default", "onUpdate:value"]
            ))
          : z("", !0),
        t.showNegativeRatioOverride
          ? (d(),
            w(
              a,
              { key: 1 },
              {
                default: f(() => [
                  c(
                    l,
                    {
                      checked: t.overrideNegativeRatios,
                      "onUpdate:checked":
                        e[0] ||
                        (e[0] = (p) =>
                          t.context.updateConstraint(
                            { overrideNegativeRatios: p },
                            "update:overrideNegativeRatios"
                          )),
                    },
                    null,
                    8,
                    ["checked"]
                  ),
                  h("span", null, [
                    e[4] || (e[4] = F(" Override negative ratio constraints ")),
                    c(i, null, {
                      default: f(
                        () =>
                          e[3] ||
                          (e[3] = [
                            F(
                              " Allow, for example, a 1-dot to have a 1-2 pair even when a negative 1:2 ratio constraint would’ve disallowed it. "
                            ),
                          ])
                      ),
                      _: 1,
                    }),
                  ]),
                ]),
                _: 1,
              }
            ))
          : z("", !0),
      ],
      64
    )
  );
}
const zI = B(FI, [["render", BI]]);
function yf(t, e) {
  const n = [...new Set(e.clues.map((s) => s.value))];
  e.negative.length > 0 &&
    n.length > 0 &&
    Hr(t, new Set(e.negative)) &&
    (e.negative = n);
}
function RI(t) {
  return (
    typeof t == "function" ||
    (Object.prototype.toString.call(t) === "[object Object]" && !Nt(t))
  );
}
function Wu(t) {
  const e = t.clues.some((n) => n.value > 1);
  return t.clues.map((n) => ({
    value: n.value <= 1 && !e ? "" : String(n.value),
    edge: n.edge,
  }));
}
const cr = {
  default: (t) => {
    const e = { fill: "#000" };
    return [
      c(
        "circle",
        { r: 0.16, fill: "#fff", stroke: "#000", "stroke-width": 0.02 },
        null
      ),
      c(kn, St({ value: t.value, "font-size": 0.25 }, e), null),
    ];
  },
};
function OI(t) {
  return t.type !== Ie.Custom
    ? [...Ve(t.minDigit, t.maxDigit)].filter(
        (e) => e > 0 && e <= t.maxDigit - t.minDigit
      )
    : [...Ve(t.minDigit, t.maxDigit)];
}
_e({
  type: _.Difference,
  label: "Difference Kropki dots",
  preview: PI,
  renderers: (t) => [
    {
      layer: oe.Foreground,
      component: c(
        Bo,
        { edgeClues: Wu(t) },
        RI(cr) ? cr : { default: () => [cr] }
      ),
    },
  ],
  editor: xe({
    editor: {
      component: ma,
      props: (t, { project: e }) => ({
        edgeClues: Wu(t),
        inputMode: { ...Kc(OI(e.spec), e.spec), type: Ke.Replace },
        highlightRadius: 0.17,
      }),
      slots: cr,
    },
    propertiesForm: {
      component: zI,
      props: (t) => {
        const e = new Set();
        for (const n of t.clues) e.add(n.value);
        return {
          usedDifferences: e,
          negative: t.negative,
          overrideNegativeRatios: t.overrideNegativeRatios,
        };
      },
    },
    updateFunc: (t, e) => {
      const { edgeClues: n, negative: s, overrideNegativeRatios: o } = e;
      if ((o !== void 0 && (t.overrideNegativeRatios = o), n)) {
        const r = new Set(t.clues.map((l) => l.value));
        (t.clues = n.map((l) => ({
          value: Number(l.value || 1),
          edge: l.edge,
        }))),
          s === void 0 && yf(r, t);
      }
      s !== void 0 && (t.negative = s);
    },
  }),
});
const Cf = S({
    __name: "CellEditor",
    props: { context: {}, cells: {} },
    setup(t) {
      const e = t;
      let n = fe();
      const s = j(),
        o = j(!1);
      Vn({
        onDragStart: (l) => {
          l.cellId !== void 0 &&
            ((n = fe()), (o.value = e.cells.includes(l.cellId)), r(l.cellId));
        },
        onDragMove: (l) => {
          l.cellId && r(l.cellId);
        },
        onHover: (l) => {
          s.value = l.cellId;
        },
        onHoverEnd: () => {
          s.value = void 0;
        },
      });
      function r(l) {
        let i = e.cells;
        o.value
          ? (i = mn(e.cells, [l]))
          : e.cells.includes(l) || (i = e.cells.concat(l)),
          !Ce(e.cells, i) &&
            e.context.updateConstraint(
              { cells: i },
              o.value ? "delete" : "add",
              n
            );
      }
      return (l, i) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              yt,
              { class: "CellEditor", context: l.context },
              os({ properties: f(() => [G(l.$slots, "properties")]), _: 2 }, [
                l.$slots.description
                  ? {
                      name: "description",
                      fn: f(() => [G(l.$slots, "description")]),
                      key: "0",
                    }
                  : void 0,
                l.$slots.appearance
                  ? {
                      name: "appearance",
                      fn: f(() => [G(l.$slots, "appearance")]),
                      key: "1",
                    }
                  : void 0,
              ]),
              1032,
              ["context"]
            ),
            c(ct, null, {
              default: f(() => [
                s.value !== void 0
                  ? G(l.$slots, "hover", { key: 0, cells: [s.value] })
                  : z("", !0),
                G(l.$slots, "default", { cells: l.cells }),
              ]),
              _: 3,
            }),
            c(y(jn)),
          ],
          64
        )
      );
    },
  }),
  NI = {
    class: "DifferentValuesPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  TI = ["fill"],
  VI = S({
    __name: "DifferentValuesPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", NI, [
          h(
            "path",
            {
              d: "M2 2v4h6v8H2v4h10v-6h6V2H2Z",
              fill: y(Ws)(e.constraint.style.color),
            },
            null,
            8,
            TI
          ),
          n[0] ||
            (n[0] = h(
              "path",
              {
                fill: "none",
                stroke: "#000",
                d: "M1 1h18v18H1zm6 0v18M1 7h18m-6 12V1m6 12H1",
              },
              null,
              -1
            )),
        ])
      );
    },
  }),
  xl = S({
    __name: "InsetRegionRenderer",
    props: {
      style: {
        type: Object,
        default() {
          return { color: "#ccc", offset: 0 };
        },
      },
      regions: { type: Array, required: !0 },
    },
    setup(t) {
      return (e, n) => (
        d(),
        C("g", null, [
          (d(!0),
          C(
            Z,
            null,
            se(
              t.regions,
              (s, o) => (
                d(),
                w(
                  Vs,
                  {
                    key: `region${o}`,
                    cells: s,
                    "stroke-width": 0,
                    "fill-color": t.style.color,
                    offset: t.style.offset,
                    "stroke-dasharray": "0.1 0.06",
                  },
                  null,
                  8,
                  ["cells", "fill-color", "offset"]
                )
              )
            ),
            128
          )),
        ])
      );
    },
  });
_e({
  type: _.DifferentValues,
  label: (t, e) => {
    const n = t.cells.length;
    return n < 2
      ? "Extra region/different values"
      : n === e.digitCount
      ? "Extra region"
      : `${n} different values`;
  },
  preview: VI,
  renderers: (t) => [
    {
      layer: oe.Background,
      component: c(xl, { regions: [t.cells], style: t.style }, null),
    },
  ],
  editor: xe({
    editor: {
      component: Cf,
      props: (t) => sn(t, "cells"),
      slots: (t) => ({
        hover({ cells: e }) {
          return [c(xl, { style: t.style, regions: [e] }, null)];
        },
        default({ cells: e }) {
          return [c(xl, { style: t.style, regions: [e] }, null)];
        },
      }),
    },
    appearanceForm: {
      props: (t) => ({
        properties: [
          {
            type: "color",
            name: "color",
            label: "Color",
            value: t.style.color,
          },
          {
            type: "radius",
            name: "offset",
            label: "Offset",
            value: t.style.offset,
          },
        ],
      }),
    },
  }),
});
const jI = {
    class: "DoubleArrowPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  UI = ["fill", "stroke"],
  HI = ["stroke"],
  WI = S({
    __name: "DoubleArrowPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", jI, [
          h(
            "g",
            {
              fill: e.constraint.style.endPoints.fill,
              stroke: e.constraint.style.endPoints.stroke.color,
            },
            n[0] ||
              (n[0] = [
                h("circle", { cx: "16", cy: "4", r: "3" }, null, -1),
                h("circle", { cx: "4", cy: "16", r: "3" }, null, -1),
              ]),
            8,
            UI
          ),
          h(
            "path",
            { d: "M13.6 6.4L6.4 13.6", stroke: e.constraint.style.lines.color },
            null,
            8,
            HI
          ),
        ])
      );
    },
  });
function ZI(t) {
  return (
    typeof t == "function" ||
    (Object.prototype.toString.call(t) === "[object Object]" && !Nt(t))
  );
}
function Zu(t) {
  return {
    default: () => [
      c(
        "circle",
        {
          r: t.style.endPoints.size / 2,
          stroke: t.style.endPoints.stroke.color,
          "stroke-width": t.style.endPoints.stroke.thickness,
          fill: t.style.endPoints.fill,
        },
        null
      ),
    ],
    selection: ({ selectionOutlineSize: e }) => [
      c(
        "circle",
        {
          r: (t.style.endPoints.size + t.style.endPoints.stroke.thickness) / 2,
          stroke: ee.selectionColor,
          "stroke-width": e * 2,
          "paint-order": "stroke",
          fill: "#fff",
        },
        null
      ),
    ],
  };
}
_e({
  type: _.DoubleArrow,
  label: "Double arrows",
  preview: WI,
  renderers: (t) => {
    let e;
    return [
      {
        layer: oe.Default,
        component: c(
          Fo,
          { lines: t.lines, style: t.style },
          ZI((e = Zu(t))) ? e : { default: () => [e] }
        ),
      },
    ];
  },
  editor: xe({
    editor: {
      component: pa,
      props: (t) => ({
        lines: t.lines,
        endPointStyleLabel: "Circle style",
        style: t.style,
      }),
      slots: Zu,
    },
  }),
});
const Ms = S({
    __name: "CommonLineRenderer",
    props: { lines: {}, style: {} },
    setup(t) {
      const e = t,
        { helpers: n } = Qe(et).value,
        s = b(() =>
          e.lines.map((o) => o.map((r) => n.cellIds.getCellCenterFromId(r)))
        );
      return (o, r) => (
        d(),
        w(
          df,
          {
            paths: s.value,
            color: o.style.color,
            "line-width": o.style.thickness,
          },
          null,
          8,
          ["paths", "color", "line-width"]
        )
      );
    },
  }),
  GI = S({
    components: {
      InputListener: jn,
      LineStyleControls: da,
      EditorEvents: Jo,
      CommonActions: Ds,
      CommonLineRenderer: Ms,
      EditorFormBase: yt,
      EditorRendererWrapper: ct,
    },
    props: {
      context: { type: Object, required: !0 },
      lines: { type: Array, required: !0 },
      style: { type: Object, required: !0 },
      directed: { type: Boolean, default: !1 },
      restrictions: {
        type: [Object, Function],
        default: () => ({ allowBranching: !0, allowCycles: !0 }),
      },
    },
    data() {
      return {
        mode: "add",
        creatingNew: !1,
        selectedCellIds: [],
        actionId: fe(),
        previousCellId: 0,
        brushMode: "none",
        erasedSegments: [],
      };
    },
    computed: {
      inputMode() {
        return { deleteButton: !this.selectedLines.isEmpty() };
      },
      selectionLinePadding() {
        return on.value;
      },
      selectionLineWidth() {
        return this.style.thickness + this.selectionLinePadding * 2;
      },
      selectionColor() {
        return ee.selectionColor;
      },
      directedGraph() {
        return new Do(this.lines);
      },
      undirectedGraph() {
        return new Ut(this.lines);
      },
      representativeGraph() {
        return this.directed ? this.directedGraph : this.undirectedGraph;
      },
      noLines() {
        return this.representativeGraph.getPoints().length === 0;
      },
      selectedLines() {
        return this.getLinesAt(this.selectedCellIds);
      },
      selectedLinesAsArrays() {
        return this.selectedLines.toArrays();
      },
      placeholderPath() {
        if (this.creatingNew) return [[this.selectedCellIds[0]]];
      },
    },
    methods: {
      getLinesAt(t) {
        return (
          this.directed &&
            (t = this.undirectedGraph
              .getComponentsContainingPoints(t)
              .getPoints()),
          this.representativeGraph.getComponentsContainingPoints(t)
        );
      },
      deselect() {
        this.selectedCellIds = [];
      },
      onStyleUpdate(t, e) {
        this.context.updateConstraintAppearance(t, "update:lineStyle", e);
      },
      onPointerDown(t) {
        if (t.cellId !== void 0)
          if (((this.actionId = fe()), ye.isSelecting())) {
            const e = this.getLinesAt([t.cellId]);
            this.selectedCellIds.some((s) => e.hasPoint(s))
              ? _t(this.selectedCellIds, e.getPoints())
              : this.selectedCellIds.push(t.cellId),
              (this.brushMode = "none"),
              (this.previousCellId = t.cellId);
          } else
            this.mode === "delete"
              ? (this.deselect(),
                this.deleteLinesAt([t.cellId]),
                (this.brushMode = "erase"))
              : (this.getLinesAt([t.cellId]).isEmpty() &&
                  (this.creatingNew = !0),
                (this.brushMode = "determine"),
                (this.selectedCellIds = [t.cellId]),
                (this.previousCellId = t.cellId));
      },
      onPointerMove(t) {
        if (!t.pointerDown || t.cellId === void 0 || this.brushMode === "none")
          return;
        if (this.brushMode === "erase") {
          this.deleteLinesAt([t.cellId]);
          return;
        }
        if (t.cellId === this.previousCellId || !al(t)) return;
        const e = this.undirectedGraph.hasEdge(t.cellId, this.previousCellId);
        this.brushMode === "determine" &&
          ((this.brushMode = e ? "removeEdges" : "addEdges"),
          this.brushMode === "removeEdges" &&
            (this.erasedSegments = [[this.previousCellId]])),
          this.brushMode === "removeEdges" && e
            ? this.eraseSegment(t.cellId)
            : this.brushMode === "addEdges" && !e
            ? this.addSegment(t.cellId)
            : e && (this.previousCellId = t.cellId);
      },
      onPointerUp() {
        (this.brushMode = "none"),
          (this.erasedSegments = []),
          (this.creatingNew = !1);
      },
      onDelete() {
        this.deleteLinesAt(this.selectedCellIds);
      },
      onSelectAll() {
        this.selectedCellIds = this.representativeGraph.getPoints();
      },
      generateNewLines() {
        return this.representativeGraph.clone();
      },
      deleteLinesAt(t) {
        const n = [...this.getLinesAt(t).getPoints()];
        if (n.length === 0) return;
        const s = this.generateNewLines();
        for (const r of n) s.removePoint(r);
        const o = s.toArrays();
        this.context.updateConstraint({ lines: o }, "delete", this.actionId);
      },
      validate(t) {
        if (typeof this.restrictions == "function") return this.restrictions(t);
        if (
          !this.restrictions.allowCycles &&
          this.representativeGraph.hasCycles()
        )
          return !1;
        const e = new Ut(t);
        if (!this.restrictions.allowBranching && !e.isSimpleLines()) return !1;
        if (this.restrictions.maxPoints) {
          for (const n of e.getAllComponents())
            if (n.getPointCount() > this.restrictions.maxPoints) return !1;
        }
        return !0;
      },
      addSegment(t) {
        const { helpers: e } = this.context,
          n = [
            ...ea(
              e.cellIds.getCoordsFromId(this.previousCellId),
              e.cellIds.getCoordsFromId(t)
            ),
          ].map((r) => e.cellIds.getIdFromCoords(r)),
          s = this.generateNewLines();
        let o = !1;
        for (let r = 0; r < n.length - 1; r++) {
          if (
            (s.addEdge(n[r], n[r + 1]),
            this.validate(this.representativeGraph.toArrays()) &&
              !this.validate(s.toArrays()))
          ) {
            s.removeEdge(n[r], n[r + 1]);
            break;
          }
          o = !0;
        }
        o &&
          (this.context.updateConstraint(
            { lines: s.toArrays() },
            "add",
            this.actionId
          ),
          (this.creatingNew = !1),
          (this.previousCellId = t));
      },
      eraseSegment(t) {
        const e = this.generateNewLines()
          .removeEdge(this.previousCellId, t)
          .removeEdge(t, this.previousCellId)
          .toArrays();
        if (this.validate(this.lines) && !this.validate(e)) return;
        this.context.updateConstraint({ lines: e }, "delete", this.actionId),
          this.selectedCellIds.push(t),
          _t(this.selectedCellIds, [this.previousCellId]);
        const n = this.erasedSegments.at(-1);
        n.length === 1 ? n.push(t) : this.erasedSegments.push([n[1], t]),
          (this.previousCellId = t);
      },
    },
  });
function qI(t, e, n, s, o, r) {
  const l = H("LineStyleControls"),
    i = H("CommonActions"),
    a = H("EditorFormBase"),
    u = H("CommonLineRenderer"),
    p = H("EditorRendererWrapper"),
    m = H("InputListener"),
    g = H("EditorEvents");
  return (
    d(),
    C(
      Z,
      null,
      [
        c(
          a,
          { class: "LineEditor", context: t.context },
          {
            properties: f(() => [G(t.$slots, "properties")]),
            appearance: f(() => [
              c(
                l,
                { value: t.style, "onUpdate:value": t.onStyleUpdate },
                null,
                8,
                ["value", "onUpdate:value"]
              ),
              G(t.$slots, "appearance"),
            ]),
            buttons: f(() => [
              c(
                i,
                {
                  mode: t.mode,
                  "onUpdate:mode": e[0] || (e[0] = (v) => (t.mode = v)),
                  "can-delete": !t.noLines,
                },
                null,
                8,
                ["mode", "can-delete"]
              ),
            ]),
            _: 3,
          },
          8,
          ["context"]
        ),
        c(p, null, {
          default: f(() => [
            t.placeholderPath
              ? G(
                  t.$slots,
                  "placeholder",
                  {
                    key: 0,
                    paths: t.placeholderPath,
                    color: t.selectionColor,
                    padding: t.selectionLinePadding,
                  },
                  () => [
                    c(
                      u,
                      {
                        lines: t.placeholderPath,
                        style: We({
                          color: t.selectionColor,
                          thickness: t.selectionLineWidth,
                        }),
                      },
                      null,
                      8,
                      ["lines", "style"]
                    ),
                  ]
                )
              : z("", !0),
            G(
              t.$slots,
              "selection",
              {
                paths: t.selectedLinesAsArrays,
                color: t.selectionColor,
                padding: t.selectionLinePadding,
              },
              () => [
                c(
                  u,
                  {
                    lines: t.selectedLinesAsArrays,
                    style: We({
                      color: t.selectionColor,
                      thickness: t.selectionLineWidth,
                    }),
                  },
                  null,
                  8,
                  ["lines", "style"]
                ),
              ]
            ),
            G(t.$slots, "default", { paths: t.lines }, () => [
              c(u, { lines: t.lines, style: We(t.style) }, null, 8, [
                "lines",
                "style",
              ]),
            ]),
            G(
              t.$slots,
              "deleteHighlight",
              {
                paths: t.erasedSegments,
                color: "#ff0000cc",
                padding: t.selectionLinePadding,
              },
              () => [
                c(
                  u,
                  {
                    lines: t.erasedSegments,
                    style: We({
                      color: "#ff0000cc",
                      thickness: t.selectionLineWidth,
                    }),
                  },
                  null,
                  8,
                  ["lines", "style"]
                ),
              ]
            ),
          ]),
          _: 3,
        }),
        c(m, { mode: t.inputMode }, null, 8, ["mode"]),
        c(
          g,
          {
            onDragStart: t.onPointerDown,
            onDragMove: t.onPointerMove,
            onDragEnd: t.onPointerUp,
            onDelete: t.onDelete,
            onSelectAll: t.onSelectAll,
          },
          null,
          8,
          ["onDragStart", "onDragMove", "onDragEnd", "onDelete", "onSelectAll"]
        ),
      ],
      64
    )
  );
}
const As = B(GI, [["render", qI]]),
  KI = {
    class: "EntropyLinePreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  XI = ["stroke"],
  YI = {
    "paint-order": "stroke",
    stroke: "#fff",
    fill: "#000",
    "font-size": "5",
    "font-weight": "bold",
  },
  JI = { x: "0", y: "7", "text-anchor": "start" },
  QI = { key: 0, x: "10", y: "16", "text-anchor": "middle" },
  ex = { key: 1, x: "20", y: "7", "text-anchor": "end" },
  tx = S({
    __name: "EntropyLinePreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      const e = t,
        n = b(() => e.constraint.style.color),
        s = b(() => {
          var r, l;
          return (
            (l = (r = e.constraint) == null ? void 0 : r.groups) != null &&
            l.length
              ? e.constraint.groups
              : [14, 112, 896]
          ).map((i) => [...nn(i, 0, 9)].join(""));
        });
      return (o, r) => (
        d(),
        C("svg", KI, [
          h(
            "path",
            { d: "m1 5.5 9 9 9-9", fill: "none", stroke: n.value },
            null,
            8,
            XI
          ),
          h("g", YI, [
            h("text", JI, X(s.value[0]), 1),
            s.value[1] ? (d(), C("text", QI, X(s.value[1]), 1)) : z("", !0),
            s.value[2] ? (d(), C("text", ex, X(s.value[2]), 1)) : z("", !0),
          ]),
        ])
      );
    },
  });
function pi(t) {
  return t
    .map((e) => [...nn(e, 0, 9)].join(""))
    .sort()
    .join(" ");
}
function nx(t, e) {
  if (t.length === 0) return !1;
  const n = new No(e).createFullDigitSet();
  for (const s of t)
    if (n.isSupersetOf(s)) n.subtract(s);
    else return !1;
  return !0;
}
function sx(t, e) {
  return `${_c(wf({ groups: t, spec: e, adjective: !0 }))} lines`;
}
function ox(t, e) {
  return `Global ${wf({ groups: t, spec: e })}`;
}
function rx(t, e) {
  if (t.length !== 2) return !1;
  const n = new No(e);
  return (
    t.includes(+n.createEvensDigitSet()) && t.includes(+n.createOddsDigitSet())
  );
}
function Gu(t, e, n) {
  if (t.length !== e) return !1;
  const s = Array.from(t, () => new Mt());
  for (let o = n.minDigit; o <= n.maxDigit; o++) s[o % e].add(o);
  return t.every((o) => s.some((r) => r.valueOf() === o));
}
function lx(t, e) {
  if (t.length !== 2) return !1;
  const n = (e.maxDigit + e.minDigit) / 2,
    s = new No(e),
    o = +s.createFilteredDigitSet((l) => l < n),
    r = +s.createFilteredDigitSet((l) => l < n);
  return t.includes(o) && t.includes(r);
}
function ix(t, e) {
  const n = `${e.minDigit}_${e.maxDigit}`,
    s = pi(t);
  return [
    "1_6|12 34 56",
    "0_5|01 23 45",
    "1_7|12 345 67",
    "0_6|01 234 56",
    "1_8|12 34 56 78",
    "0_7|01 23 45 67",
    "1_9|123 456 789",
    "0_8|012 345 678",
  ].includes(`${n}|${s}`);
}
function wf({ groups: t, spec: e, short: n, adjective: s }) {
  return rx(t, e)
    ? n
      ? "parity"
      : "parity (odd/even)"
    : Gu(t, 3, e)
    ? s
      ? "3-modular"
      : "modulo-3"
    : Gu(t, 4, e)
    ? s
      ? "4-modular"
      : "modulo-4"
    : lx(t, e)
    ? n
      ? "polarity"
      : "polarity (low/high)"
    : ix(t, e)
    ? s
      ? "entropic"
      : "entropy"
    : t
        .map((o) => [...nn(o, 0, 9)].join(""))
        .sort()
        .join("/") || "???";
}
function ax(t) {
  switch (t.digitCount) {
    case 4:
      return [fs(t), hs(t)];
    case 5:
      return [fs(t), Sn(3, t), hs(t)];
    case 6:
      return [po(t), fs(t), Sn(3, t), hs(t)];
    case 7:
      return [po(t), fs(t), Sn(3, t), Sn(4, t), hs(t)];
    case 8:
      return [po(t), fs(t), Sn(3, t), Sn(4, t), hs(t)];
    case 9:
      return [po(t), fs(t), Sn(3, t), Sn(4, t), hs(t)];
    default:
      return [];
  }
}
function ux(t) {
  switch (t.digitCount) {
    case 6:
    case 8:
      return [fs(t), hs(t)];
    case 9:
      return [po(t), Sn(3, t)];
    default:
      return [];
  }
}
function fs(t) {
  const e = ["", ""];
  for (let n = t.minDigit; n <= t.maxDigit; n++) e[n % 2] += n;
  return { value: e.join(" "), label: "Odd/even" };
}
function hs(t) {
  const e = ["", ""];
  for (let n = t.minDigit; n <= t.maxDigit; n++)
    n < (t.minDigit + t.maxDigit) / 2 && (e[0] += n),
      n > (t.minDigit + t.maxDigit) / 2 && (e[1] += n);
  return { value: e.join(" "), label: "Low/high" };
}
function Sn(t, e) {
  const n = Array.from({ length: t }, () => "");
  for (let s = e.minDigit; s <= e.maxDigit; s++) n[s % t] += s;
  return { value: n.join(" "), label: `Modulo ${t}` };
}
function po(t) {
  let e = "";
  switch (t.digitCount) {
    case 6:
      e = t.minDigit === 1 ? "12 34 56" : "01 23 45";
      break;
    case 7:
      e = t.minDigit === 1 ? "12 345 67" : "01 234 56";
      break;
    case 8:
      e = t.minDigit === 1 ? "12 34 56 78" : "01 23 45 67";
      break;
    case 9:
      e = t.minDigit === 1 ? "123 456 789" : "012 345 678";
      break;
  }
  return { value: e, label: "Entropic" };
}
const cx = S({
  components: { DropdownSelect: qs, FormRow: ve, TextInput: vt },
  props: {
    context: { type: Object, required: !0 },
    groups: { type: Array, required: !0 },
    isGlobal: { type: Boolean, default: !1 },
  },
  data() {
    return { textInput: "" };
  },
  computed: {
    presets() {
      return this.isGlobal
        ? ux(this.context.project.spec)
        : ax(this.context.project.spec);
    },
    preset() {
      return this.textInput;
    },
    restrictions() {
      return { allowBranching: !1, allowCycles: !1 };
    },
    groupsFromInput() {
      return this.getGroupsFromString(this.textInput);
    },
    validGroups() {
      return nx(this.groupsFromInput, this.context.project.spec);
    },
  },
  watch: {
    groups: {
      immediate: !0,
      handler(t) {
        this.textInput = pi(t);
      },
    },
  },
  methods: {
    setPreset(t) {
      this.onTextChange(t);
    },
    onTextChange(t) {
      const e = this.getGroupsFromString(t);
      if (Hr(new Set(e), new Set(this.groups))) {
        this.textInput = pi(e);
        return;
      }
      this.context.updateConstraint({ groups: e }, "update");
    },
    getGroupsFromString(t) {
      const e = this.context.helpers.digits.createFullDigitSet();
      return t
        .split(" ")
        .map((n) => {
          const s = new Set([...n.matchAll(/\d/g)].map(Number));
          return Vt(s) & +e;
        })
        .filter((n) => n)
        .sort((n, s) => n - s);
    },
  },
});
function dx(t, e, n, s, o, r) {
  const l = H("TextInput"),
    i = H("DropdownSelect"),
    a = H("FormRow");
  return (
    d(),
    w(
      a,
      { label: "Groups:" },
      {
        default: f(() => [
          c(
            l,
            {
              value: t.textInput,
              "onUpdate:value": e[0] || (e[0] = (u) => (t.textInput = u)),
              class: "groupInput",
              invalid: !t.validGroups,
              onChange: t.onTextChange,
            },
            null,
            8,
            ["value", "invalid", "onChange"]
          ),
          t.presets.length > 0
            ? (d(),
              w(
                i,
                {
                  key: 0,
                  "model-value": t.preset,
                  options: t.presets,
                  "fallback-text": "Custom",
                  "dropdown-align": "left",
                  "onUpdate:modelValue": e[1] || (e[1] = (u) => t.setPreset(u)),
                },
                null,
                8,
                ["model-value", "options"]
              ))
            : z("", !0),
        ]),
        _: 1,
      }
    )
  );
}
const bf = B(cx, [
  ["render", dx],
  ["__scopeId", "data-v-c047e22f"],
]);
_e({
  type: _.EntropyLines,
  label: (t, e) => sx(t.groups, e),
  preview: tx,
  renderers: (t) => [
    {
      layer: oe.Default,
      component: c(Ms, { lines: t.lines, style: t.style }, null),
    },
  ],
  editor: xe({
    editor: {
      component: As,
      props: (t) => ({
        lines: t.lines,
        style: t.style,
        restrictions: {
          allowCycles: !0,
          allowBranching: t.groups.length === 2,
        },
      }),
    },
    propertiesForm: { component: bf, props: (t) => ({ groups: t.groups }) },
  }),
});
const px = S({
    components: { CellEditor: Cf, CellSymbolRenderer: is },
    props: {
      context: { type: Object, required: !0 },
      cells: { type: Array, required: !0 },
    },
  }),
  fx = { opacity: "0.5" };
function hx(t, e, n, s, o, r) {
  const l = H("CellSymbolRenderer"),
    i = H("CellEditor");
  return (
    d(),
    w(
      i,
      { context: t.context, cells: t.cells },
      os(
        {
          properties: f(() => [G(t.$slots, "properties")]),
          hover: f(({ cells: a }) => [
            c(
              l,
              { cells: a },
              {
                default: f(({ position: u, cell: p }) => [
                  h("g", fx, [
                    G(t.$slots, "default", { position: u, cell: p }),
                  ]),
                ]),
                _: 2,
              },
              1032,
              ["cells"]
            ),
          ]),
          default: f(({ cells: a }) => [
            c(
              l,
              { cells: a },
              {
                default: f(({ position: u, cell: p }) => [
                  G(t.$slots, "default", { position: u, cell: p }),
                ]),
                _: 2,
              },
              1032,
              ["cells"]
            ),
          ]),
          _: 2,
        },
        [
          t.$slots.appearance
            ? {
                name: "appearance",
                fn: f(() => [G(t.$slots, "appearance")]),
                key: "0",
              }
            : void 0,
        ]
      ),
      1032,
      ["context", "cells"]
    )
  );
}
const gl = B(px, [["render", hx]]),
  mx = {
    class: "EvenPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  gx = ["fill"],
  vx = S({
    __name: "EvenPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", mx, [
          h(
            "path",
            {
              d: "M19.5 1c0-.3-.2-.5-.5-.5H1C.7.5.5.7.5 1v18c0 .3.2.5.5.5h18c.3 0 .5-.2.5-.5V1Zm-4 8.7c-.2 0-.4-.2-.5-.4-.2-.2-.2-.4-.2-.7 0-.4.1-.7.4-1 .3-.2.7-.4 1.1-.4.5 0 .9.2 1.2.5.3.2.4.6.4 1 0 .2 0 .4-.2.6-.1.2-.3.3-.6.4.3.1.6.3.8.6l.2.8c0 .5-.1.9-.5 1.2-.3.3-.7.5-1.3.5-.5 0-1-.2-1.3-.5-.3-.3-.4-.7-.4-1.2 0-.3 0-.6.2-.9l.8-.5Zm-1.7-1.1h-.7c0-.2 0-.4-.2-.5a.9.9 0 0 0-.7-.3 1 1 0 0 0-.5.2c-.2.1-.4.3-.5.6L11 10a1.5 1.5 0 0 1 1.3-.7c.5 0 .8.1 1.1.5.3.3.5.7.5 1.2 0 .4 0 .7-.2 1a1.6 1.6 0 0 1-1.5.9c-.5 0-1-.2-1.3-.7-.4-.4-.6-1-.6-2s.2-1.8.6-2.2c.4-.5.8-.7 1.4-.7.4 0 .7.2 1 .4.3.2.5.6.5 1ZM5.5 12v.7H1.9v-.5l.5-.7.9-.8 1.2-1.2c.2-.3.3-.5.3-.8 0-.2-.1-.5-.3-.6a1 1 0 0 0-.8-.3A1 1 0 0 0 3 8a1 1 0 0 0-.3.8L2 8.8c0-.5.2-.9.5-1.2.3-.2.7-.4 1.3-.4.5 0 .9.2 1.2.5.3.3.4.6.4 1v.7l-.5.6-1 1a11.2 11.2 0 0 0-1.1 1h2.7Zm2.8.7v-1.3H5.9v-.6l2.5-3.5H9v3.5h.7v.6H9v1.3h-.7Zm7-1.6v.6l.5.4.5.1c.4 0 .6 0 .8-.3.2-.2.3-.5.3-.8a1 1 0 0 0-.3-.8 1 1 0 0 0-.8-.3 1 1 0 0 0-1 1.1ZM11 11l.1.7.5.5.5.1c.3 0 .5-.1.7-.3.2-.3.3-.6.3-1 0-.3 0-.6-.3-.8a1 1 0 0 0-.7-.4 1 1 0 0 0-.8.4c-.2.2-.3.5-.3.8Zm-2.8-.1V8.3l-1.7 2.5h1.7Zm7.2-2.2c0 .3 0 .5.2.6l.6.3c.3 0 .5-.1.7-.3l.2-.6c0-.2 0-.4-.2-.6a.9.9 0 0 0-.7-.2c-.2 0-.4 0-.6.2-.2.2-.2.4-.2.6Z",
              fill: y(Ws)(e.constraint.style.color),
            },
            null,
            8,
            gx
          ),
        ])
      );
    },
  });
function yx(t) {
  return (
    typeof t == "function" ||
    (Object.prototype.toString.call(t) === "[object Object]" && !Nt(t))
  );
}
function qu(t) {
  return {
    default() {
      return [
        c(
          "rect",
          {
            x: -t.style.size / 2,
            y: -t.style.size / 2,
            width: t.style.size,
            height: t.style.size,
            fill: t.style.color,
          },
          null
        ),
      ];
    },
  };
}
_e({
  type: _.Even,
  label: "Even",
  preview: vx,
  renderers: (t) => {
    let e;
    return [
      {
        layer: oe.Default,
        component: c(
          is,
          { cells: t.cells },
          yx((e = qu(t))) ? e : { default: () => [e] }
        ),
      },
    ];
  },
  editor: xe({
    editor: { component: gl, props: (t) => sn(t, "cells"), slots: qu },
    appearanceForm: {
      props: (t) => ({
        properties: [
          {
            type: "color",
            name: "color",
            label: "Color",
            value: t.style.color,
          },
          { type: "size", name: "size", label: "Size", value: t.style.size },
        ],
      }),
    },
  }),
});
const Cx = S({
    __name: "FogLightEditor",
    props: { context: {}, lightCells: {} },
    setup(t) {
      const e = t,
        n = j(),
        s = b(() => {
          const u = e.context.helpers,
            p = new Set();
          if (Ne.showFog)
            for (const m of u.cellIds.getAllCellIds()) {
              const g = m === n.value;
              !e.lightCells.includes(m) && !g && p.add(m);
            }
          return {
            fogCells: p,
            lightBulbs:
              n.value !== void 0
                ? Lt.withoutAll(e.lightCells, [n.value])
                : e.lightCells,
          };
        }),
        o = b(() => {
          const u = e.context.constraints.find(
            (p) => p.enabled && p.config.type === _.Regions
          );
          if (u) return u.config.regions;
        });
      let r = fe();
      const l = j(),
        i = j(!1);
      ae(l, () => {
        n.value = i.value ? void 0 : l.value;
      }),
        Vn({
          onDragStart: (u) => {
            u.cellId !== void 0 &&
              ((r = fe()),
              (i.value = e.lightCells.includes(u.cellId)),
              a(u.cellId));
          },
          onDragMove: (u) => {
            u.cellId !== void 0 && u.pointerDown && a(u.cellId);
          },
          onDragEnd: () => {
            i.value = !1;
          },
          onHover: (u) => {
            l.value = u.cellId;
          },
          onHoverEnd: () => {
            l.value = void 0;
          },
        });
      function a(u) {
        let p = e.lightCells;
        if (
          (i.value
            ? (p = Lt.withoutAll(e.lightCells, [u]))
            : e.lightCells.includes(u) || (p = e.lightCells.concat(u)),
          Ce(e.lightCells, p))
        )
          return;
        const m = i.value ? "delete" : "add";
        e.context.updateConstraint({ lightCells: p }, m, r);
      }
      return (u, p) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              yt,
              { class: "FogEditor", context: u.context },
              {
                properties: f(() => [
                  c(lt, null, {
                    default: f(
                      () =>
                        p[0] ||
                        (p[0] = [
                          F(
                            " Note: the solver does not take fog into account and will solve the grid as if the fog was not there. "
                          ),
                        ])
                    ),
                    _: 1,
                  }),
                ]),
                _: 1,
              },
              8,
              ["context"]
            ),
            c(
              ct,
              { layer: y(oe).AboveDigits },
              {
                default: f(() => [
                  c(
                    ol,
                    {
                      "fog-cells": s.value.fogCells,
                      regions: o.value,
                      transparent: "",
                    },
                    null,
                    8,
                    ["fog-cells", "regions"]
                  ),
                  c(Ip, { "light-bulb-cells": s.value.lightBulbs }, null, 8, [
                    "light-bulb-cells",
                  ]),
                ]),
                _: 1,
              },
              8,
              ["layer"]
            ),
          ],
          64
        )
      );
    },
  }),
  wx = {
    class: "FogPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    "stroke-linecap": "round",
  },
  bx = S({
    __name: "FogPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "svg",
          wx,
          n[0] ||
            (n[0] = [
              h(
                "path",
                {
                  d: "M4 4h12v12H4zm4 0v12m4-12v12M4 8h12M4 12h12",
                  stroke: "#000",
                  fill: "none",
                  "stroke-width": "1",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M10,12l-10,-5.774M10,12l0,-12M10,12l-6.928,-12M10,12l6.928,-12M10,12l10,-5.774",
                  stroke: "#0008",
                  "stroke-width": "2",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M10,12l-10,-5.774M10,12l0,-12M10,12l-6.928,-12M10,12l6.928,-12M10,12l10,-5.774",
                  stroke: "#fd0",
                  "stroke-width": "1",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M15 8h.25a3.5 3.5 0 0 1 0 7H4.75a3.5 3.5 0 0 1 0-7h.31a2 2 0 0 1 2.61-1.4A3.75 3.75 0 0 1 15 8Z",
                  fill: "#bbb",
                },
                null,
                -1
              ),
            ])
        )
      );
    },
  });
_e({
  type: _.FogLights,
  label: "Fog lights",
  preview: bx,
  editor: xe({
    editor: { component: Cx, props: (t) => ({ lightCells: t.lightCells }) },
  }),
  ignoredBySolver: !0,
  actions: (t, e) => {
    const n = e.size.width * e.size.height;
    return [
      {
        label: "Clear fog",
        icon: Lp,
        disabled: t.lightCells.length === n,
        callback: (s, o) => ({ ...s, lightCells: new jr(o).getAllCellIds() }),
      },
      {
        label: "Cover grid",
        icon: Ep,
        disabled: t.lightCells.length === 0,
        callback: (s) => ({ ...s, lightCells: [] }),
      },
    ];
  },
});
function kx() {
  const t = j();
  function e(s) {
    var o, r, l, i;
    (r = (o = t.value) == null ? void 0 : o.onExit) == null || r.call(o),
      (t.value = s),
      (i = (l = t.value).onEnter) == null || i.call(l);
  }
  Vn({
    onDelete() {
      var s, o;
      (o = (s = t.value) == null ? void 0 : s.onDelete) == null || o.call(s);
    },
    onSelectAll() {
      var s, o;
      (o = (s = t.value) == null ? void 0 : s.onSelectAll) == null || o.call(s);
    },
    onInput(s) {
      var o, r;
      (r = (o = t.value) == null ? void 0 : o.onInput) == null || r.call(o, s);
    },
    onPointerAction(s) {
      var o, r;
      (r = (o = t.value) == null ? void 0 : o.onAction) == null || r.call(o, s);
    },
    onHover(s) {
      var o, r;
      (r = (o = t.value) == null ? void 0 : o.onHover) == null || r.call(o, s);
    },
    onHoverEnd(s) {
      var o, r;
      (r = (o = t.value) == null ? void 0 : o.onHoverEnd) == null ||
        r.call(o, s);
    },
    onDragStart(s) {
      var o, r;
      (r = (o = t.value) == null ? void 0 : o.onDragStart) == null ||
        r.call(o, s);
    },
    onDragMove(s) {
      var o, r;
      (r = (o = t.value) == null ? void 0 : o.onDragMove) == null ||
        r.call(o, s);
    },
    onDragEnd(s) {
      var o, r;
      (r = (o = t.value) == null ? void 0 : o.onDragEnd) == null ||
        r.call(o, s);
    },
    onPointerDown(s) {
      var o, r;
      (r = (o = t.value) == null ? void 0 : o.onPointerDown) == null ||
        r.call(o, s);
    },
    onPointerMove(s) {
      var o, r;
      (r = (o = t.value) == null ? void 0 : o.onPointerMove) == null ||
        r.call(o, s);
    },
    onPointerUp(s) {
      var o, r;
      (r = (o = t.value) == null ? void 0 : o.onPointerUp) == null ||
        r.call(o, s);
    },
  });
  function n(s) {
    return Al(s) === Al(t.value);
  }
  return { isCurrentState: n, setState: e };
}
function _x(t) {
  const e = j("add"),
    n = j(new Set()),
    s = j([]);
  let o = fe();
  const r = b(() => t.elements.value.filter((k) => n.value.has(k.position))),
    { setState: l } = kx();
  function i() {
    var k;
    (n.value = new Set()),
      (k = t.disabled) != null && k.value ? l($) : l(e.value === "add" ? p : v);
  }
  ae(e, i),
    ae(t.elements, (k) => {
      const M = Kn(k, (P) => P.position);
      He.hasSomeWhere(n.value, (P) => !M.includes(P)) && i(),
        t.elements.value.length === 0 && (e.value = "add");
    }),
    t.disabled &&
      ae(t.disabled, (k) => {
        k ? l($) : e.value !== "add" ? (e.value = "add") : l(p);
      });
  function a(k) {
    const M = [
      ...t.elements.value,
      { position: k, value: gn(t.defaultValue, k) || "" },
    ];
    t.updateConstraint(M, "add", o);
  }
  function u(k) {
    k instanceof Set || (k = new Set([k]));
    const M = t.elements.value.filter((P) => !He.hasSome(k, [P.position]));
    t.updateConstraint(M, "delete", o);
  }
  Vn({
    onInput: (k) => {
      var x;
      if ((x = t.disabled) != null && x.value) return;
      const M = k.string,
        P = t.elements.value.map((A) =>
          n.value.has(A.position) ? { value: M, position: A.position } : A
        );
      Ce(P, t.elements.value) || t.updateConstraint(P, "update", o);
    },
  });
  const p = {
      onSelectAll: () => {
        n.value = new Set(t.elements.value.map((k) => k.position));
      },
      onDragStart: (k) => {
        const M = t.getPosition(k);
        if (M === void 0) {
          ye.isSelecting() || i();
          return;
        }
        (o = fe()),
          (s.value = [...t.elements.value]),
          t.elements.value.find((x) => M === x.position)
            ? ye.isSelecting()
              ? He.hasSome(n.value, [M])
                ? He.deleteAll(n.value, [M])
                : (n.value.add(M), l(m))
              : ((n.value = new Set([M])), l(m))
            : (a(M), (n.value = new Set([M])), l(g));
      },
      onDelete: () => {
        u(n.value);
      },
    },
    m = {
      onDragMove: (k) => {
        const M = t.getPosition(k);
        if (M === void 0) return;
        t.elements.value.find((x) => M === x.position) && n.value.add(M);
      },
      onDragEnd: () => {
        l(p);
      },
    },
    g = {
      onDragMove: (k) => {
        const M = t.getPosition(k);
        if (M === void 0) return;
        t.elements.value.find((x) => M === x.position) ? n.value.add(M) : a(M);
      },
      onDragEnd: () => {
        var k;
        l(p), (k = t.onActionFinish) == null || k.call(t, "add", s.value);
      },
    },
    v = {
      onDragStart: (k) => {
        const M = t.getPosition(k);
        M !== void 0 && ((o = fe()), u(M));
      },
      onDragMove: (k) => {
        const M = t.getPosition(k);
        M === void 0 || !k.pointerDown || u(M);
      },
    },
    $ = {};
  return l(p), { mode: e, selectedElements: r, reset: i };
}
const $x = S({
    __name: "RevealPatternSelector",
    props: { modelValue: {} },
    emits: ["update:modelValue"],
    setup(t, { emit: e }) {
      const n = t,
        s = e;
      let o = fe();
      const r = j(!1);
      function l() {
        (o = fe()), (r.value = !0);
      }
      const i = b(() => [
          { value: Be.Self, label: "itself" },
          { value: Be.OrthogonalNeighbors, label: "orthogonal neighbors" },
          { value: Be.DiagonalNeighbors, label: "diagonal neighbors" },
          { value: Be.Row, label: "containing row" },
          { value: Be.Column, label: "containing column" },
          { value: Be.KnightsMoves, label: "all cells a knight’s move away" },
        ]),
        a = b(() => {
          const p = n.modelValue;
          if (p.length === 0) return "nothing";
          const m =
              p.includes(Be.Self) &&
              p.includes(Be.OrthogonalNeighbors) &&
              p.includes(Be.DiagonalNeighbors),
            g = [];
          return (
            m
              ? g.push("the surrounding 3x3")
              : (p.includes(Be.Self) && g.push("itself"),
                p.includes(Be.OrthogonalNeighbors) &&
                  g.push("orthogonal neighbors"),
                p.includes(Be.DiagonalNeighbors) &&
                  g.push("diagonal neighbors")),
            p.includes(Be.Row) && g.push("its row"),
            p.includes(Be.Column) && g.push("its column"),
            p.includes(Be.KnightsMoves) && g.push("cells a knight’s move away"),
            At(g)
          );
        });
      function u(p) {
        const m = [...n.modelValue];
        m.includes(p) ? Lt.removeFirst(m, p) : m.push(p),
          s("update:modelValue", m, o);
      }
      return (p, m) => (
        d(),
        C(
          Z,
          null,
          [
            h("button", { class: "triggerButton", onClick: l }, [
              h("span", null, "On cell input, clear " + X(a.value), 1),
              c(ls),
            ]),
            c(
              tl,
              {
                show: r.value,
                align: "left",
                fixate: "",
                onClose: m[0] || (m[0] = (g) => (r.value = !1)),
              },
              {
                default: f(() => [
                  (d(!0),
                  C(
                    Z,
                    null,
                    se(
                      i.value,
                      (g) => (
                        d(),
                        w(
                          Ge,
                          { key: g.value, onClick: (v) => u(g.value) },
                          {
                            default: f(() => [
                              c(
                                at,
                                { checked: p.modelValue.includes(g.value) },
                                null,
                                8,
                                ["checked"]
                              ),
                              F(" " + X(g.label), 1),
                            ]),
                            _: 2,
                          },
                          1032,
                          ["onClick"]
                        )
                      )
                    ),
                    128
                  )),
                ]),
                _: 1,
              },
              8,
              ["show"]
            ),
          ],
          64
        )
      );
    },
  }),
  Sx = B($x, [["__scopeId", "data-v-24233881"]]),
  Ix = { components: { Icon: he } };
function xx(t, e, n, s, o, r) {
  const l = H("Icon");
  return (
    d(),
    w(
      l,
      {
        class: "Flag",
        viewBox: "0 0 16 16",
        "stroke-width": "1",
        "stroke-linejoin": "round",
      },
      {
        default: f(
          () =>
            e[0] ||
            (e[0] = [
              h(
                "path",
                {
                  d: "M15.2 7.1s-.8 1.8-2.5 2.2c-1.8.5-3.3-.6-5-.2-1.8.5-2.7 1.5-2.7 1.5L3.2 4.2s1-1 2.7-1.5c1.7-.5 3.3.6 5 .2 1.8-.5 2.5-2.2 2.5-2.2L15.2 7Z",
                  fill: "#f8c",
                  stroke: "currentColor",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M2.8 2.6 6.1 15l-1.6.4L1.2 3.1l1.6-.5Z",
                  fill: "#ccc",
                  stroke: "currentColor",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M1.7 1.7c.7-.2 1.3.2 1.5.8.2.7-.2 1.4-.9 1.5-.6.2-1.3-.2-1.5-.8-.2-.7.2-1.3.9-1.5Z",
                  fill: "var(--mainBgColor)",
                  stroke: "currentColor",
                },
                null,
                -1
              ),
            ])
        ),
        _: 1,
      }
    )
  );
}
const Dx = B(Ix, [["render", xx]]),
  Mx = [..."abcdefghijklmnopqrstuvwxyz0123456789"].map((t) => {
    const e = t.toUpperCase();
    return new $s({ input: e, label: e, hotkeys: [t, e] });
  });
function Ax() {
  return {
    panel: Mx,
    type: Ke.CosmeticText,
    zeroButton: new $s({
      label: () => Qt(Dx, { style: "margin: 0.5rem" }),
      input: "!",
      hotkeys: ["!"],
      tooltip: 'Toggle default fog clearing (Shortcut key: "!")',
    }),
    deleteButton: !0,
  };
}
const Px = ["transform"],
  Lx = S({
    __name: "OverrideVisual",
    props: { cell: {} },
    setup(t) {
      const e = t,
        { helpers: n } = Qe(et).value,
        s = b(() => n.cellIds.getCellCenterFromId(e.cell));
      return (o, r) => (
        d(),
        C(
          "g",
          { transform: `translate(${s.value.x} ${s.value.y})` },
          r[0] ||
            (r[0] = [
              h(
                "path",
                {
                  d: "M0.2 0.11v0.24M0.2 0.13h0.16v0.12h-0.16",
                  stroke: "#000",
                  fill: "#f8c",
                  "stroke-width": "0.025",
                  "stroke-linecap": "round",
                },
                null,
                -1
              ),
            ]),
          8,
          Px
        )
      );
    },
  }),
  Ex = { transform: "scale(0.015) translate(-9 -11)" },
  Fx = ["stroke", "stroke-width"],
  Bx = ["stroke", "stroke-width"],
  zx = ["fill"],
  Rx = ["fill"],
  Ox = S({
    __name: "LockIcon",
    props: { highlight: { type: Boolean } },
    setup(t) {
      return (e, n) => (
        d(),
        C("g", Ex, [
          n[0] ||
            (n[0] = h(
              "g",
              { stroke: "#fff", "stroke-width": "5" },
              [
                h("path", {
                  d: "M12 5v4a4 4 0 0 1-8 0V5a4 4 0 0 1 8 0Z",
                  fill: "none",
                }),
                h("path", {
                  d: "M15.5 10.1v8.8c0 .88-.72 1.6-1.6 1.6H2.1a1.6 1.6 0 0 1-1.6-1.6v-8.8c0-.88.72-1.6 1.6-1.6h11.8c.88 0 1.6.72 1.6 1.6Z",
                }),
              ],
              -1
            )),
          h(
            "path",
            {
              d: "M12 5v4a4 4 0 0 1-8 0V5a4 4 0 0 1 8 0Z",
              fill: "none",
              stroke: e.highlight ? "#fff" : "#000",
              "stroke-width": e.highlight ? 2 : 1,
            },
            null,
            8,
            Fx
          ),
          h(
            "path",
            {
              d: "M15.5 10.1v8.8c0 .88-.72 1.6-1.6 1.6H2.1a1.6 1.6 0 0 1-1.6-1.6v-8.8c0-.88.72-1.6 1.6-1.6h11.8c.88 0 1.6.72 1.6 1.6Z",
              fill: "#9caec4",
              stroke: e.highlight ? "#fff" : "#000",
              "stroke-width": e.highlight ? 2 : 1,
            },
            null,
            8,
            Bx
          ),
          h(
            "circle",
            { cx: "8", cy: "13", r: "2", fill: e.highlight ? "#fff" : "#000" },
            null,
            8,
            zx
          ),
          h(
            "path",
            {
              d: "M9 14v3a1 1 0 0 1-2 0v-3a1 1 0 0 1 2 0Z",
              fill: e.highlight ? "#fff" : "#000",
            },
            null,
            8,
            Rx
          ),
        ])
      );
    },
  }),
  Nx = ["opacity"],
  Tx = ["d", "stroke"],
  Vx = ["d", "stroke"],
  jx = ["d", "stroke"],
  Ux = ["transform"],
  Hx = S({
    __name: "TriggerEffectVisual",
    props: {
      effect: {},
      selected: { type: Boolean },
      highlight: { type: Boolean },
      editing: { type: Boolean },
    },
    setup(t) {
      const e = t,
        { helpers: n } = Qe(et).value,
        s = b(() => (Ne.showFog ? "#fe0c" : "#eb0c")),
        o = b(() => (Ne.showFog ? "#fff" : "#9caec4")),
        r = b(() => e.effect.label || ""),
        l = b(() =>
          Kn(
            n.connectivity.getOrthogonallyConnectedGroups(e.effect.cells),
            (a) => a.getPoints()
          ).map((a) => {
            const u = a.map((g) => n.cellIds.getCoordsFromId(g)),
              p = new Mr(u, 0.06667).getSvgDString(),
              m = new Mr(u, 0.1).getSvgDString();
            return {
              d: p,
              d2: m,
              topLeftCorner: n.cellIds.getCoordsFromId(Math.min(...a)),
            };
          })
        );
      return (i, a) => (
        d(!0),
        C(
          Z,
          null,
          se(
            l.value,
            ({ d: u, d2: p, topLeftCorner: m }, g) => (
              d(),
              C(
                "g",
                { key: g, opacity: i.editing ? 1 : 0.75 },
                [
                  i.highlight
                    ? (d(),
                      C(
                        "path",
                        {
                          key: 0,
                          d: p,
                          stroke: s.value,
                          "stroke-width": "0.12",
                          fill: "none",
                        },
                        null,
                        8,
                        Tx
                      ))
                    : z("", !0),
                  i.selected
                    ? (d(),
                      C(
                        "path",
                        {
                          key: 1,
                          d: u,
                          stroke: y(ee).selectionColor,
                          "stroke-width": "0.12",
                          fill: "none",
                        },
                        null,
                        8,
                        Vx
                      ))
                    : z("", !0),
                  h(
                    "path",
                    {
                      d: u,
                      stroke: o.value,
                      "stroke-dasharray": "0.05 0.1",
                      "stroke-linecap": "square",
                      "stroke-width": "0.04",
                      fill: "none",
                    },
                    null,
                    8,
                    jx
                  ),
                  h(
                    "g",
                    { transform: `translate(${m.x + 0.15} ${m.y + 0.15})` },
                    [
                      c(
                        kn,
                        {
                          value: r.value,
                          x: 0.15,
                          y: 0,
                          "font-size": 0.3,
                          stroke: i.highlight && !i.selected ? s.value : "#fff",
                          "stroke-width": "0.06",
                          "paint-order": "stroke",
                          align: "left",
                          "show-caret": i.selected,
                        },
                        null,
                        8,
                        ["value", "stroke", "show-caret"]
                      ),
                      c(Ox),
                    ],
                    8,
                    Ux
                  ),
                ],
                8,
                Nx
              )
            )
          ),
          128
        )
      );
    },
  }),
  Wx = ["transform", "opacity"],
  Zx = ["r", "stroke"],
  Gx = ["r", "stroke"],
  qx = ["r"],
  Kx = ["r"],
  Xx = S({
    __name: "TriggerVisual",
    props: {
      trigger: {},
      selected: { type: Boolean },
      highlight: { type: Boolean },
      editing: { type: Boolean },
    },
    setup(t) {
      const e = t,
        { helpers: n } = Qe(et).value,
        s = b(() => (e.editing ? 1 : 0.7)),
        o = b(() => n.cellIds.getCellCenterFromId(e.trigger.cell)),
        r = b(() => e.trigger.label || ""),
        l = b(() => (Ne.showFog ? "#fe0" : "#eb0"));
      return (i, a) => (
        d(),
        C(
          "g",
          {
            transform: `translate(${o.value.x} ${o.value.y})`,
            opacity: 0.75 * s.value,
          },
          [
            i.highlight
              ? (d(),
                C(
                  "circle",
                  {
                    key: 0,
                    r: 0.4 * s.value,
                    fill: "none",
                    stroke: l.value,
                    "stroke-width": "0.125",
                  },
                  null,
                  8,
                  Zx
                ))
              : z("", !0),
            i.selected
              ? (d(),
                C(
                  "circle",
                  {
                    key: 1,
                    r: 0.3 * s.value,
                    fill: "none",
                    stroke: y(ee).selectionColor,
                    "stroke-width": "0.125",
                  },
                  null,
                  8,
                  Gx
                ))
              : z("", !0),
            h(
              "circle",
              {
                r: 0.35 * s.value,
                fill: "none",
                stroke: "#0008",
                "stroke-width": "0.025",
              },
              null,
              8,
              qx
            ),
            h(
              "circle",
              {
                r: 0.25 * s.value,
                fill: "none",
                stroke: "#0008",
                "stroke-width": "0.025",
              },
              null,
              8,
              Kx
            ),
            c(
              kn,
              {
                value: r.value,
                "font-size": 0.3 * s.value,
                stroke: "#fff",
                "stroke-width": "0.05",
                "paint-order": "stroke",
                "show-caret": i.selected,
              },
              null,
              8,
              ["value", "font-size", "show-caret"]
            ),
          ],
          8,
          Wx
        )
      );
    },
  }),
  Yx = S({
    __name: "FogTriggerEditor",
    props: {
      context: {},
      patterns: {},
      triggers: {},
      patternOverrides: {},
      effects: {},
      defaultDisabling: { type: Boolean },
    },
    setup(t) {
      const e = t,
        n = b(() =>
          e.context.project
            .getEnabledConstraints()
            .some(
              (R) =>
                R.config.type === _.FogTriggers && R.config.patterns.length > 0
            )
        );
      function s(R, W) {
        e.context.updateConstraint(
          { patterns: R },
          "update reveal patterns",
          W
        );
      }
      function o(R) {
        e.context.updateConstraint(
          { editor: { defaultDisabling: R } },
          "update triggers"
        );
      }
      const r = j(!1),
        l = j("triggers");
      function i() {
        return Nk(new Set(e.triggers.map((R) => R.label)));
      }
      const a = j(i()),
        u = {
          ...Ax(),
          callback: (R) => {
            if (String(R).includes("!")) return U(), !0;
          },
        },
        p = b(() => {
          if (k.value.length + m.value.length !== 0) return u;
        }),
        {
          selectedElements: m,
          mode: g,
          reset: v,
        } = _x({
          getPosition: (R) => R.cellId,
          elements: b(() =>
            e.triggers.map((R) => ({ value: R.label, position: R.cell }))
          ),
          helpers: e.context.helpers,
          project: e.context.project,
          updateConstraint: (R, W, T) => {
            const Y = R.map((de) => de.position),
              J = e.triggers.map((de) => de.cell),
              re = [],
              ce = [];
            for (const de of R)
              re.push({ label: de.value, cell: de.position }),
                e.defaultDisabling &&
                  !J.includes(de.position) &&
                  ce.push(de.position);
            const ge = e.patternOverrides
              .concat(ce)
              .filter((de) => Y.includes(de));
            e.context.updateConstraint(
              { triggers: re, patternOverrides: ge },
              W,
              T
            );
          },
          disabled: b(() => l.value !== "triggers"),
          defaultValue: () => a.value,
          onActionFinish: async (R, W) => {
            if (R !== "add") return;
            await wn();
            const T = new Set(W.flatMap((J) => J.value));
            new Set(e.triggers.flatMap((J) => J.label)).size > T.size &&
              (l.value = "effects");
          },
        }),
        $ = b(() => {
          const R = m.value.map((W) => W.position);
          return e.triggers.filter((W) => R.includes(W.cell));
        }),
        {
          selectedCages: k,
          mode: M,
          deselect: P,
        } = of({
          cages: b(() =>
            e.effects.map((R) => ({ value: R.label, cells: R.cells }))
          ),
          helpers: e.context.helpers,
          project: e.context.project,
          updateConstraint: (R, W, T) => {
            const Y = R.map((J) => ({ label: J.value, cells: J.cells }));
            e.context.updateConstraint({ effects: Y }, W, T);
          },
          disabled: b(() => l.value !== "effects"),
          defaultValue: () => a.value,
        }),
        x = b({
          get() {
            return l.value === "effects" ? M.value : g.value;
          },
          set(R) {
            l.value === "effects" ? (M.value = R) : (g.value = R);
          },
        }),
        A = b(() =>
          l.value === "effects"
            ? e.effects.length === 0
            : e.triggers.length === 0
        ),
        O = b(() => {
          const R = k.value.flatMap((W) => W.cells);
          return e.effects.filter((W) => Lt.includesSome(R, W.cells));
        }),
        V = b(() => {
          var R, W;
          return l.value === "effects"
            ? (R = k.value[0]) == null
              ? void 0
              : R.value
            : (W = m.value[0]) == null
            ? void 0
            : W.value;
        });
      er({ inputMode: p, selectedValue: V }),
        ot("input", (R) => {
          a.value = R.string;
        }),
        ae(V, () => {
          V.value && (a.value = V.value);
        }),
        ae(l, () => {
          l.value === "triggers" ? ((a.value = i()), P()) : v();
        });
      function I(R) {
        return V.value !== void 0 ? V.value === R : a.value === R;
      }
      function U() {
        let R = [
          ...He.union(
            new Set(e.patternOverrides),
            $.value.map((W) => W.cell)
          ),
        ];
        R.length === e.patternOverrides.length &&
          (R = Lt.withoutAll(
            e.patternOverrides,
            $.value.map((W) => W.cell)
          )),
          e.context.updateConstraint(
            { patternOverrides: R },
            "update overrides"
          );
      }
      const D = b(() =>
          e.context.constraints
            .filter((W) => W.enabled && W.config.type === _.FogLights)
            .flatMap((W) => W.config.lightCells)
        ),
        N = b(() => {
          const R = e.context.constraints.find(
            (W) => W.enabled && W.config.type === _.Regions
          );
          if (R) return R.config.regions;
        }),
        E = b(() => {
          const R = e.context.helpers,
            W = new Set(),
            T = new Set(D.value);
          if (
            (e.effects.forEach((Y) => {
              I(Y.label) && He.addAll(T, Y.cells);
            }),
            Ne.showFog)
          )
            for (const Y of R.cellIds.getAllCellIds()) T.has(Y) || W.add(Y);
          return { fogCells: W, lightBulbs: T, regions: N.value };
        });
      return (R, W) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              yt,
              { class: "FogTriggersEditor", context: R.context },
              {
                properties: f(() => [
                  c(
                    ve,
                    { label: "Add/edit:" },
                    {
                      default: f(() => [
                        c(
                          Go,
                          {
                            value: l.value,
                            "onUpdate:value":
                              W[0] || (W[0] = (T) => (l.value = T)),
                            options: [
                              { label: "Triggers", value: "triggers" },
                              { label: "Cells to reveal", value: "effects" },
                            ],
                            variant: "horizontal",
                          },
                          null,
                          8,
                          ["value"]
                        ),
                      ]),
                      _: 1,
                    }
                  ),
                  c(ns, null, {
                    default: f(() => [
                      r.value
                        ? (d(),
                          w(
                            Qp,
                            { key: 0 },
                            {
                              default: f(() => [
                                c(
                                  be,
                                  { vertical: "", gap: "" },
                                  {
                                    default: f(() => [
                                      c(
                                        ve,
                                        {
                                          label: "Default fog clearing:",
                                          vertical: "",
                                        },
                                        {
                                          default: f(() => [
                                            c(
                                              Sx,
                                              {
                                                "model-value": R.patterns,
                                                "onUpdate:modelValue": s,
                                              },
                                              null,
                                              8,
                                              ["model-value"]
                                            ),
                                          ]),
                                          _: 1,
                                        }
                                      ),
                                      n.value
                                        ? (d(),
                                          w(
                                            xn,
                                            {
                                              key: 0,
                                              checked: R.defaultDisabling,
                                              "onUpdate:checked": o,
                                            },
                                            {
                                              default: f(() => [
                                                W[5] ||
                                                  (W[5] = F(
                                                    " Flag triggers by default "
                                                  )),
                                                c(dt, null, {
                                                  default: f(
                                                    () =>
                                                      W[4] ||
                                                      (W[4] = [
                                                        F(
                                                          " Flagging a trigger cell will disable default fog clearing for that cell. "
                                                        ),
                                                      ])
                                                  ),
                                                  _: 1,
                                                }),
                                              ]),
                                              _: 1,
                                            },
                                            8,
                                            ["checked"]
                                          ))
                                        : z("", !0),
                                    ]),
                                    _: 1,
                                  }
                                ),
                              ]),
                              _: 1,
                            }
                          ))
                        : z("", !0),
                    ]),
                    _: 1,
                  }),
                ]),
                buttonsLeft: f(() => [
                  c(
                    te,
                    {
                      icon: "",
                      active: r.value,
                      onClick: W[1] || (W[1] = (T) => (r.value = !r.value)),
                    },
                    { default: f(() => [c(ra)]), _: 1 },
                    8,
                    ["active"]
                  ),
                ]),
                buttons: f(() => [
                  c(
                    te,
                    {
                      active: x.value === "add",
                      onClick: W[2] || (W[2] = (T) => (x.value = "add")),
                    },
                    {
                      default: f(() => W[6] || (W[6] = [F(" Add/edit ")])),
                      _: 1,
                    },
                    8,
                    ["active"]
                  ),
                  c(
                    te,
                    {
                      active: x.value === "delete",
                      disabled: A.value,
                      onClick: W[3] || (W[3] = (T) => (x.value = "delete")),
                    },
                    {
                      default: f(() => W[7] || (W[7] = [F(" Delete ")])),
                      _: 1,
                    },
                    8,
                    ["active", "disabled"]
                  ),
                ]),
                _: 1,
              },
              8,
              ["context"]
            ),
            c(
              ct,
              { layer: y(oe).AboveDigits },
              {
                default: f(() => [
                  c(
                    ol,
                    {
                      "fog-cells": E.value.fogCells,
                      regions: E.value.regions,
                      transparent: "",
                    },
                    null,
                    8,
                    ["fog-cells", "regions"]
                  ),
                  (d(!0),
                  C(
                    Z,
                    null,
                    se(
                      R.triggers,
                      (T, Y) => (
                        d(),
                        w(
                          Xx,
                          {
                            key: Y,
                            trigger: T,
                            selected: $.value.includes(T),
                            highlight: I(T.label),
                            editing: l.value === "triggers",
                          },
                          null,
                          8,
                          ["trigger", "selected", "highlight", "editing"]
                        )
                      )
                    ),
                    128
                  )),
                  (d(!0),
                  C(
                    Z,
                    null,
                    se(
                      R.effects,
                      (T, Y) => (
                        d(),
                        w(
                          Hx,
                          {
                            key: Y,
                            effect: T,
                            selected: O.value.includes(T),
                            highlight: I(T.label),
                            editing: l.value === "effects",
                          },
                          null,
                          8,
                          ["effect", "selected", "highlight", "editing"]
                        )
                      )
                    ),
                    128
                  )),
                  (d(!0),
                  C(
                    Z,
                    null,
                    se(
                      R.patternOverrides,
                      (T) => (
                        d(), w(Lx, { key: T, cell: T }, null, 8, ["cell"])
                      )
                    ),
                    128
                  )),
                ]),
                _: 1,
              },
              8,
              ["layer"]
            ),
          ],
          64
        )
      );
    },
  }),
  Jx = B(Yx, [["__scopeId", "data-v-15136ff0"]]),
  Qx = {
    class: "FogTriggersPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  e9 = S({
    __name: "FogTriggersPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "svg",
          Qx,
          n[0] ||
            (n[0] = [
              h(
                "path",
                {
                  d: "M4 4h12v12H4zm4 0v12m4-12v12M4 8h12M4 12h12",
                  stroke: "#000",
                  fill: "none",
                  "stroke-width": "1",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M15 8h.25a3.5 3.5 0 0 1 0 7H4.75a3.5 3.5 0 0 1 0-7h.31a2 2 0 0 1 2.61-1.4A3.75 3.75 0 0 1 15 8Z",
                  fill: "#bbb",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "m11.5 10.3-4.7 5.2c-.4.5-1.1.7-1.8.5-.4-.2-.8-.6-1-1-.2-.7 0-1.4.5-1.8l5.2-4.7A3.3 3.3 0 0 1 13.3 4l.2.1v.2L11.6 6l.5 1.8 1.8.5 1.7-1.7h.4a3.3 3.3 0 0 1-4.5 3.7Zm-6 4.8a.6.6 0 0 1-.6-.6c0-.3.2-.6.6-.6.3 0 .6.3.6.6 0 .4-.3.6-.6.6Z",
                  fill: "#fff",
                  "fill-rule": "evenodd",
                  stroke: "#000",
                  "stroke-width": "0.5",
                  "stroke-linejoin": "round",
                  "stroke-miterlimit": "2",
                },
                null,
                -1
              ),
            ])
        )
      );
    },
  });
_e({
  type: _.FogTriggers,
  label: "Custom fog clearing",
  preview: e9,
  editor: xe({
    editor: {
      component: Jx,
      props: (t) => {
        const e = [];
        for (const n of t.triggers)
          for (const s of n.cells) e.push({ cell: s, label: n.label });
        return {
          patterns: t.patterns,
          triggers: e,
          effects: t.effects,
          patternOverrides: t.overrides,
          defaultDisabling: t.editor.defaultDisabling,
        };
      },
    },
    updateFunc: (t, e) => {
      const {
        patterns: n,
        editor: s,
        effects: o,
        patternOverrides: r,
        triggers: l,
      } = e;
      n && (t.patterns = n),
        s && bn(t.editor, s),
        o && (t.effects = o),
        r && (t.overrides = r),
        l && (t.triggers = t9(l));
    },
  }),
  ignoredBySolver: !0,
});
function t9(t) {
  const e = new Map();
  for (const n of t) {
    const s = n.label;
    e.has(s) || e.set(s, { cells: [], label: n.label }),
      e.get(s).cells.push(n.cell);
  }
  return [...e.values()];
}
const n9 = { viewBox: "-1 -1 22 22", xmlns: "http://www.w3.org/2000/svg" },
  s9 = S({
    __name: "GivensPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "svg",
          n9,
          n[0] ||
            (n[0] = [
              h(
                "path",
                {
                  d: "M4.29 6.46h-.74v-4.7a4.93 4.93 0 0 1-1.47.89v-.7c.4-.2.77-.43 1.08-.71.3-.28.52-.54.65-.8h.48v6.02Zm7.6-.71v.71H7.92c0-.18.03-.35.09-.51.1-.27.26-.54.48-.8.23-.26.55-.56.97-.9a8.2 8.2 0 0 0 1.32-1.28c.23-.31.34-.6.34-.88 0-.3-.1-.54-.31-.74-.21-.2-.48-.3-.82-.3-.35 0-.64.1-.85.32-.21.2-.32.5-.32.88l-.76-.08c.05-.56.25-1 .59-1.29A2 2 0 0 1 10 .44c.57 0 1.03.16 1.36.48.34.31.5.71.5 1.18 0 .24-.04.48-.14.71-.1.23-.26.48-.49.73-.23.26-.6.61-1.13 1.06-.45.37-.73.62-.85.75a3.5 3.5 0 0 0-.32.4h2.95Zm-3.87 5.78.73-.1c.09.42.23.72.43.9.2.19.46.28.75.28a1.22 1.22 0 0 0 1.24-1.25 1.13 1.13 0 0 0-1.18-1.17c-.14 0-.31.03-.52.08l.08-.64h.12c.31 0 .6-.08.85-.24.25-.16.37-.42.37-.76a.9.9 0 0 0-.27-.67.97.97 0 0 0-.71-.26 1 1 0 0 0-.72.27c-.19.18-.3.45-.36.8l-.74-.12c.09-.5.3-.88.61-1.15.32-.27.72-.4 1.2-.4.32 0 .62.06.9.2a1.53 1.53 0 0 1 .85 1.35c0 .26-.07.5-.2.7-.15.22-.35.39-.63.52.36.08.63.25.83.5.2.26.3.59.3.97 0 .53-.2.97-.58 1.33-.38.37-.86.55-1.45.55a1.82 1.82 0 0 1-1.9-1.69Zm9.3 1.59v-1.44h-2.6V11l2.74-3.88h.6V11h.81v.68h-.8v1.44h-.75Zm0-2.12V8.3L15.45 11h1.87Zm-9.26 3.56v-.71h3.88v.57a9.87 9.87 0 0 0-2 3.7c-.15.5-.24 1.05-.28 1.65H8.9a8.99 8.99 0 0 1 2.1-5.21H8.06Zm6.77 3.82.7-.06c.07.33.18.57.35.72.17.15.39.23.65.23.23 0 .43-.06.6-.16.17-.1.3-.24.42-.41a3.67 3.67 0 0 0 .39-1.6l-.01-.15a1.7 1.7 0 0 1-1.43.79c-.5 0-.92-.18-1.26-.54a1.97 1.97 0 0 1-.52-1.43c0-.6.18-1.1.54-1.47.36-.37.8-.55 1.35-.55a1.92 1.92 0 0 1 1.8 1.2c.17.4.25.96.25 1.7 0 .76-.08 1.37-.25 1.83a1.93 1.93 0 0 1-1.9 1.4c-.46 0-.85-.14-1.14-.4-.3-.26-.48-.63-.54-1.1Zm3.02-2.64c0-.43-.12-.76-.34-1.01-.23-.25-.5-.37-.81-.37-.33 0-.62.13-.86.4-.24.26-.36.61-.36 1.04 0 .38.11.69.34.93.23.24.52.35.85.35.35 0 .63-.11.85-.35.22-.24.33-.57.33-1Z",
                },
                null,
                -1
              ),
            ])
        )
      );
    },
  });
_e({
  type: _.Givens,
  label: "Given digits",
  preview: s9,
  ignoredBySolver: !0,
  unique: !0,
});
const o9 = { viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg" },
  r9 = S({
    __name: "AntiKingPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "svg",
          o9,
          n[0] ||
            (n[0] = [
              h(
                "path",
                {
                  fill: "none",
                  stroke: "#000",
                  d: "M7 13h1m5 0h-1M7 7h2m4 0h-2M7 7v2m0 4v-1m6 1v-1m0-5v2M1 1h18v18H1zm0 6h6V1m6 0v6h6m-6 12v-6h6M7 19v-6H1",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M11.76 12.1H8.24L9 13h2l.76-.9Zm-1.32-4.15h.88v.79h-.88v.5c.32.14.57.44.7.81.17-.4.51-.67.9-.67.57 0 1.03.56 1.03 1.24 0 .68-.46 1.23-1.02 1.23h-4.1c-.56 0-1.02-.55-1.02-1.23 0-.68.46-1.24 1.02-1.24.4 0 .74.27.91.67.13-.37.38-.67.7-.82v-.5h-.88v-.78h.88v-.8h.88v.8Z",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  fill: "none",
                  stroke: "red",
                  d: "m2 14 4 4m-4 0 4-4m8 0 4 4m-4 0 4-4M14 2l4 4m-4 0 4-4M2 2l4 4M2 6l4-4",
                },
                null,
                -1
              ),
            ])
        )
      );
    },
  }),
  l9 = { viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg" },
  i9 = S({
    __name: "AntiKnightPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "svg",
          l9,
          n[0] ||
            (n[0] = [
              h(
                "path",
                {
                  fill: "none",
                  stroke: "#000",
                  d: "M7 13h6v6H7zm0-6h6v6H7zm0-6h6v6H7zm6 6h6v6h-6zM1 7h6v12H1zm0-6h6v6H1zm12 0h6v6h-6zm0 12h6v6h-6z",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M3.1 18h-.3v1h3v-1h-.2c-.3-1 .3-1.1.3-3 0-2-1.4-2.2-1.4-2.2l-.5-.6v.6h-.4l.1.3-.5.2v.3l-.7.6h-.3s-.4 1 .6 1c.6 0 .6-.3.6-.3h1S2.1 17.1 3 18Z",
                },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "m8 2 4 4m2 2 4 4m-4 0 4-4M8 6l4-4",
                  fill: "none",
                  stroke: "red",
                },
                null,
                -1
              ),
              h(
                "path",
                { d: "M1 13h1.5M7 13H6", fill: "none", stroke: "#000" },
                null,
                -1
              ),
            ])
        )
      );
    },
  }),
  a9 = { viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg" },
  u9 = S({
    __name: "DisjointGroupsPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "svg",
          a9,
          n[0] ||
            (n[0] = [
              Ro(
                '<path fill="none" stroke="#000" d="M1 1h18v18H1zm0 6h18M1 13h18M7 19V1m6 18V1"></path><circle cx="4" cy="4" r="1" fill="red"></circle><circle cx="10" cy="4" r="1" fill="red"></circle><circle cx="16" cy="4" r="1" fill="red"></circle><circle cx="16" cy="10" r="1" fill="red"></circle><circle cx="10" cy="10" r="1" fill="red"></circle><circle cx="4" cy="10" r="1" fill="red"></circle><circle cx="4" cy="16" r="1" fill="red"></circle><circle cx="10" cy="16" r="1" fill="red"></circle><circle cx="16" cy="16" r="1" fill="red"></circle>',
                10
              ),
            ])
        )
      );
    },
  }),
  c9 = {
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    "stroke-linecap": "square",
    "stroke-miterlimit": "1.5",
  },
  d9 = S({
    __name: "NonconsecutivePreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "svg",
          c9,
          n[0] ||
            (n[0] = [
              h(
                "path",
                {
                  d: "M3.92 12.13H3.1V9.07c-.3.28-.64.48-1.04.61v-.74c.21-.06.44-.2.69-.39.25-.2.42-.42.5-.68h.67v4.26ZM18.1 11.38v.75h-2.85c.03-.29.13-.56.28-.81.16-.26.46-.6.91-1.02.37-.34.6-.57.68-.7a.88.88 0 0 0 .17-.5c0-.17-.05-.31-.15-.4a.55.55 0 0 0-.4-.15c-.17 0-.3.05-.4.15-.1.1-.17.27-.18.5l-.81-.07c.05-.45.2-.77.46-.96.25-.2.56-.3.95-.3.41 0 .74.11.98.34.24.22.36.5.36.84 0 .2-.03.37-.1.55-.07.17-.18.35-.32.54-.1.12-.28.3-.54.54-.26.23-.42.39-.49.46-.06.08-.12.16-.16.24h1.61Z",
                  "fill-rule": "nonzero",
                },
                null,
                -1
              ),
              h(
                "path",
                { d: "M10 4v12", fill: "none", stroke: "#000" },
                null,
                -1
              ),
              h(
                "path",
                { d: "M16 4 4 16M16 16 4 4", fill: "none", stroke: "red" },
                null,
                -1
              ),
            ])
        )
      );
    },
  }),
  p9 = [
    [_.Antiking, "Antiking", r9],
    [_.Antiknight, "Antiknight", i9],
    [_.Nonconsecutive, "Non­consecutive", d9],
    [_.DisjointGroups, "Disjoint groups", u9],
  ];
p9.forEach(([t, e, n]) => {
  _e({ type: t, label: e, preview: n, selectable: !1, unique: !0 });
});
const f9 = {
    class: "GlobalEntropyPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  h9 = ["fill"],
  m9 = ["fill"],
  g9 = ["fill"],
  v9 = ["fill"],
  y9 = ["fill"],
  C9 = ["fill"],
  w9 = S({
    __name: "GlobalEntropyPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      const e = t,
        n = [
          0,
          6 / 9,
          1 / 9,
          2 / 9,
          8 / 9,
          5 / 9,
          7 / 9,
          4 / 9,
          3 / 9,
          0 / 9,
          6 / 9,
        ],
        s = b(() => e.constraint.groups.length),
        o = b(() => e.constraint.groups.map((l) => r(l)));
      function r(l) {
        const i = [...nn(l, e.context.spec.minDigit, e.context.spec.maxDigit)];
        i[1] || (i[1] = i[0]), i[2] || (i[2] = ((i[0] * 3) % 9) + 1);
        const a = e.context.spec.maxDigit - e.context.spec.minDigit + 1;
        return (
          (i[0] = Math.ceil((9 * i[0]) / a)),
          (i[1] = Math.ceil((9 * i[1]) / a)),
          (i[2] = Rt(Math.ceil((9 * i[2]) / a), 1, 9)),
          Hs({
            red: 0.5 + 0.5 * n[i[0]],
            green: 0.4 + 0.6 * n[i[1]],
            blue: 0.6 + 0.4 * n[i[2]],
            alpha: 1,
          })
        );
      }
      return (l, i) => (
        d(),
        C("svg", f9, [
          s.value === 1
            ? (d(),
              C(
                "path",
                {
                  key: 0,
                  d: "M1 1h9l-9 9zM10 1h9l-9 9zM1 10h9l-9 9zM10 10h9l-9 9z",
                  fill: o.value[0],
                },
                null,
                8,
                h9
              ))
            : z("", !0),
          s.value === 2
            ? (d(),
              C(
                Z,
                { key: 1 },
                [
                  h(
                    "rect",
                    {
                      x: "1",
                      y: "1",
                      width: "18",
                      height: "18",
                      fill: o.value[1],
                    },
                    null,
                    8,
                    m9
                  ),
                  h(
                    "path",
                    { d: "M1 1h18l-18 18z", fill: o.value[0] },
                    null,
                    8,
                    g9
                  ),
                ],
                64
              ))
            : s.value === 3
            ? (d(),
              C(
                Z,
                { key: 2 },
                [
                  h(
                    "rect",
                    {
                      x: "1",
                      y: "1",
                      height: "9",
                      width: "9",
                      fill: o.value[0],
                    },
                    null,
                    8,
                    v9
                  ),
                  h(
                    "rect",
                    {
                      x: "1",
                      y: "10",
                      height: "9",
                      width: "9",
                      fill: o.value[1],
                    },
                    null,
                    8,
                    y9
                  ),
                  h(
                    "rect",
                    {
                      x: "10",
                      y: "1",
                      height: "9",
                      width: "9",
                      fill: o.value[2],
                    },
                    null,
                    8,
                    C9
                  ),
                ],
                64
              ))
            : z("", !0),
          i[0] ||
            (i[0] = h(
              "path",
              {
                d: "M1 1H19V19H1zM10 1v18M1 10h18",
                stroke: "#000",
                fill: "none",
              },
              null,
              -1
            )),
        ])
      );
    },
  });
_e({
  type: _.GlobalEntropy,
  selectable: !1,
  label: (t, e) => ox(t.groups, e),
  preview: w9,
  editor: xe({
    propertiesForm: {
      component: bf,
      props: (t) => ({ groups: t.groups, isGlobal: !0 }),
    },
  }),
});
const b9 = S({
    components: { ColorInput: Cn, CellSymbolEditor: gl },
    props: {
      context: { type: Object, required: !0 },
      cells: { type: Array, required: !0 },
      style: { type: Object, required: !0 },
    },
    methods: {
      onColorUpdate(t, e) {
        this.context.updateConstraintAppearance(
          { color: t },
          "update:color",
          e
        );
      },
    },
  }),
  k9 = ["fill"];
function _9(t, e, n, s, o, r) {
  const l = H("ColorInput"),
    i = H("CellSymbolEditor");
  return (
    d(),
    w(
      i,
      { context: t.context, cells: t.cells },
      {
        properties: f(() => [G(t.$slots, "properties")]),
        appearance: f(() => [
          c(l, { color: t.style.color, onInput: t.onColorUpdate }, null, 8, [
            "color",
            "onInput",
          ]),
          G(t.$slots, "appearance"),
        ]),
        default: f(() => [
          h(
            "rect",
            {
              x: "-0.5",
              y: "-0.5",
              width: "1",
              height: "1",
              fill: t.style.color,
            },
            null,
            8,
            k9
          ),
        ]),
        _: 3,
      },
      8,
      ["context", "cells"]
    )
  );
}
const $9 = B(b9, [["render", _9]]),
  S9 = {
    class: "ColumnIndexerPreview",
    viewBox: "0 0 40 40",
    xmlns: "http://www.w3.org/2000/svg",
  },
  I9 = ["fill"],
  x9 = S({
    __name: "ColumnIndexerPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", S9, [
          h(
            "path",
            {
              fill: y(Ws)(e.constraint.style.color),
              d: "M10 10h10v10H10zM0 10h10v10H0zM30 20h10v10H30zM10 20h10v10H10z",
            },
            null,
            8,
            I9
          ),
          n[0] ||
            (n[0] = Ro(
              '<path d="M12.5 22v-.9h5v.8c-.5.5-1 1.2-1.4 2.1a12.9 12.9 0 0 0-1.6 4.9h-1c0-.6.2-1.4.4-2.3a11.7 11.7 0 0 1 2.4-4.5h-3.8Z" fill-rule="nonzero"></path><path d="M6.5 6.8 5 8.3 3.5 6.8" fill="none" stroke="#000"></path><path d="M15 9V5H5v3.3" fill="none" stroke="#000" stroke-linejoin="round" stroke-miterlimit="1.5"></path><path d="m33.5 33.2 1.5-1.5 1.5 1.5" fill="none" stroke="#000"></path><path d="M15 31v4h20v-3.3" fill="none" stroke="#000" stroke-linejoin="round" stroke-miterlimit="1.5"></path><path d="m2.4 16.8 1-.1c0 .5.2.9.5 1.1.3.3.6.4 1 .4.5 0 .9-.2 1.2-.5.3-.4.5-.9.5-1.5 0-.5-.2-1-.5-1.3-.3-.3-.7-.5-1.2-.5a1.7 1.7 0 0 0-1.5.8l-.9-.1.8-4.1h4v1H4l-.4 2c.4-.3 1-.4 1.5-.4.7 0 1.2.2 1.7.7.5.5.7 1.1.7 1.9 0 .7-.2 1.3-.6 1.8-.5.7-1.2 1-2 1s-1.4-.2-1.9-.6c-.4-.4-.7-1-.7-1.6ZM32.4 26.8l1-.1c0 .5.2.9.5 1.1.3.3.6.4 1 .4.5 0 .9-.2 1.2-.5.3-.4.5-.9.5-1.5 0-.5-.2-1-.5-1.3-.3-.3-.7-.5-1.2-.5a1.7 1.7 0 0 0-1.4.8l-1-.1.8-4.1h4v1H34l-.4 2c.4-.3 1-.4 1.5-.4.7 0 1.2.2 1.7.7.5.5.7 1.1.7 1.9 0 .7-.2 1.3-.6 1.8-.5.7-1.2 1-2 1s-1.4-.2-1.9-.6c-.4-.4-.7-1-.7-1.6ZM15.7 19v-2h-3.5v-.8L16 11h.8v5.2h1v.9h-1V19h-1Zm0-2.8v-3.6l-2.5 3.6h2.5Z" fill-rule="nonzero"></path>',
              6
            )),
        ])
      );
    },
  }),
  D9 = {
    class: "RowIndexerPreview",
    viewBox: "0 0 40 40",
    xmlns: "http://www.w3.org/2000/svg",
  },
  M9 = ["fill"],
  A9 = S({
    __name: "RowIndexerPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", D9, [
          h(
            "path",
            {
              d: "M10 20v10h10V20H10ZM10 30v10h10V30H10ZM20 0v10h10V0H20ZM20 20v10h10V20H20Z",
              fill: y(Ws)(e.constraint.style.color),
            },
            null,
            8,
            M9
          ),
          n[0] ||
            (n[0] = Ro(
              '<path d="m22.4 26.8 1-.1c.1.5.3 1 .6 1.1.2.3.5.4 1 .4.4 0 .8-.1 1-.5.4-.3.5-.7.5-1.1A1.5 1.5 0 0 0 25 25c-.2 0-.4 0-.7.2l.1-.9h.2a2 2 0 0 0 1.1-.3c.3-.2.5-.5.5-1 0-.3-.1-.6-.4-.9-.2-.2-.5-.3-.9-.3s-.7.1-1 .3l-.4 1.1-1-.2c.1-.6.4-1.1.8-1.5.4-.3 1-.5 1.6-.5.4 0 .8 0 1.2.3a2 2 0 0 1 1 1.7c0 .4 0 .7-.2 1-.2.2-.4.5-.8.6.5.1.8.3 1 .7.3.3.5.7.5 1.3 0 .6-.3 1.2-.8 1.7s-1.1.7-1.9.7c-.7 0-1.2-.2-1.7-.6-.4-.4-.7-1-.8-1.6Z" fill-rule="nonzero"></path><path d="M6.8 33.5 8.3 35l-1.5 1.5" fill="none" stroke="#000"></path><path d="M9 25H5v10h3.3" fill="none" stroke="#000" stroke-linejoin="round" stroke-miterlimit="1.5"></path><path d="M33.2 6.5 31.7 5l1.5-1.5" fill="none" stroke="#000"></path><path d="M31 25h4V5h-3.3" fill="none" stroke="#000" stroke-linejoin="round" stroke-miterlimit="1.5"></path><path d="m12.4 36.8 1-.1c0 .5.2.9.5 1.1.3.3.6.4 1 .4.5 0 .9-.2 1.2-.5.3-.4.5-.9.5-1.5 0-.5-.2-1-.5-1.3-.3-.3-.7-.5-1.2-.5a1.7 1.7 0 0 0-1.5.8l-.9-.1.8-4.1h4v1H14l-.4 2c.4-.3 1-.4 1.5-.4.7 0 1.2.2 1.7.7.5.5.7 1.1.7 1.9 0 .7-.2 1.3-.6 1.8-.5.7-1.2 1-2 1s-1.4-.2-1.9-.6c-.4-.4-.7-1-.7-1.6ZM22.4 6.8l1-.1c0 .5.2.9.5 1.1.3.3.6.4 1 .4.5 0 .9-.2 1.2-.5.3-.4.5-.9.5-1.5 0-.5-.2-1-.5-1.3-.3-.3-.7-.5-1.2-.5a1.7 1.7 0 0 0-1.4.8l-1-.1.8-4.1h4v1H24l-.4 2c.4-.3 1-.4 1.5-.4.7 0 1.2.2 1.7.7.5.5.7 1.1.7 1.9 0 .7-.2 1.3-.6 1.8-.5.7-1.2 1-2 1s-1.4-.2-1.9-.6c-.4-.4-.7-1-.7-1.6ZM17.5 23h-1c0-.4-.2-.7-.3-.9-.3-.2-.6-.4-1-.4l-.9.3c-.3.2-.5.5-.7 1-.2.4-.3 1-.3 1.8a2.3 2.3 0 0 1 2-1c.6 0 1.2.2 1.7.7.4.5.6 1 .6 1.9 0 .5 0 1-.3 1.4a2.4 2.4 0 0 1-2.2 1.3c-.8 0-1.4-.3-2-1-.5-.5-.7-1.5-.7-2.9 0-1.5.2-2.7.8-3.4.5-.6 1.2-.9 2-.9.7 0 1.2.2 1.6.5.4.4.6.9.7 1.5Zm-4 3.4c0 .3 0 .6.2 1 .1.2.3.5.6.6.3.2.5.3.8.3.4 0 .8-.2 1-.5.4-.4.5-.8.5-1.4 0-.5-.1-1-.4-1.3-.3-.3-.7-.5-1.1-.5-.5 0-.8.2-1.1.5-.4.3-.5.7-.5 1.3Z" fill-rule="nonzero"></path>',
              6
            )),
        ])
      );
    },
  });
function kf(t, e, n) {
  _e({
    type: t,
    label: e,
    preview: n,
    renderers: (s) => [
      {
        layer: oe.Background,
        component: c(zr, { cells: s.cells, color: s.style.color }, null),
      },
    ],
    editor: xe({
      editor: { component: $9, props: (s) => sn(s, "cells", "style") },
    }),
  });
}
kf(_.RowIndexer, "Row indexers", A9);
kf(_.ColumnIndexer, "Column indexers", x9);
_e({
  type: _.KillerCages,
  label: "Killer cages",
  preview: ha,
  renderers: (t) => {
    const e = t.cages.map((n) => ({
      cells: n.cells,
      value: n.value ? n.value.toString() : "",
    }));
    return [
      { layer: oe.Grid, component: c(fl, { cages: e, style: t.style }, null) },
    ];
  },
  editor: xe({
    editor: {
      component: fa,
      props: (t, { project: e }) => ({
        cages: t.cages.map((n) => ({
          cells: n.cells,
          value: n.value ? n.value.toString() : "",
        })),
        style: t.style,
        inputMode: {
          ...Zs(),
          validation(n) {
            return n === "" || Number(n) <= Cs(e.spec.maxDigit);
          },
        },
        maxSize: e.spec.digitCount,
        defaultValue: (n) =>
          n.includes(void 0) ? "" : n.reduce((s, o) => s + o).toString(),
      }),
    },
    updateFunc: (t, e) => {
      const { cages: n } = e;
      t.cages = n.map((s) => ({ cells: s.cells, value: Number(s.value) || 0 }));
    },
  }),
});
const P9 = ["transform"],
  Is = S({
    __name: "OutsideRenderer",
    props: { clues: {} },
    setup(t) {
      const e = t,
        { helpers: n } = Qe(et).value,
        s = b(() =>
          e.clues.map((o) => ({
            position: n.outerCellIds.getCellCenterFromId(o.outerCell),
            item: o,
          }))
        );
      return (o, r) => (
        d(!0),
        C(
          Z,
          null,
          se(
            s.value,
            (l, i) => (
              d(),
              C(
                "g",
                {
                  key: i,
                  transform: `translate(${l.position.x} ${l.position.y})`,
                },
                [G(o.$slots, "default", St({ ref_for: !0 }, l.item))],
                8,
                P9
              )
            )
          ),
          128
        )
      );
    },
  });
var zt = ((t) => (
  (t[(t.Custom = 0)] = "Custom"),
  (t[(t.Orthogonal = 1)] = "Orthogonal"),
  (t[(t.Diagonal = 2)] = "Diagonal"),
  t
))(zt || {});
const L9 = ["transform"],
  E9 = ["fill", "r"],
  tr = S({
    __name: "OuterGeometryEditor",
    props: {
      context: {},
      clues: {},
      type: { default: zt.Custom },
      bidirectional: { type: Boolean, default: !1 },
      defaultValue: { type: [String, Function], default: "" },
      customTypeProps: { default: void 0 },
      highlightRadius: { default: 0.4 },
      inputMode: { default: void 0 },
    },
    setup(t) {
      const e = t;
      function n({ outerCell: T, diagonal: Y }) {
        if (typeof e.defaultValue == "string") return e.defaultValue;
        const re = o({ outerCell: T, diagonal: Y }).map(
          (ce) => e.context.project.cells[ce].value
        );
        return e.defaultValue(re);
      }
      function s({ outerCell: T }) {
        return e.clues.find((Y) => Y.outerCell === T);
      }
      function o({ outerCell: T, diagonal: Y }) {
        var J;
        switch (e.type) {
          case zt.Custom:
            return (
              ((J = e.customTypeProps) == null ? void 0 : J.getCellIds(T, Y)) ||
              []
            );
          case zt.Diagonal:
            return [
              ...e.context.helpers.geometry.getCellsPointedAtByOuterClue(T, Y),
            ];
          case zt.Orthogonal:
            return [
              ...e.context.helpers.geometry.getCellsPointedAtByOuterClue(T),
            ];
        }
      }
      function r({ x: T, y: Y }) {
        const { width: J, height: re } = e.context.project.spec.size;
        return T < -1 ||
          T > J ||
          Y < -1 ||
          Y > re ||
          (e.type === zt.Orthogonal && (T < 0 || T >= J) && (Y < 0 || Y >= re))
          ? !1
          : T < 0 || T >= J || Y < 0 || Y >= re;
      }
      function l(T) {
        if (!r(T)) return;
        const Y = e.context.helpers.outerCellIds.getIdFromCoords(T),
          { width: J, height: re } = e.context.project.spec.size;
        let ce;
        const ge = s({ outerCell: Y });
        if (ge) ce = ge.diagonal;
        else if (
          (T.y === -1 && T.x === -1) ||
          (T.y === 0 && T.x === -1) ||
          (T.y === -1 && T.x === 0) ||
          (T.y === re && T.x === J) ||
          (T.y === re && T.x === J - 1) ||
          (T.y === re - 1 && T.x === J)
        )
          ce = Se.NegativeDiagonal;
        else if (
          (T.y === -1 && T.x === J) ||
          (T.y === 0 && T.x === J) ||
          (T.y === -1 && T.x === J - 1) ||
          (T.y === re && T.x === -1) ||
          (T.y === re && T.x === 0) ||
          (T.y === re - 1 && T.x === -1)
        )
          ce = Se.PositiveDiagonal;
        else if (T.y === -1)
          ce = T.offsetX > 0.5 ? Se.NegativeDiagonal : Se.PositiveDiagonal;
        else if (T.x === J)
          ce = T.offsetY > 0.5 ? Se.PositiveDiagonal : Se.NegativeDiagonal;
        else if (T.y === re)
          ce = T.offsetX > 0.5 ? Se.PositiveDiagonal : Se.NegativeDiagonal;
        else if (T.x === -1)
          ce = T.offsetY > 0.5 ? Se.NegativeDiagonal : Se.PositiveDiagonal;
        else return;
        return { outerCell: Y, diagonal: ce };
      }
      function i(T) {
        var ce;
        if (!e.bidirectional) return;
        const { width: Y, height: J } = e.context.project.spec.size,
          { helpers: re } = e.context;
        switch (e.type) {
          case zt.Custom:
            return (ce = e.customTypeProps) == null
              ? void 0
              : ce.getOpposite(T);
          case zt.Diagonal: {
            const { x: ge, y: de } = re.outerCellIds.getCoordsFromId(
                T.outerCell
              ),
              ze = () =>
                T.diagonal === Se.NegativeDiagonal
                  ? { x: Y - 1 - de, y: J - 1 - ge }
                  : { x: de, y: ge };
            return {
              outerCell: re.outerCellIds.getIdFromCoords(ze()),
              value: T.value,
              diagonal: T.diagonal,
            };
          }
          case zt.Orthogonal: {
            const { x: ge, y: de } = re.outerCellIds.getCoordsFromId(
                T.outerCell
              ),
              ze = () =>
                ge === -1 || ge === Y
                  ? { x: Y - 1 - ge, y: de }
                  : { x: ge, y: J - 1 - de };
            return {
              outerCell: re.outerCellIds.getIdFromCoords(ze()),
              value: T.value,
            };
          }
        }
      }
      const a = b(() => e.clues.length > 0),
        u = j([]),
        p = b(() =>
          u.value
            .map((T) => e.clues.find((Y) => T === Y.outerCell))
            .filter((T) => T)
        ),
        m = b(() => (p.value.length > 0 ? String(p.value[0].value) : void 0));
      function g() {
        u.value = [];
      }
      ae(
        () => e.clues,
        (T) => {
          u.value = u.value.filter((Y) => T.some((J) => Y === J.outerCell));
        }
      );
      function v() {
        u.value = e.clues.map((T) => T.outerCell);
      }
      const $ = b(() =>
        p.value.length === 0
          ? {}
          : { ...e.inputMode, deleteButton: p.value.length > 0 }
      );
      er({ inputMode: $, selectedValue: m });
      let k = fe();
      function M({ outerCell: T, diagonal: Y }, J = !1) {
        k = fe();
        let re = s({ outerCell: T, diagonal: Y });
        if (!re) {
          re = {
            value: n({ outerCell: T, diagonal: Y }),
            outerCell: T,
            diagonal: Y,
          };
          const ce = [...e.clues, re],
            ge = i(re);
          if (ge) {
            const de = ce.find(
              (ze) =>
                ze.outerCell === ge.outerCell && ze.diagonal === ge.diagonal
            );
            de && (_t(ce, [de]), (re.value = de.value));
          }
          e.context.updateConstraint({ clues: ce }, "add", k);
        }
        J || g(), u.value.includes(T) ? _t(u.value, [T]) : u.value.push(T);
      }
      function P(T) {
        const Y = p.value;
        if (Y.every((re) => re.value === T)) return;
        const J = ue(e.clues);
        for (const re of Y) {
          const ce = J.findIndex((ge) => ge.outerCell === re.outerCell);
          ce !== -1 && (J[ce].value = T);
        }
        e.context.updateConstraint({ clues: J }, "update", k);
      }
      function x(T) {
        const Y = e.clues.slice();
        for (const J of T) {
          const re = Y.findIndex((ce) => ce.outerCell === J.outerCell);
          re !== -1 && Y.splice(re, 1);
        }
        e.context.updateConstraint({ clues: Y }, "delete"), g();
      }
      function A({ outerCell: T }) {
        x(e.clues.filter((Y) => Y.outerCell === T));
      }
      function O() {
        x(p.value);
      }
      const {
          position: V,
          pointerAction: I,
          deleting: U,
          placing: D,
        } = ml({
          createOrSelectClue: M,
          deselect: g,
          selectAll: v,
          updateClueValue: P,
          deleteAt: A,
          deleteSelectedClues: O,
          getClueAt: s,
          getPlaceablePosition: l,
        }),
        N = b(
          () =>
            V.value &&
            e.context.helpers.outerCellIds.getCellCenterFromId(
              V.value.outerCell
            )
        ),
        E = b(() => {
          if (
            !(
              !U.value ||
              !V.value ||
              !e.clues.find((T) => T.outerCell === V.value.outerCell)
            )
          )
            return e.context.helpers.outerCellIds.getCellCenterFromId(
              V.value.outerCell
            );
        }),
        R = b(() => (V.value === void 0 ? [] : o(V.value))),
        W = b(() => [...new Set(p.value.flatMap((T) => o(T)))]);
      return (T, Y) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              yt,
              { class: "OuterGeometryEditor", context: T.context },
              os(
                {
                  buttons: f(() => [
                    c(
                      Ds,
                      {
                        mode: y(I),
                        "onUpdate:mode":
                          Y[0] ||
                          (Y[0] = (J) => (Rn(I) ? (I.value = J) : null)),
                        "can-delete": a.value,
                      },
                      null,
                      8,
                      ["mode", "can-delete"]
                    ),
                  ]),
                  _: 2,
                },
                [
                  T.$slots.description
                    ? {
                        name: "description",
                        fn: f(() => [G(T.$slots, "description")]),
                        key: "0",
                      }
                    : void 0,
                  T.$slots.properties
                    ? {
                        name: "properties",
                        fn: f(() => [G(T.$slots, "properties")]),
                        key: "1",
                      }
                    : void 0,
                  T.$slots.appearance
                    ? {
                        name: "appearance",
                        fn: f(() => [G(T.$slots, "appearance")]),
                        key: "2",
                      }
                    : void 0,
                ]
              ),
              1032,
              ["context"]
            ),
            c(ct, null, {
              default: f(() => [
                y(D) && y(V)
                  ? (d(),
                    C(
                      Z,
                      { key: 0 },
                      [
                        h(
                          "g",
                          {
                            transform: `translate(${N.value.x} ${N.value.y})`,
                            opacity: "0.3",
                          },
                          [
                            G(T.$slots, "default", {
                              outerCell: y(V).outerCell,
                              diagonal: y(V).diagonal,
                              value: n(y(V)),
                            }),
                          ],
                          8,
                          L9
                        ),
                        R.value.length > 0
                          ? (d(),
                            w(
                              zr,
                              { key: 0, cells: R.value, color: "#0003" },
                              null,
                              8,
                              ["cells"]
                            ))
                          : z("", !0),
                      ],
                      64
                    ))
                  : z("", !0),
                c(
                  zr,
                  { color: y(ee).selectionColor, cells: W.value },
                  null,
                  8,
                  ["color", "cells"]
                ),
                c(
                  Is,
                  { clues: p.value },
                  {
                    default: f(() => [
                      h(
                        "circle",
                        { fill: y(ee).selectionColor, r: T.highlightRadius },
                        null,
                        8,
                        E9
                      ),
                    ]),
                    _: 1,
                  },
                  8,
                  ["clues"]
                ),
                c(
                  Is,
                  { clues: T.clues },
                  {
                    default: f((J) => [
                      G(
                        T.$slots,
                        "default",
                        St(J, { selected: u.value.includes(J.outerCell) })
                      ),
                    ]),
                    _: 3,
                  },
                  8,
                  ["clues"]
                ),
              ]),
              _: 3,
            }),
            c(
              ct,
              { layer: y(oe).Foreground },
              {
                default: f(() => [
                  E.value
                    ? (d(),
                      w(
                        hl,
                        {
                          key: 0,
                          x: E.value.x,
                          y: E.value.y,
                          scale: T.highlightRadius,
                        },
                        null,
                        8,
                        ["x", "y", "scale"]
                      ))
                    : z("", !0),
                ]),
                _: 1,
              },
              8,
              ["layer"]
            ),
          ],
          64
        )
      );
    },
  }),
  F9 = {
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    "stroke-miterlimit": "1.5",
  },
  B9 = S({
    __name: "LittleKillersPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "svg",
          F9,
          n[0] ||
            (n[0] = [
              h(
                "path",
                {
                  d: "M3.75 9.5h-.92V3.64A6.16 6.16 0 0 1 1 4.75v-.88c.51-.24.96-.53 1.34-.87.39-.34.66-.68.82-1h.59v7.5ZM7.5 5.45a1.72 1.72 0 0 1-.84-.6 1.56 1.56 0 0 1-.28-.93c0-.54.2-1 .59-1.36.39-.37.9-.56 1.56-.56.65 0 1.17.19 1.57.57.4.38.6.84.6 1.38 0 .34-.1.65-.28.9a1.7 1.7 0 0 1-.82.6 2 2 0 0 1 1.04.72c.24.33.36.73.36 1.19 0 .64-.23 1.17-.68 1.6-.45.44-1.04.66-1.78.66-.73 0-1.33-.22-1.78-.66a2.18 2.18 0 0 1-.68-1.63c0-.48.13-.89.37-1.21.25-.33.6-.56 1.05-.67Zm-.18-1.56c0 .36.11.64.34.87.23.22.52.33.89.33.35 0 .64-.1.86-.33.23-.22.34-.5.34-.82 0-.33-.11-.61-.34-.84a1.19 1.19 0 0 0-.87-.35c-.35 0-.64.12-.87.34-.23.22-.35.5-.35.8Zm-.3 3.45c0 .26.07.51.2.76.11.24.3.43.54.56.25.14.51.2.8.2a1.45 1.45 0 0 0 1.51-1.5c0-.43-.15-.8-.45-1.08a1.5 1.5 0 0 0-1.1-.44 1.45 1.45 0 0 0-1.5 1.5Z",
                },
                null,
                -1
              ),
              h(
                "path",
                { d: "M14 18h5v-5M11 10l8 8", fill: "none", stroke: "#000" },
                null,
                -1
              ),
            ])
        )
      );
    },
  }),
  z9 = S({
    __name: "CornerArrow",
    props: {
      cellCorner: {},
      color: { default: "#000" },
      strokeWidth: { default: 0.05 },
    },
    setup(t) {
      const e = t,
        n = b(() => Qd(e.cellCorner));
      return (s, o) => (
        d(),
        w(
          Qo,
          {
            class: "CornerArrow",
            points: n.value,
            size: y(Yd),
            "end-arrow": "",
            color: s.color,
            "line-width": s.strokeWidth,
          },
          null,
          8,
          ["points", "size", "color", "line-width"]
        )
      );
    },
  }),
  R9 = S({
    __name: "LittleOutsideArrow",
    props: {
      outerCell: {},
      diagonal: {},
      color: { default: "#000" },
      strokeWidth: { default: 0.05 },
    },
    setup(t) {
      const e = t,
        { spec: n, helpers: s } = Qe(et).value,
        o = b(() => s.outerCellIds.getCoordsFromId(e.outerCell)),
        r = b(() => Jd(o.value, e.diagonal, n.size));
      return (l, i) => (
        d(),
        w(
          z9,
          {
            "cell-corner": r.value,
            color: l.color,
            "stroke-width": l.strokeWidth,
          },
          null,
          8,
          ["cell-corner", "color", "stroke-width"]
        )
      );
    },
  }),
  nr = S({
    __name: "OuterNumber",
    props: { value: {}, fill: {}, showCaret: { type: Boolean } },
    setup(t) {
      return (e, n) => (
        d(),
        w(
          kn,
          {
            value: e.value,
            "font-size": 0.65,
            fill: e.fill,
            "show-caret": e.showCaret,
          },
          null,
          8,
          ["value", "fill", "show-caret"]
        )
      );
    },
  });
function O9(t) {
  return (
    typeof t == "function" ||
    (Object.prototype.toString.call(t) === "[object Object]" && !Nt(t))
  );
}
function _f(t) {
  return (e) => ({
    default({ outerCell: n, diagonal: s, value: o, selected: r }) {
      return o === void 0 && !t
        ? []
        : [
            c(
              R9,
              { outerCell: n, diagonal: s, color: e.style.arrow.color },
              null
            ),
            c(
              nr,
              { value: o ?? "", fill: e.style.text.color, showCaret: t && r },
              null
            ),
          ];
    },
  });
}
const N9 = _f(!0),
  T9 = _f(!1);
_e({
  type: _.LittleKillers,
  label: "Little killers",
  preview: B9,
  margins: Bn(1),
  renderers: (t) => {
    let e;
    return [
      {
        layer: oe.Default,
        component: c(
          Is,
          { clues: t.clues },
          O9((e = T9(t))) ? e : { default: () => [e] }
        ),
      },
    ];
  },
  editor: xe({
    editor: {
      component: tr,
      props: (t, { project: e }) => ({
        clues: t.clues.map((n) => ({
          outerCell: n.outerCell,
          value: (n.value ?? "").toString(),
          diagonal: n.diagonal,
        })),
        type: zt.Diagonal,
        bidirectional: !0,
        inputMode: {
          ...Zs(),
          validation: (n) =>
            Number(n) <=
            Math.min(e.spec.size.width, e.spec.size.height) * e.spec.maxDigit,
        },
        defaultValue: (n) => (n.includes(void 0) ? "" : rc(n).toString()),
      }),
      slots: N9,
    },
    appearanceForm: {
      props: (t) => ({
        properties: [
          {
            type: "color",
            name: "textColor",
            label: "Text color",
            value: t.style.text.color,
            binding: (e) => ({ text: { color: e } }),
          },
          {
            type: "color",
            name: "arrowColor",
            label: "Arrow color",
            value: t.style.arrow.color,
            binding: (e) => ({ arrow: { color: e } }),
          },
        ],
        layout: [["textColor", "arrowColor"]],
      }),
    },
    updateFunc: (t, e, n) => {
      const { clues: s } = e;
      t.clues = s.map((o) => {
        let r;
        return (
          o.value === ""
            ? (r = void 0)
            : Number(o.value)
            ? (r = Number(o.value))
            : (r = n.project.spec.minDigit === 0 ? 0 : void 0),
          { value: r, outerCell: o.outerCell, diagonal: o.diagonal }
        );
      });
    },
  }),
});
const V9 = {
    class: "LockoutLinePreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  j9 = ["fill", "stroke"],
  U9 = ["stroke"],
  H9 = S({
    __name: "LockoutLinePreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", V9, [
          h(
            "g",
            {
              fill: e.constraint.style.endPoints.fill,
              stroke: e.constraint.style.endPoints.stroke.color,
              "stroke-linejoin": "bevel",
            },
            n[0] ||
              (n[0] = [
                h(
                  "path",
                  {
                    d: "M.5 4 4 .5 7.5 4 4 7.5zM12.5 16l3.5-3.5 3.5 3.5-3.5 3.5z",
                  },
                  null,
                  -1
                ),
              ]),
            8,
            j9
          ),
          h(
            "g",
            { stroke: e.constraint.style.lines.color },
            n[1] ||
              (n[1] = [
                h(
                  "path",
                  { d: "M6.4 6.4l2.1 2.1M13.6 13.6l-2.1-2.1" },
                  null,
                  -1
                ),
              ]),
            8,
            U9
          ),
          n[2] ||
            (n[2] = h(
              "path",
              {
                d: "m14.8 16.82.45-.04a.8.8 0 0 0 .23.5c.13.11.27.17.45.17.2 0 .38-.08.52-.24a.88.88 0 0 0 .22-.62.8.8 0 0 0-.2-.58.73.73 0 0 0-.55-.22.75.75 0 0 0-.64.34l-.4-.05.33-1.8h1.75v.4h-1.4l-.2.95c.22-.15.44-.22.67-.22.31 0 .57.1.78.32.21.21.32.49.32.82 0 .32-.1.6-.28.83-.23.28-.53.42-.93.42-.31 0-.58-.09-.78-.27-.2-.17-.32-.41-.35-.7Zm-5.9-5.9.43-.03c.04.2.11.35.21.44.1.09.24.14.4.14.13 0 .26-.04.36-.1.1-.06.19-.15.25-.25.07-.1.13-.25.17-.43.05-.18.07-.36.07-.54v-.1a1.03 1.03 0 0 1-.87.49c-.3 0-.56-.11-.77-.33a1.2 1.2 0 0 1-.31-.87c0-.37.1-.66.32-.89a1.17 1.17 0 0 1 1.92.4c.1.24.15.58.15 1.03 0 .46-.05.83-.15 1.1-.1.28-.25.5-.45.64s-.43.21-.7.21c-.29 0-.52-.08-.7-.23a1.02 1.02 0 0 1-.33-.67Zm1.84-1.6a.88.88 0 0 0-.2-.61.64.64 0 0 0-.5-.23c-.2 0-.38.08-.52.25a.9.9 0 0 0-.22.63c0 .23.07.42.2.56a.7.7 0 0 0 .53.22c.2 0 .37-.07.5-.22.14-.14.2-.34.2-.6ZM4.5 5.8H4V3l-.4.3c-.16.12-.32.22-.5.3V3c.3 0 .5-.2.7-.4l.4-.5h.3v3.7Z",
                fill: "#000",
              },
              null,
              -1
            )),
        ])
      );
    },
  }),
  W9 = ["r", "stroke", "stroke-width", "fill"],
  Z9 = ["d", "stroke", "stroke-width", "fill"],
  G9 = ["d", "stroke", "stroke-width", "fill"],
  q9 = ["points", "stroke", "stroke-width", "fill"],
  Rr = S({
    __name: "BasicShape",
    props: { shape: {}, style: {} },
    setup(t) {
      const e = t,
        n = b(() => {
          const l = e.style.size,
            i = l / 2;
          return `M-${i}-${i}h${l}v${l}h-${l}z`;
        }),
        s = b(() => {
          const l = e.style.size / 2;
          return `M-${l} 0l${l}-${l}l${l} ${l}l-${l} ${l}z`;
        }),
        o = b(() =>
          "points" in e.shape
            ? e.shape.points.map((l) => `${l.x},${l.y}`).join(" ")
            : ""
        ),
        r = b(() =>
          "headSize" in e.shape
            ? [
                { x: -e.shape.length / 2, y: 0 },
                { x: e.shape.length / 2, y: 0 },
              ]
            : []
        );
      return (l, i) =>
        l.shape.type === "circle"
          ? (d(),
            C(
              "circle",
              {
                key: 0,
                r: l.style.size / 2,
                stroke: l.style.stroke.color,
                "stroke-width": l.style.stroke.thickness,
                fill: l.style.fill,
              },
              null,
              8,
              W9
            ))
          : l.shape.type === "square"
          ? (d(),
            C(
              "path",
              {
                key: 1,
                d: n.value,
                stroke: l.style.stroke.color,
                "stroke-width": l.style.stroke.thickness,
                fill: l.style.fill,
              },
              null,
              8,
              Z9
            ))
          : l.shape.type === "diamond"
          ? (d(),
            C(
              "path",
              {
                key: 2,
                d: s.value,
                stroke: l.style.stroke.color,
                "stroke-width": l.style.stroke.thickness,
                fill: l.style.fill,
              },
              null,
              8,
              G9
            ))
          : l.shape.type === "polygon"
          ? (d(),
            C(
              "polygon",
              {
                key: 3,
                points: o.value,
                stroke: l.style.stroke.color,
                "stroke-width": l.style.stroke.thickness,
                fill: l.style.fill,
              },
              null,
              8,
              q9
            ))
          : l.shape.type === "arrow"
          ? (d(),
            w(
              Qo,
              {
                key: 4,
                points: r.value,
                size: l.shape.headSize,
                color: l.style.stroke.color,
                "line-width": l.style.stroke.thickness,
              },
              null,
              8,
              ["points", "size", "color", "line-width"]
            ))
          : z("", !0);
    },
  });
function K9(t) {
  return (
    typeof t == "function" ||
    (Object.prototype.toString.call(t) === "[object Object]" && !Nt(t))
  );
}
function Ku(t) {
  return {
    default: () => [
      c(Rr, { shape: { type: "diamond" }, style: t.style.endPoints }, null),
    ],
    selection: ({ selectionOutlineSize: e }) => [
      c(
        Rr,
        {
          shape: { type: "diamond" },
          style: {
            size:
              t.style.endPoints.size +
              Math.SQRT2 * t.style.endPoints.stroke.thickness,
            stroke: { color: ee.selectionColor, thickness: e * 2 },
            fill: "#fff",
          },
          "paint-order": "stroke",
        },
        null
      ),
    ],
  };
}
_e({
  type: _.LockoutLines,
  label: "Lockout lines",
  preview: H9,
  renderers: (t) => {
    let e;
    return [
      {
        layer: oe.Default,
        component: c(
          Fo,
          { lines: t.lines, style: t.style },
          K9((e = Ku(t))) ? e : { default: () => [e] }
        ),
      },
    ];
  },
  editor: xe({
    editor: {
      component: pa,
      props: (t) => ({
        lines: t.lines,
        endPointStyleLabel: "Diamond style",
        style: t.style,
      }),
      slots: Ku,
    },
  }),
});
const X9 = ["stroke"],
  Y9 = S({
    __name: "LookAndSayCagesPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        w(
          ha,
          Vr(Ci(e.$props)),
          {
            default: f(() => [
              h(
                "path",
                {
                  d: "m15.68 4.85-.23 1.81-2.73 2.99 2.07 1.4-.79 1.47s2.16.14 2.5.78c.43.82-2.25 1.54-2.25 1.54s.5 1.88 2.66 1.67m-5.14-4.26-4.48-1.8m4.7 3.2-3.97-.03m3.97 1.65-3.62 1.59",
                  fill: "none",
                  stroke: e.constraint.style.text.color,
                },
                null,
                8,
                X9
              ),
            ]),
            _: 1,
          },
          16
        )
      );
    },
  });
_e({
  type: _.LookAndSayCages,
  label: "Look-and-say cages",
  preview: Y9,
  renderers: (t) => [
    {
      layer: oe.Grid,
      component: c(fl, { cages: t.cages, style: t.style }, null),
    },
  ],
  editor: xe({
    editor: {
      component: fa,
      props: (t) => ({
        cages: t.cages,
        style: t.style,
        inputMode: { ...Zs(), validation: (e) => !!e.match(/^\d+$/) },
      }),
    },
  }),
});
const J9 = {
    class: "MaximumPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    "stroke-linecap": "round",
    "stroke-miterlimit": "1.5",
  },
  Q9 = ["fill"],
  eD = S({
    __name: "MaximumPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", J9, [
          h(
            "path",
            {
              fill: e.constraint.style.color,
              stroke: "#000",
              d: "M1 1h18v18H1z",
            },
            null,
            8,
            Q9
          ),
          n[0] ||
            (n[0] = h(
              "path",
              {
                d: "m4.5 13-2-3 2-3m11 0 2 3-2 3M13 15.5l-3 2-3-2m0-11 3-2 3 2",
                fill: "none",
                stroke: "#000",
              },
              null,
              -1
            )),
        ])
      );
    },
  }),
  tD = {
    class: "MinimumPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    "stroke-linecap": "round",
    "stroke-miterlimit": "1.5",
  },
  nD = ["fill"],
  sD = S({
    __name: "MinimumPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", tD, [
          h(
            "path",
            {
              fill: e.constraint.style.color,
              stroke: "#000",
              d: "M1 1h18v18H1z",
            },
            null,
            8,
            nD
          ),
          n[0] ||
            (n[0] = h(
              "path",
              {
                d: "m2.5 7 2 3-2 3m15 0-2-3 2-3M7 17.5l3-2 3 2m0-15-3 2-3-2",
                fill: "none",
                stroke: "#000",
              },
              null,
              -1
            )),
        ])
      );
    },
  }),
  oD = { key: 0 },
  rD = { key: 1, transform: "rotate(90)" },
  lD = { key: 2, transform: "rotate(180)" },
  iD = { key: 3, transform: "rotate(270)" },
  aD = S({
    __name: "FortressRenderer",
    props: { cell: {}, cells: {} },
    setup(t) {
      const e = t,
        { helpers: n } = Qe(et).value;
      function s(r) {
        return {
          left: n.cellIds.getIdFromCoordsSafe({ x: r.x - 1, y: r.y }),
          right: n.cellIds.getIdFromCoordsSafe({ x: r.x + 1, y: r.y }),
          top: n.cellIds.getIdFromCoordsSafe({ x: r.x, y: r.y - 1 }),
          bottom: n.cellIds.getIdFromCoordsSafe({ x: r.x, y: r.y + 1 }),
        };
      }
      const o = b(() => {
        const r = n.cellIds.getCoordsFromId(e.cell),
          { left: l, right: i, top: a, bottom: u } = s(r);
        return {
          left: l === void 0 ? !1 : !e.cells.includes(l),
          right: i === void 0 ? !1 : !e.cells.includes(i),
          top: a === void 0 ? !1 : !e.cells.includes(a),
          bottom: u === void 0 ? !1 : !e.cells.includes(u),
        };
      });
      return (r, l) => (
        d(),
        C("g", null, [
          o.value.left
            ? (d(), C("g", oD, [G(r.$slots, "default")]))
            : z("", !0),
          o.value.top ? (d(), C("g", rD, [G(r.$slots, "default")])) : z("", !0),
          o.value.right
            ? (d(), C("g", lD, [G(r.$slots, "default")]))
            : z("", !0),
          o.value.bottom
            ? (d(), C("g", iD, [G(r.$slots, "default")]))
            : z("", !0),
        ])
      );
    },
  });
function $f(t, e = !1) {
  let n = "";
  for (let s = 0; s < t.length; s++)
    s === 0 ? (n += `M${t[s].x} ${t[s].y}`) : (n += `L${t[s].x} ${t[s].y}`);
  return e ? `${n}Z` : n;
}
function uD(t) {
  return (
    typeof t == "function" ||
    (Object.prototype.toString.call(t) === "[object Object]" && !Nt(t))
  );
}
const cD = $f(Gd),
  dD = $f(qd);
function Sf(t, e, n, s) {
  const o = (r) => ({
    default({ cell: l }) {
      return [
        c(
          "rect",
          { x: -0.5, y: -0.5, width: 1, height: 1, fill: r.style.color },
          null
        ),
        c(
          aD,
          { cell: l, cells: r.cells },
          {
            default: () =>
              c(
                "path",
                { stroke: "#000", fill: "none", "stroke-width": "0.03", d: e },
                null
              ),
          }
        ),
      ];
    },
  });
  _e({
    type: t,
    label: n,
    preview: s,
    renderers: (r) => {
      let l;
      return [
        {
          layer: oe.Default,
          component: c(
            is,
            { cells: r.cells },
            uD((l = o(r))) ? l : { default: () => [l] }
          ),
        },
      ];
    },
    editor: xe({
      editor: { component: gl, props: (r) => ({ cells: r.cells }), slots: o },
      appearanceForm: {
        props: (r) => ({
          properties: [
            {
              type: "color",
              name: "color",
              label: "Color",
              value: r.style.color,
            },
          ],
        }),
      },
    }),
  });
}
Sf(_.Minimum, cD, "Minimum", sD);
Sf(_.Maximum, dD, "Maximum", eD);
const pD = { viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg" },
  fD = ["fill"],
  hD = S({
    __name: "NumberedRoomsPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", pD, [
          n[0] ||
            (n[0] = h(
              "path",
              { d: "M3 19V1h14v18", fill: "none", stroke: "#000" },
              null,
              -1
            )),
          n[1] ||
            (n[1] = h(
              "path",
              { d: "M5 19V3h10v16", fill: "#fff", stroke: "#000" },
              null,
              -1
            )),
          n[2] ||
            (n[2] = h(
              "path",
              { d: "M12 13h1.5", fill: "none", stroke: "#000" },
              null,
              -1
            )),
          h(
            "path",
            {
              d: "M8.48 8.3h1.7V6.13a50.37 50.37 0 0 0-1.7 2.17Zm2.9 1.11.01 1.2c-.42.04-.8.09-1.16.14l-.06-.03V8.9H9.1l-1.32.01-.04-.4a70.71 70.71 0 0 0 2.21-2.78c.25-.31.48-.62.7-.93l.75-.04-.03 1.81V8.3h.95l.02.61-.97-.01v.51Z",
              fill: e.constraint.style.color,
            },
            null,
            8,
            fD
          ),
        ])
      );
    },
  });
function mD(t) {
  return (
    typeof t == "function" ||
    (Object.prototype.toString.call(t) === "[object Object]" && !Nt(t))
  );
}
function If(t) {
  return (e) => ({
    default({ value: n, selected: s }) {
      return n === void 0 && !t
        ? []
        : [
            c(
              nr,
              {
                value: n ?? "",
                fill: e.style.color,
                showCaret: n === void 0 && t && s,
              },
              null
            ),
          ];
    },
  });
}
const gD = If(!0),
  vD = If(!1);
_e({
  type: _.NumberedRooms,
  label: "Numbered rooms",
  preview: hD,
  margins: Bn(1),
  renderers: (t) => {
    let e;
    return [
      {
        layer: oe.Default,
        component: c(
          Is,
          { clues: t.clues },
          mD((e = vD(t))) ? e : { default: () => [e] }
        ),
      },
    ];
  },
  editor: xe({
    editor: {
      component: tr,
      props: (t, { project: e }) => ({
        clues: t.clues.map((n) => ({
          outerCell: n.outerCell,
          value: (n.value ?? "").toString(),
        })),
        type: zt.Orthogonal,
        inputMode: { ...Yc(e.spec) },
        defaultValue: (n) => {
          if (n[0]) {
            const s = n[0] - 1;
            return (n[s] ?? "").toString();
          }
          return "";
        },
      }),
      slots: gD,
    },
    appearanceForm: {
      props: (t) => ({
        properties: [
          {
            type: "color",
            name: "color",
            label: "Color",
            value: t.style.color,
          },
        ],
      }),
    },
    updateFunc: (t, e, n) => {
      const { clues: s } = e;
      t.clues = s.map((o) => {
        let r;
        return (
          o.value === ""
            ? (r = void 0)
            : Number(o.value)
            ? (r = Number(o.value))
            : (r = n.project.spec.minDigit === 0 ? 0 : void 0),
          { value: r, outerCell: o.outerCell }
        );
      });
    },
  }),
});
const yD = {
    class: "OddPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  CD = ["fill"],
  wD = S({
    __name: "OddPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", yD, [
          h(
            "path",
            {
              d: "M10 .5a9.5 9.5 0 1 0 0 19 9.5 9.5 0 0 0 0-19Zm.1 14.3h.6l.3.6.5.1h.5l.4-.4.2-.6a3 3 0 0 0 0-.9 1.4 1.4 0 0 1-1.1.7c-.4 0-.8-.2-1-.5-.3-.2-.5-.6-.5-1.1 0-.5.2-1 .5-1.2.3-.3.6-.5 1-.5a1.6 1.6 0 0 1 1.6 1l.2 1.4-.2 1.5-.6.8c-.3.2-.6.3-1 .3s-.7 0-1-.3c-.2-.2-.3-.5-.4-.9Zm-3.8-3.1V11h3.2v.5c-.4.3-.7.8-1 1.3a8 8 0 0 0-1 3H7c0-.3 0-.8.2-1.3a7.3 7.3 0 0 1 1.5-3H6.3Zm6.3 1c0-.4 0-.7-.3-.9a.9.9 0 0 0-.6-.3 1 1 0 0 0-.7.4c-.2.2-.3.5-.3.8 0 .3 0 .6.2.8.2.2.5.3.7.3.3 0 .6-.1.7-.3.2-.2.3-.5.3-.8ZM8.2 7.6h.6c0 .3.1.5.3.6l.6.3c.3 0 .5-.1.7-.3.2-.2.3-.5.3-.7a1 1 0 0 0-1-1h-.4l.1-.5h.1c.3 0 .5 0 .7-.2.2 0 .3-.3.3-.6 0-.2 0-.4-.2-.5a.8.8 0 0 0-.6-.2c-.2 0-.4 0-.6.2l-.3.6h-.6c0-.5.3-.8.5-1 .3-.2.6-.3 1-.3l.7.1.5.5c.2.2.2.4.2.6 0 .3 0 .4-.2.6 0 .2-.2.3-.5.4.3.1.6.2.7.4.2.3.3.5.3.8 0 .5-.2.8-.5 1.1-.3.3-.7.5-1.2.5-.4 0-.8-.2-1-.4-.3-.3-.5-.6-.5-1Zm3.8 0h.6c0 .3.1.5.3.6l.6.3c.3 0 .6-.1.8-.4.2-.2.3-.5.3-.8 0-.4-.1-.6-.3-.8a1 1 0 0 0-.8-.3 1 1 0 0 0-.9.4h-.5l.4-2.5H15v.5h-2L12.7 6c.3-.2.7-.3 1-.3.4 0 .8.2 1 .5.3.3.5.7.5 1.1 0 .5-.1.9-.4 1.2-.3.4-.7.6-1.3.6-.4 0-.8-.2-1-.4-.3-.3-.5-.6-.6-1ZM6.5 8.9H6V5l-.6.4a4 4 0 0 1-.6.3v-.6l.9-.6.5-.6h.4v4.9Z",
              fill: y(Ws)(e.constraint.style.color),
            },
            null,
            8,
            CD
          ),
        ])
      );
    },
  });
function bD(t) {
  return (
    typeof t == "function" ||
    (Object.prototype.toString.call(t) === "[object Object]" && !Nt(t))
  );
}
function Xu(t) {
  return {
    default() {
      return [c("circle", { r: t.style.size / 2, fill: t.style.color }, null)];
    },
  };
}
_e({
  type: _.Odd,
  label: "Odd",
  preview: wD,
  renderers: (t) => {
    let e;
    return [
      {
        layer: oe.Background,
        component: c(
          is,
          { cells: t.cells },
          bD((e = Xu(t))) ? e : { default: () => [e] }
        ),
      },
    ];
  },
  editor: xe({
    editor: { component: gl, props: (t) => sn(t, "cells"), slots: Xu },
    appearanceForm: {
      props: (t) => ({
        properties: [
          {
            type: "color",
            name: "color",
            label: "Color",
            value: t.style.color,
          },
          { type: "size", name: "size", label: "Size", value: t.style.size },
        ],
      }),
    },
  }),
});
const kD = {
    class: "PalindromePreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  _D = ["stroke"],
  $D = S({
    __name: "PalindromePreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", kD, [
          h(
            "path",
            {
              d: "M1 19 18.95 1",
              fill: "none",
              stroke: e.constraint.style.color,
              "stroke-width": "1.5",
            },
            null,
            8,
            _D
          ),
          n[0] ||
            (n[0] = h(
              "path",
              {
                class: "text",
                d: "M9.61 10.1c-.2.1-.4.13-.57.1a.88.88 0 0 1-.48-.26 1.02 1.02 0 0 1-.31-.78c0-.3.14-.58.4-.84s.54-.4.85-.4c.3 0 .57.1.78.31.14.14.23.3.26.47.03.18 0 .36-.1.57.24-.13.48-.17.7-.13.23.04.44.15.62.33.26.25.38.56.37.9 0 .36-.15.68-.45.98-.29.29-.61.44-.96.45-.36 0-.66-.12-.92-.38-.2-.2-.3-.4-.34-.64-.03-.22.02-.45.15-.68Zm-.69-.55c.14.14.3.22.48.21.18 0 .34-.07.49-.22.14-.14.2-.3.2-.47a.62.62 0 0 0-.18-.46.67.67 0 0 0-.96.01.68.68 0 0 0-.21.48c0 .18.06.33.18.45Zm1.25 1.5c.1.1.23.17.38.22.15.05.3.05.44 0a.9.9 0 0 0 .4-.23.83.83 0 0 0 .26-.6.81.81 0 0 0-.26-.6.83.83 0 0 0-.6-.25c-.24 0-.44.09-.62.26a.81.81 0 0 0 0 1.2ZM13.77 4.68l-.34.39a.97.97 0 0 0-.45-.17.71.71 0 0 0-.73.61c-.03.2 0 .4.1.64.1.22.29.49.58.78a1.2 1.2 0 0 1 .33-1.11c.24-.24.54-.36.89-.35.35 0 .66.15.95.43.18.19.32.4.4.64a1.23 1.23 0 0 1-.32 1.3c-.3.31-.66.45-1.07.42-.42-.04-.88-.3-1.4-.82-.57-.57-.88-1.1-.93-1.57-.04-.41.1-.77.4-1.09.24-.23.5-.36.78-.38.28-.01.55.08.8.28Zm-.21 2.77c.12.12.27.22.44.28.17.06.33.07.49.04.15-.04.28-.11.39-.22a.73.73 0 0 0 .2-.58 1.04 1.04 0 0 0-.33-.67.97.97 0 0 0-.65-.32.76.76 0 0 0-.6.23.8.8 0 0 0-.23.6c0 .23.1.45.29.64ZM6.77 11.68l-.34.39a.97.97 0 0 0-.44-.18c-.2 0-.38.07-.52.21a.71.71 0 0 0-.21.4c-.03.2 0 .42.1.64.09.23.28.5.57.8a1.2 1.2 0 0 1 .33-1.12c.24-.25.54-.36.89-.35.35 0 .67.15.95.43.19.19.32.4.4.64a1.23 1.23 0 0 1-.32 1.3c-.3.31-.66.45-1.07.41-.42-.03-.88-.3-1.4-.81-.57-.58-.88-1.1-.93-1.57-.04-.41.1-.78.4-1.09.24-.23.5-.36.78-.38.28-.01.55.08.8.28Zm-.21 2.77c.13.12.27.21.44.28.17.06.33.07.49.03.15-.03.28-.1.39-.2a.73.73 0 0 0 .2-.59 1.04 1.04 0 0 0-.33-.67.97.97 0 0 0-.65-.32.76.76 0 0 0-.6.23.8.8 0 0 0-.23.6c0 .23.1.44.29.64ZM18.95 3.98l-.37.36-2.32-2.32a3.48 3.48 0 0 1-.29 1.17l-.35-.35c.1-.3.17-.6.19-.88.01-.3-.01-.53-.08-.73l.24-.23 2.98 2.98ZM5.07 17.86l-.36.36-2.32-2.32a3.48 3.48 0 0 1-.29 1.17l-.36-.36c.11-.3.18-.59.2-.88 0-.29-.02-.53-.08-.72l.23-.23 2.98 2.98Z",
                "fill-rule": "nonzero",
              },
              null,
              -1
            )),
        ])
      );
    },
  }),
  SD = B($D, [["__scopeId", "data-v-e9e10db2"]]);
_e({
  type: _.Palindrome,
  label: "Palindromes",
  preview: SD,
  renderers: (t) => [
    {
      layer: oe.Default,
      component: c(Ms, { lines: t.lines, style: t.style }, null),
    },
  ],
  editor: xe({
    editor: {
      component: As,
      props: (t) => ({
        lines: t.lines,
        style: t.style,
        restrictions: { allowCycles: !1, allowBranching: !1 },
      }),
    },
  }),
});
const ID = ["transform"],
  fi = S({
    __name: "CornerRenderer",
    props: { cornerClues: {} },
    setup(t) {
      const e = t,
        { helpers: n } = Qe(et).value,
        s = b(() =>
          e.cornerClues.map((o) => ({
            position: n.cornerIds.getCoordsFromId(o.corner),
            item: o,
          }))
        );
      return (o, r) => (
        d(!0),
        C(
          Z,
          null,
          se(
            s.value,
            (l, i) => (
              d(),
              C(
                "g",
                {
                  key: i,
                  transform: `translate(${l.position.x} ${l.position.y})`,
                },
                [G(o.$slots, "default", St({ ref_for: !0 }, l.item))],
                8,
                ID
              )
            )
          ),
          128
        )
      );
    },
  }),
  xD = ["stroke", "stroke-width", "r"],
  DD = ["transform"],
  MD = S({
    __name: "CornerGeometryEditor",
    props: {
      context: {},
      cornerClues: {},
      defaultValue: { type: [String, Function], default: "" },
      highlightRadius: { default: 0.16 },
      inputMode: { default: void 0 },
      inputValidator: { type: Function, default: () => !0 },
    },
    setup(t) {
      const e = t;
      function n(D) {
        if (typeof e.defaultValue == "string") return e.defaultValue;
        const E = [...e.context.helpers.geometry.getCellsTouchingCorner(D)].map(
          (R) => e.context.project.cells[R].value
        );
        return e.defaultValue(E);
      }
      function s(D) {
        return e.cornerClues.find((N) => N.corner === D);
      }
      function o(D) {
        if (D.outside) return;
        let N = D.x,
          E = D.y;
        D.offsetX > 0.5 && N++, D.offsetY > 0.5 && E++;
        const { width: R, height: W } = e.context.project.spec.size;
        if (!(N < 1 || E < 1 || N >= R || E >= W))
          return e.context.helpers.cornerIds.getIdFromCornerCoords({
            x: N,
            y: E,
          });
      }
      const r = b(() => e.cornerClues.length > 0),
        l = j([]),
        i = b(() =>
          l.value
            .map((D) => e.cornerClues.find((N) => D === N.corner))
            .filter((D) => D)
        ),
        a = b(() => (i.value.length > 0 ? String(i.value[0].value) : void 0));
      function u() {
        l.value = [];
      }
      function p() {
        l.value = e.cornerClues.map((D) => D.corner);
      }
      ae(
        () => e.cornerClues,
        (D) => {
          l.value = l.value.filter((N) => D.some((E) => N === E.corner));
        }
      );
      const m = b(() =>
        i.value.length === 0
          ? {}
          : { ...e.inputMode, deleteButton: i.value.length > 0 }
      );
      er({ inputMode: m, selectedValue: a });
      let g = fe();
      function v(D, N = !1) {
        g = fe();
        let E = s(D);
        E ||
          ((E = { value: n(D), corner: D }),
          e.context.updateConstraint(
            { cornerClues: [...e.cornerClues, E] },
            "add",
            g
          )),
          N || u(),
          l.value.includes(D) ? _t(l.value, [D]) : l.value.push(D);
      }
      function $(D) {
        const N = i.value;
        if (N.every((R) => R.value === D)) return;
        const E = ue(e.cornerClues);
        for (const R of N) {
          const W = E.findIndex((T) => T.corner === R.corner);
          W !== -1 && (E[W].value = D);
        }
        e.context.updateConstraint({ cornerClues: E }, "update", g);
      }
      function k(D) {
        const N = e.cornerClues.slice();
        for (const E of D) {
          const R = N.findIndex((W) => W.corner === E.corner);
          R !== -1 && N.splice(R, 1);
        }
        e.context.updateConstraint({ cornerClues: N }, "delete"), u();
      }
      function M(D) {
        k(e.cornerClues.filter((N) => N.corner === D));
      }
      function P() {
        k(i.value);
      }
      const {
          position: x,
          pointerAction: A,
          deleting: O,
          placing: V,
        } = ml({
          createOrSelectClue: v,
          deselect: u,
          selectAll: p,
          updateClueValue: $,
          deleteAt: M,
          deleteSelectedClues: P,
          getClueAt: s,
          getPlaceablePosition: o,
        }),
        I = b(
          () => x.value && e.context.helpers.cornerIds.getCoordsFromId(x.value)
        ),
        U = b(() => {
          if (
            !(
              !O.value ||
              !x.value ||
              !e.cornerClues.find((D) => D.corner === x.value)
            )
          )
            return e.context.helpers.cornerIds.getCoordsFromId(x.value);
        });
      return (D, N) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              yt,
              { class: "CornerGeometryEditor", context: D.context },
              os(
                {
                  buttons: f(() => [
                    c(
                      Ds,
                      {
                        mode: y(A),
                        "onUpdate:mode":
                          N[0] ||
                          (N[0] = (E) => (Rn(A) ? (A.value = E) : null)),
                        "can-delete": r.value,
                      },
                      null,
                      8,
                      ["mode", "can-delete"]
                    ),
                  ]),
                  _: 2,
                },
                [
                  D.$slots.description
                    ? {
                        name: "description",
                        fn: f(() => [G(D.$slots, "description")]),
                        key: "0",
                      }
                    : void 0,
                  D.$slots.properties
                    ? {
                        name: "properties",
                        fn: f(() => [G(D.$slots, "properties")]),
                        key: "1",
                      }
                    : void 0,
                  D.$slots.appearance
                    ? {
                        name: "appearance",
                        fn: f(() => [G(D.$slots, "appearance")]),
                        key: "2",
                      }
                    : void 0,
                ]
              ),
              1032,
              ["context"]
            ),
            c(
              ct,
              { layer: y(oe).Foreground },
              {
                default: f(() => [
                  c(
                    fi,
                    { "corner-clues": i.value },
                    {
                      default: f(() => [
                        h(
                          "circle",
                          {
                            fill: "none",
                            stroke: y(ee).selectionColor,
                            "stroke-width": y(on),
                            r: D.highlightRadius + y(on) / 2,
                          },
                          null,
                          8,
                          xD
                        ),
                      ]),
                      _: 1,
                    },
                    8,
                    ["corner-clues"]
                  ),
                  c(
                    fi,
                    { "corner-clues": D.cornerClues },
                    {
                      default: f((E) => [G(D.$slots, "default", Vr(Ci(E)))]),
                      _: 3,
                    },
                    8,
                    ["corner-clues"]
                  ),
                  y(V) && I.value
                    ? (d(),
                      C(
                        "g",
                        {
                          key: 0,
                          transform: `translate(${I.value.x} ${I.value.y})`,
                          opacity: "0.3",
                        },
                        [
                          G(D.$slots, "default", {
                            edge: y(x),
                            value: n(y(x)),
                          }),
                        ],
                        8,
                        DD
                      ))
                    : U.value
                    ? (d(),
                      w(
                        hl,
                        {
                          key: 1,
                          x: U.value.x,
                          y: U.value.y,
                          scale: D.highlightRadius,
                        },
                        null,
                        8,
                        ["x", "y", "scale"]
                      ))
                    : z("", !0),
                ]),
                _: 3,
              },
              8,
              ["layer"]
            ),
          ],
          64
        )
      );
    },
  }),
  AD = { viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg" },
  PD = S({
    __name: "QuadruplesPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "svg",
          AD,
          n[0] ||
            (n[0] = [
              h(
                "circle",
                { cx: "10", cy: "10", r: "9", fill: "#fff", stroke: "#000" },
                null,
                -1
              ),
              h(
                "path",
                {
                  d: "M8.76 8.27v.59H5.44c0-.15.02-.3.08-.43.08-.23.22-.45.4-.67.19-.22.46-.48.8-.76.55-.45.93-.8 1.12-1.06.19-.27.28-.52.28-.75a.82.82 0 0 0-.26-.61.96.96 0 0 0-.68-.26c-.3 0-.54.1-.71.27-.18.18-.27.43-.28.74l-.63-.07c.04-.47.2-.82.5-1.08.27-.24.65-.37 1.13-.37.48 0 .86.13 1.14.4.28.27.42.6.42 1 0 .2-.03.4-.11.59-.09.2-.22.4-.41.61-.2.21-.51.5-.96.89-.37.3-.6.52-.71.63-.1.11-.2.22-.26.34h2.46ZM11.38 7.53l.62-.08c.07.35.19.6.35.75a.9.9 0 0 0 .63.23A1.03 1.03 0 0 0 14 7.38a.95.95 0 0 0-.98-.97c-.11 0-.26.02-.44.07l.07-.54h.1c.27 0 .5-.07.71-.2.21-.14.32-.35.32-.64a.77.77 0 0 0-.23-.56.82.82 0 0 0-.6-.22.8.8 0 0 0-.6.23c-.15.14-.26.37-.3.67l-.62-.1c.08-.42.25-.74.51-.97.27-.23.6-.34 1-.34.27 0 .53.06.76.18.23.12.4.28.52.48a1.12 1.12 0 0 1 .01 1.24c-.11.18-.28.32-.51.42.3.07.53.21.7.43.16.22.24.49.24.82 0 .43-.16.8-.48 1.11-.32.3-.73.46-1.21.46-.44 0-.8-.14-1.1-.4-.29-.26-.46-.6-.5-1.02ZM7.5 16.1v-1.2H5.32v-.57l2.3-3.25h.5v3.25h.68v.57h-.68v1.2H7.5Zm0-1.77v-2.26l-1.57 2.26H7.5ZM12.33 13.38c-.26-.1-.45-.23-.57-.4a1.05 1.05 0 0 1-.2-.63c0-.36.14-.67.4-.92a1.5 1.5 0 0 1 1.05-.37c.44 0 .8.12 1.06.38.27.26.4.56.4.93 0 .23-.06.43-.18.6-.13.18-.3.31-.56.4.3.1.55.27.7.5.17.22.25.48.25.8 0 .43-.15.79-.46 1.08-.3.29-.7.44-1.2.44-.49 0-.89-.15-1.2-.45-.3-.28-.45-.66-.45-1.1 0-.32.08-.6.25-.81.17-.22.4-.37.7-.45Zm-.13-1.05c0 .24.08.43.23.59.16.14.35.22.6.22a.8.8 0 0 0 .58-.22.73.73 0 0 0 .23-.55.8.8 0 0 0-.24-.58.82.82 0 0 0-.58-.22.8.8 0 0 0-.59.22.72.72 0 0 0-.23.54Zm-.2 2.32c0 .18.05.35.13.51.08.17.2.3.37.39.16.09.34.13.53.13a1 1 0 0 0 .73-.29c.2-.19.29-.42.29-.72a1 1 0 0 0-.3-.74c-.2-.19-.44-.28-.74-.28s-.53.1-.72.28a.95.95 0 0 0-.29.72Z",
                },
                null,
                -1
              ),
            ])
        )
      );
    },
  }),
  LD = S({
    props: {
      value: { type: String, required: !0 },
      color: { type: String, default: "#000" },
      singleLine: { type: Boolean, default: !1 },
    },
    computed: {
      text() {
        const t = ep[this.value.length];
        return [...this.value].map((e, n) => ({ digit: e, ...t[n] }));
      },
    },
  }),
  ED = { transform: "scale(0.02)" },
  FD = ["fill"],
  BD = ["x", "y", "fill"];
function zD(t, e, n, s, o, r) {
  return (
    d(),
    C("g", ED, [
      t.singleLine
        ? (d(),
          C(
            "text",
            {
              key: 0,
              fill: t.color,
              "font-size": "12",
              "text-anchor": "middle",
              "dominant-baseline": "central",
            },
            X(t.value),
            9,
            FD
          ))
        : (d(!0),
          C(
            Z,
            { key: 1 },
            se(
              t.text,
              (l, i) => (
                d(),
                C(
                  "text",
                  {
                    key: i,
                    x: l.x * 50,
                    y: l.y * 50,
                    fill: t.color,
                    "font-size": "12",
                    "text-anchor": "middle",
                    "dominant-baseline": "central",
                  },
                  X(l.digit),
                  9,
                  BD
                )
              )
            ),
            128
          )),
    ])
  );
}
const Yu = B(LD, [["render", zD]]),
  dr = { size: 0.6, fill: "#fff", stroke: { color: "#000", thickness: 0.02 } };
_e({
  type: _.Quadruple,
  label: "Quadruples",
  preview: PD,
  renderers: (t) => [
    {
      layer: oe.Foreground,
      component: c(
        fi,
        { cornerClues: t.clues },
        {
          default({ digits: e }) {
            return [
              c(Rr, { shape: { type: "circle" }, style: dr }, null),
              c(
                Yu,
                { value: e.join(""), singleLine: t.style.singleLine },
                null
              ),
            ];
          },
        }
      ),
    },
  ],
  editor: xe({
    editor: {
      component: MD,
      props: (t, { project: e }) => ({
        cornerClues: t.clues.map((n) => ({
          corner: n.corner,
          value: n.digits.join(""),
        })),
        inputMode: { ...Ih(e.spec), validation: (n) => n.length <= 4 },
        highlightRadius: (dr.size + dr.stroke.thickness) / 2,
      }),
      slots: (t) => ({
        default(e) {
          return [
            c(Rr, { shape: { type: "circle" }, style: dr }, null),
            c(Yu, { value: e.value, singleLine: t.style.singleLine }, null),
          ];
        },
      }),
    },
    appearanceForm: {
      props: (t) => ({
        properties: [
          {
            type: "boolean",
            name: "singleLine",
            label: "Show digits on a single line",
            value: t.style.singleLine,
          },
        ],
      }),
    },
    updateFunc: (t, e) => {
      const { cornerClues: n } = e;
      t.clues = n.map((s) => ({
        corner: s.corner,
        digits: [...s.value].map(Number),
      }));
    },
  }),
});
const RD = {
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    "stroke-linecap": "square",
    "stroke-miterlimit": "1.5",
  },
  OD = S({
    __name: "RatioPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "svg",
          RD,
          n[0] ||
            (n[0] = [
              h(
                "path",
                { d: "M10 4v12", fill: "none", stroke: "#000" },
                null,
                -1
              ),
              h("circle", { cx: "10", cy: "10", r: "4" }, null, -1),
              h(
                "path",
                {
                  d: "M4.58 11.38v.75H1.74c.03-.29.12-.56.28-.81.15-.26.45-.6.9-1.02.37-.34.6-.57.68-.7a.88.88 0 0 0 .17-.5c0-.17-.05-.31-.14-.4a.55.55 0 0 0-.41-.15c-.17 0-.3.05-.4.15-.1.1-.17.27-.18.5l-.8-.07c.04-.45.2-.77.45-.96.25-.2.57-.3.95-.3.42 0 .75.11.98.34.25.22.36.5.36.84 0 .2-.03.37-.1.55-.07.17-.17.35-.32.54-.1.12-.28.3-.53.54-.27.23-.42.39-.5.46l-.16.24h1.61ZM16.95 12.13v-.85h-1.73v-.72l1.83-2.69h.69v2.69h.52v.72h-.52v.85h-.79Zm0-1.57V9.1l-.97 1.45h.97Z",
                },
                null,
                -1
              ),
            ])
        )
      );
    },
  }),
  ND = S({
    components: {
      FormControlLabel: ut,
      CheckBox: at,
      TooltipIndicator: dt,
      DigitSetInput: vf,
    },
    props: {
      context: { type: Object, required: !0 },
      usedRatios: { type: Set, required: !0 },
      allowedRatios: { type: Array, required: !0 },
      negative: { type: Array, required: !0 },
      overrideNegativeDifferences: { type: Boolean, required: !0 },
    },
    computed: {
      defaultNegativeRatios() {
        return this.usedRatios.size === 0 ? [2] : [...this.usedRatios];
      },
      showNegativeDifferenceOverride() {
        const t = [];
        for (const n of this.context.constraints)
          n.config.type === _.Difference
            ? t.push(...n.config.negative)
            : n.config.type === _.Nonconsecutive && t.push(1);
        if (t.length === 0) return !1;
        const e = new Set();
        for (const n of this.usedRatios)
          for (let s = 1; s <= this.context.project.spec.maxDigit / n; s++)
            e.add(s * (n - 1));
        return t.some((n) => e.has(n));
      },
      mentionNonconsecutive() {
        return !!this.context.constraints.find(
          (t) => t.config.type === _.Nonconsecutive
        );
      },
    },
    methods: {
      onNegativeInputChange(t, e) {
        this.context.updateConstraint(
          { negative: t },
          "updateNegativeValues",
          e
        );
      },
      updateNegative(t) {
        t
          ? this.context.updateConstraint(
              { negative: this.defaultNegativeRatios },
              "toggleNegative"
            )
          : this.context.updateConstraint({ negative: [] }, "toggleNegative");
      },
    },
  });
function TD(t, e, n, s, o, r) {
  const l = H("CheckBox"),
    i = H("TooltipIndicator"),
    a = H("FormControlLabel"),
    u = H("DigitSetInput");
  return (
    d(),
    C(
      Z,
      null,
      [
        c(a, null, {
          default: f(() => [
            c(
              l,
              {
                checked: t.negative.length > 0,
                "onUpdate:checked": t.updateNegative,
              },
              null,
              8,
              ["checked", "onUpdate:checked"]
            ),
            h("span", null, [
              e[2] || (e[2] = F(" Negative constraint ")),
              c(i, null, {
                default: f(
                  () =>
                    e[1] ||
                    (e[1] = [
                      F(
                        " All cells not joined with a dot must not have any of the specified ratios "
                      ),
                    ])
                ),
                _: 1,
              }),
            ]),
          ]),
          _: 1,
        }),
        t.negative.length > 0
          ? (d(),
            w(
              u,
              {
                key: 0,
                value: t.negative,
                digits: t.allowedRatios,
                default: t.defaultNegativeRatios,
                label: "Disallowed ratios",
                "onUpdate:value": t.onNegativeInputChange,
              },
              null,
              8,
              ["value", "digits", "default", "onUpdate:value"]
            ))
          : z("", !0),
        t.showNegativeDifferenceOverride
          ? (d(),
            w(
              a,
              { key: 1 },
              {
                default: f(() => [
                  c(
                    l,
                    {
                      checked: t.overrideNegativeDifferences,
                      "onUpdate:checked":
                        e[0] ||
                        (e[0] = (p) =>
                          t.context.updateConstraint(
                            { overrideNegativeDifferences: p },
                            "update:overrideNegativeDifferences"
                          )),
                    },
                    null,
                    8,
                    ["checked"]
                  ),
                  h("span", null, [
                    e[4] ||
                      (e[4] = F(" Override negative difference constraints ")),
                    t.mentionNonconsecutive
                      ? (d(),
                        C(
                          Z,
                          { key: 0 },
                          [F(" (including the nonconsecutive constraint) ")],
                          64
                        ))
                      : z("", !0),
                    c(i, null, {
                      default: f(
                        () =>
                          e[3] ||
                          (e[3] = [
                            F(
                              " Allow, for example, a 2-dot to have a 1-2 pair even when a nonconsecutive constraint would’ve disallowed it. "
                            ),
                          ])
                      ),
                      _: 1,
                    }),
                  ]),
                ]),
                _: 1,
              }
            ))
          : z("", !0),
      ],
      64
    )
  );
}
const VD = B(ND, [
  ["render", TD],
  ["__scopeId", "data-v-6fb57dc9"],
]);
function jD(t) {
  return (
    typeof t == "function" ||
    (Object.prototype.toString.call(t) === "[object Object]" && !Nt(t))
  );
}
const UD = {
  size: 0.32,
  fill: "#000",
  stroke: { color: "#000", thickness: 0.02 },
};
function Ju(t) {
  const e = t.clues.some((n) => n.value !== 2);
  return t.clues.map((n) => ({
    value: n.value === 2 && !e ? "" : String(n.value),
    edge: n.edge,
  }));
}
const pr = {
  default: (t) => {
    const e = { fill: "#fff" };
    return [
      c(
        "circle",
        { r: UD.size / 2, fill: "#000", stroke: "#000", "stroke-width": 0.02 },
        null
      ),
      c(kn, St({ value: t.value, "font-size": 0.25 }, e), null),
    ];
  },
};
function Qu(t) {
  return t.type !== Ie.Custom
    ? [...Ve(t.minDigit, t.maxDigit)].filter((e) =>
        t.minDigit === 0 ? e > 0 : e !== 1
      )
    : [...Ve(t.minDigit, t.maxDigit)];
}
_e({
  type: _.Ratio,
  label: "Ratio Kropki dots",
  preview: OD,
  renderers: (t) => [
    {
      layer: oe.Foreground,
      component: c(
        Bo,
        { edgeClues: Ju(t) },
        jD(pr) ? pr : { default: () => [pr] }
      ),
    },
  ],
  editor: xe({
    editor: {
      component: ma,
      props: (t, { project: e }) => ({
        edgeClues: Ju(t),
        inputMode: { ...Kc(Qu(e.spec), e.spec), type: Ke.Replace },
        highlightRadius: 0.17,
      }),
      slots: pr,
    },
    propertiesForm: {
      component: VD,
      props: (t, e) => {
        const n = new Set();
        for (const s of t.clues) n.add(s.value);
        return {
          usedRatios: n,
          allowedRatios: Qu(e.project.spec),
          negative: t.negative,
          overrideNegativeDifferences: t.overrideNegativeDifferences,
        };
      },
    },
    updateFunc: (t, e) => {
      const { edgeClues: n, negative: s, overrideNegativeDifferences: o } = e;
      if (n) {
        const r = new Set(t.clues.map((l) => l.value));
        (t.clues = n.map((l) => ({
          value: Number(l.value || 2),
          edge: l.edge,
        }))),
          s === void 0 && yf(r, t);
      }
      s !== void 0 && (t.negative = s),
        o !== void 0 && (t.overrideNegativeDifferences = o);
    },
  }),
});
const HD = {
    class: "RegionSumsPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  WD = {
    fill: "none",
    stroke: "#000",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
  },
  ZD = ["stroke"],
  GD = S({
    __name: "RegionSumsPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", HD, [
          h("g", WD, [
            n[0] ||
              (n[0] = h(
                "path",
                { d: "M1 1h18v18H1zM10 1v5M1 10h5M10 19v-5M19 10h-5" },
                null,
                -1
              )),
            n[1] || (n[1] = h("path", { d: "M8 9h4M8 11h4" }, null, -1)),
            h(
              "path",
              {
                d: "M3 17V8l5-5h4M17 8v4l-2 2h-3",
                "stroke-width": "1.5",
                stroke: e.constraint.style.color,
              },
              null,
              8,
              ZD
            ),
          ]),
        ])
      );
    },
  }),
  qD = S({
    components: { RadioList: Go },
    props: {
      context: { type: Object, required: !0 },
      singleRegionTotals: { type: Boolean, required: !0 },
    },
    methods: {
      toggleMultiple(t) {
        this.context.updateConstraint(
          { singleRegionTotals: !!t },
          "toggleSingleRegionTotals"
        );
      },
    },
  });
function KD(t, e, n, s, o, r) {
  const l = H("RadioList");
  return (
    d(),
    C("div", null, [
      e[1] || (e[1] = F(" Every visit to a region... ")),
      c(
        l,
        {
          options: [
            { value: 0, label: "counts to a new total" },
            {
              value: 1,
              label: "counts towards the same total for that region",
            },
          ],
          value: t.singleRegionTotals ? 1 : 0,
          "onUpdate:value": e[0] || (e[0] = (i) => t.toggleMultiple(i)),
        },
        null,
        8,
        ["value"]
      ),
    ])
  );
}
const XD = B(qD, [["render", KD]]);
_e({
  type: _.RegionSumLine,
  label: "Region sum lines",
  preview: GD,
  renderers: (t) => [
    {
      layer: oe.Default,
      component: c(Ms, { lines: t.lines, style: t.style }, null),
    },
  ],
  editor: xe({
    editor: {
      component: As,
      props: (t) => ({
        lines: t.lines,
        style: t.style,
        restrictions: { allowCycles: !0, allowBranching: !0 },
      }),
    },
    propertiesForm: {
      component: XD,
      props: (t) => ({ singleRegionTotals: t.singleRegionTotals }),
    },
    updateFunc: (t, e) => {
      const { lines: n, singleRegionTotals: s } = e;
      s !== void 0 && (t.singleRegionTotals = s), n && (t.lines = n);
    },
  }),
});
const YD = ["transform"],
  JD = S({
    __name: "RegionsEditor",
    props: { context: {}, regions: {} },
    setup(t) {
      const e = t,
        n = j(new kp()),
        s = b(() => {
          const x = n.value.getLastSelected();
          return x === void 0 || e.regions[x] === -1
            ? ""
            : (e.regions[x] + 1).toString();
        }),
        o = b(() => {
          const { size: x, digitCount: A } = e.context.project.spec;
          return x.width !== x.height ? !1 : A === x.width;
        }),
        r = b(() => e.context.project.spec.size),
        l = b(() =>
          e.context.project.spec.type === Ie.Custom
            ? {
                panel: [...Ve(1, 9)].map((x) => yn(x, x.toString())),
                zeroButton: qc,
                deleteButton: !0,
                validation(x) {
                  return Number(x) <= 64;
                },
                type: Ke.Concatenate,
              }
            : {
                panel: [...Ve(1, e.context.project.spec.maxDigit)].map((x) =>
                  yn(x, x.toString())
                ),
                deleteButton: !0,
                type: Ke.Replace,
              }
        ),
        i = b(() => {
          const x = {};
          for (const V of e.regions) x[V] = (x[V] || 0) + 1;
          const A = e.context.project.spec.digitCount,
            O = new Set();
          for (const [V, I] of Object.entries(x)) I > A && O.add(Number(V));
          return O;
        }),
        a = b(() => Oc(e.context.project.spec, e.regions)),
        u = b(() => o.value && [4, 6, 8, 9].includes(r.value.width));
      function p(x) {
        g(x === "" ? -1 : Number(x) - 1);
      }
      function m() {
        g(-1);
      }
      function g(x) {
        if (!$(x)) return;
        const A = e.regions.map((O, V) => (n.value.has(V) ? x : O));
        x !== -1 && k(A), e.context.updateConstraint({ regions: A }, "update");
      }
      function v() {
        const x = Pc(e.context.project.spec);
        e.context.updateConstraint({ regions: x }, "update");
      }
      function $(x) {
        for (const A of n.value.getCellIds()) if (e.regions[A] !== x) return !0;
        return !1;
      }
      function k(x) {
        if (!o.value) return;
        const A = e.context.project.spec.size.width,
          O = Array.from({ length: A }, () => []);
        for (let I = 0; I < x.length; I++) {
          const U = x[I];
          U >= 0 && U < A && O[U].push(I);
        }
        let V = -1;
        for (let I = 0; I < O.length; I++) {
          const U = O[I];
          if (U.length > A || (U.length < A && V !== -1)) return;
          U.length < A && (V = I);
        }
        V !== -1 &&
          x.forEach((I, U) => {
            I === -1 && (x[U] = V);
          });
      }
      function M(x) {
        const { x: A, y: O } = e.context.helpers.cellIds.getCoordsFromId(x);
        return `translate(${A} ${O})`;
      }
      function P(x) {
        const A = new Set();
        for (const O of e.context.helpers.cellIds.getAllCellIds())
          e.regions[O] === e.regions[x] && A.add(O);
        n.value.addMultiple(A);
      }
      return (x, A) => (
        d(),
        C(
          Z,
          null,
          [
            c(
              yt,
              { class: "RegionsEditor", context: x.context },
              {
                buttons: f(() => [
                  u.value
                    ? (d(),
                      w(
                        te,
                        { key: 0, disabled: a.value, onClick: v },
                        {
                          default: f(
                            () =>
                              A[0] || (A[0] = [F(" Reset to default boxes ")])
                          ),
                          _: 1,
                        },
                        8,
                        ["disabled"]
                      ))
                    : z("", !0),
                ]),
                _: 1,
              },
              8,
              ["context"]
            ),
            c(
              ct,
              { layer: y(oe).AboveDigits },
              {
                default: f(() => [
                  (d(!0),
                  C(
                    Z,
                    null,
                    se(
                      x.regions,
                      (O, V) => (
                        d(),
                        C(
                          "g",
                          {
                            key: V,
                            transform: M(V),
                            class: Ae({ invalid: i.value.has(O) }),
                            opacity: "0.9",
                          },
                          [
                            O >= 0
                              ? (d(),
                                C(
                                  Z,
                                  { key: 0 },
                                  [
                                    A[1] ||
                                      (A[1] = h(
                                        "rect",
                                        {
                                          fill: "#fff",
                                          x: "0",
                                          y: "0",
                                          width: "1",
                                          height: "1",
                                        },
                                        null,
                                        -1
                                      )),
                                    c(
                                      kn,
                                      {
                                        x: 0.5,
                                        y: 0.5,
                                        "font-size": 0.8,
                                        value: O + 1,
                                      },
                                      null,
                                      8,
                                      ["value"]
                                    ),
                                  ],
                                  64
                                ))
                              : z("", !0),
                          ],
                          10,
                          YD
                        )
                      )
                    ),
                    128
                  )),
                  c(
                    bp,
                    { spec: x.context.project.spec, model: n.value, onHold: P },
                    null,
                    8,
                    ["spec", "model"]
                  ),
                  c(Vi, { regions: x.regions }, null, 8, ["regions"]),
                ]),
                _: 1,
              },
              8,
              ["layer"]
            ),
            c(
              y(jn),
              { mode: l.value, "current-value": s.value, onUpdate: p },
              null,
              8,
              ["mode", "current-value"]
            ),
            c(y(Jo), { onDelete: m }),
          ],
          64
        )
      );
    },
  }),
  QD = B(JD, [["__scopeId", "data-v-12f7f3da"]]),
  eM = {
    class: "RegionsPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "#000",
    fill: "none",
  },
  tM = ["x1", "x2", "stroke-width"],
  nM = ["y1", "y2", "stroke-width"],
  sM = S({
    __name: "RegionsPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", eM, [
          n[0] ||
            (n[0] = h(
              "rect",
              { x: "1", y: "1", width: "18", height: "18" },
              null,
              -1
            )),
          (d(),
          C(
            Z,
            null,
            se([1, 2, 3, 4, 5, 6, 7, 8], (s) =>
              h(
                "line",
                {
                  key: s,
                  x1: s * 2 + 1,
                  x2: s * 2 + 1,
                  y1: 1,
                  y2: 19,
                  "stroke-width": s % 3 === 0 ? 1 : 0.25,
                },
                null,
                8,
                tM
              )
            ),
            64
          )),
          (d(),
          C(
            Z,
            null,
            se([1, 2, 3, 4, 5, 6, 7, 8], (s) =>
              h(
                "line",
                {
                  key: s,
                  y1: s * 2 + 1,
                  y2: s * 2 + 1,
                  x1: 1,
                  x2: 19,
                  "stroke-width": s % 3 === 0 ? 1 : 0.25,
                },
                null,
                8,
                nM
              )
            ),
            64
          )),
        ])
      );
    },
  });
_e({
  type: _.Regions,
  label: "Regions",
  preview: sM,
  unique: !0,
  renderers: (t) => [
    { layer: oe.Grid, component: c(Vi, { regions: t.regions }, null) },
  ],
  editor: xe({ editor: { component: QD, props: (t) => sn(t, "regions") } }),
});
_e({
  type: _.Renban,
  label: "Renban lines",
  preview: pf,
  renderers: (t) => [
    {
      layer: oe.Default,
      component: c(Ms, { lines: t.lines, style: t.style }, null),
    },
  ],
  editor: xe({
    editor: {
      component: As,
      props: (t, { project: e }) => ({
        lines: t.lines,
        style: t.style,
        restrictions: {
          allowBranching: !0,
          allowCycles: !0,
          maxPoints: e.spec.digitCount,
        },
      }),
    },
  }),
});
const oM = {
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
  },
  rM = ["stroke"],
  lM = ["fill"],
  iM = S({
    __name: "SandwichSumPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", oM, [
          n[1] ||
            (n[1] = h(
              "path",
              {
                d: "M1 7s.02-6 4-6h10c3.95 0 4 6 4 6H1ZM19 14s-.02 5-4 5H5c-3.95 0-4-5-4-5h18Z",
                fill: "#fff",
                stroke: "#000",
              },
              null,
              -1
            )),
          n[2] ||
            (n[2] = h(
              "path",
              {
                d: "M8 1 6 3M11 1 9 3M14 1l-2 2",
                fill: "none",
                stroke: "#000",
              },
              null,
              -1
            )),
          h(
            "g",
            { fill: "#fff", stroke: e.constraint.style.color },
            n[0] ||
              (n[0] = [
                h(
                  "ellipse",
                  { cx: "5", cy: "10.5", rx: "4", ry: "3.5" },
                  null,
                  -1
                ),
                h(
                  "ellipse",
                  { cx: "10", cy: "10.5", rx: "4", ry: "3.5" },
                  null,
                  -1
                ),
                h(
                  "ellipse",
                  { cx: "15", cy: "10.5", rx: "4", ry: "3.5" },
                  null,
                  -1
                ),
              ]),
            8,
            rM
          ),
          h(
            "path",
            {
              d: "m13.55 11.45.6-.08c.06.34.18.58.34.73.17.15.37.22.6.22.28 0 .52-.1.7-.29.2-.2.3-.43.3-.72a.9.9 0 0 0-.95-.93c-.11 0-.25.02-.42.06l.07-.52h.1c.25 0 .47-.06.67-.19.2-.13.3-.34.3-.6 0-.23-.07-.4-.21-.55a.78.78 0 0 0-.57-.21.8.8 0 0 0-.58.21c-.15.15-.25.37-.3.66l-.59-.1c.07-.4.24-.71.5-.93.25-.22.57-.33.95-.33.27 0 .51.06.73.17a1.23 1.23 0 0 1 .69 1.08c0 .21-.06.4-.17.57-.11.18-.28.31-.5.41.29.07.5.2.67.41.16.21.23.47.23.78 0 .42-.15.78-.46 1.07-.3.3-.7.44-1.16.44a1.46 1.46 0 0 1-1.53-1.36ZM11.52 12.37v.57H8.33c0-.14.02-.28.07-.4.08-.23.21-.44.4-.65.17-.21.43-.46.77-.73.52-.43.88-.77 1.06-1.03.18-.25.28-.48.28-.7a.79.79 0 0 0-.26-.6.9.9 0 0 0-.65-.24.93.93 0 0 0-.69.25.97.97 0 0 0-.26.71l-.6-.06c.04-.45.2-.8.46-1.04a1.6 1.6 0 0 1 1.1-.35c.46 0 .83.12 1.1.38.27.26.4.57.4.96 0 .19-.03.38-.11.57a2.2 2.2 0 0 1-.4.58c-.18.21-.48.5-.91.85-.36.3-.58.5-.69.61-.1.1-.18.21-.25.32h2.37ZM4.68 12.72v-1.16h-2.1v-.54L4.8 7.89h.48v3.13h.66v.54h-.66v1.16h-.59Zm0-1.7V8.84l-1.51 2.18h1.51Z",
              fill: e.constraint.style.color,
            },
            null,
            8,
            lM
          ),
        ])
      );
    },
  });
function aM(t) {
  return (
    typeof t == "function" ||
    (Object.prototype.toString.call(t) === "[object Object]" && !Nt(t))
  );
}
function xf(t) {
  return (e) => ({
    default({ value: n, selected: s }) {
      return n === void 0 && !t
        ? []
        : [
            c(
              nr,
              { value: n ?? "", fill: e.style.color, showCaret: t && s },
              null
            ),
          ];
    },
  });
}
const uM = xf(!0),
  cM = xf(!1);
_e({
  type: _.SandwichSums,
  label: "Sandwich sums",
  preview: iM,
  margins: Bn(1),
  renderers: (t) => {
    let e;
    return [
      {
        layer: oe.Default,
        component: c(
          Is,
          { clues: t.clues },
          aM((e = cM(t))) ? e : { default: () => [e] }
        ),
      },
    ];
  },
  editor: xe({
    editor: {
      component: tr,
      props: (t, { project: e }) => ({
        clues: t.clues.map((n) => ({
          outerCell: n.outerCell,
          value: (n.value ?? "").toString(),
        })),
        type: zt.Orthogonal,
        bidirectional: !0,
        inputMode: {
          ...Zs(),
          validation: (n) =>
            Number(n) <=
            Cs(e.spec.maxDigit) - e.spec.minDigit - e.spec.maxDigit,
        },
        defaultValue: (n) => {
          let s = 0,
            o = !1;
          for (let r = 0; r < n.length; r++) {
            const l = n[r];
            if (!o) (l === 1 || l === 9) && (o = !0);
            else {
              if (l === void 0) return "";
              if (l === 1 || l === 9) return s.toString();
              s += l;
            }
          }
          return "";
        },
      }),
      slots: uM,
    },
    appearanceForm: {
      props: (t) => ({
        properties: [
          {
            type: "color",
            name: "color",
            label: "Color",
            value: t.style.color,
          },
        ],
      }),
    },
    updateFunc: (t, e) => {
      const { clues: n } = e;
      t.clues = n.map((s) => {
        let o;
        return (
          s.value === "" ? (o = void 0) : (o = Number(s.value)),
          { value: o, outerCell: s.outerCell }
        );
      });
    },
  }),
});
const dM = {
    class: "SequencePreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  pM = ["stroke"],
  fM = S({
    __name: "SequencePreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", dM, [
          h(
            "path",
            {
              d: "m1 5.5 9 9 9-9",
              fill: "none",
              stroke: e.constraint.style.color,
            },
            null,
            8,
            pM
          ),
          n[0] ||
            (n[0] = h(
              "path",
              {
                d: "M3.79 7.7v.59H.53c0-.15.02-.29.07-.42.08-.22.21-.44.4-.66.18-.21.44-.46.79-.75.54-.44.9-.79 1.09-1.04.19-.26.28-.5.28-.73a.81.81 0 0 0-.26-.6.93.93 0 0 0-.67-.26c-.3 0-.52.1-.7.27a1 1 0 0 0-.27.72l-.62-.06c.04-.46.2-.82.48-1.06.28-.25.65-.37 1.12-.37.48 0 .85.13 1.13.4.27.26.41.58.41.97 0 .2-.04.4-.12.58-.08.2-.21.4-.4.6-.19.22-.5.5-.94.88-.36.3-.6.5-.7.62-.1.1-.19.22-.25.33h2.42ZM18.04 8.29V7.1h-2.15v-.56l2.26-3.2h.5v3.2h.66v.56h-.67v1.18h-.6Zm0-1.74V4.32l-1.55 2.23h1.55ZM8.5 15.67l.6-.08c.07.34.19.59.36.74.16.15.37.23.6.23.3 0 .53-.1.73-.3a1 1 0 0 0 .3-.74.93.93 0 0 0-.97-.96c-.12 0-.26.03-.43.07l.07-.53h.1c.25 0 .49-.06.7-.2.2-.13.3-.34.3-.62 0-.22-.07-.4-.22-.55a.8.8 0 0 0-.59-.22.83.83 0 0 0-.59.22c-.15.15-.25.37-.3.67l-.6-.11c.07-.4.24-.72.5-.94.26-.23.59-.34.98-.34.27 0 .52.06.75.17a1.26 1.26 0 0 1 .7 1.11c0 .22-.06.41-.18.59-.11.17-.28.31-.5.41.29.07.51.21.68.42.16.22.24.48.24.8 0 .43-.16.8-.47 1.1-.32.3-.71.45-1.2.45a1.5 1.5 0 0 1-1.57-1.4Z",
                "fill-rule": "nonzero",
              },
              null,
              -1
            )),
        ])
      );
    },
  });
_e({
  type: _.Sequence,
  label: "Sequence lines",
  preview: fM,
  renderers: (t) => [
    {
      layer: oe.Default,
      component: c(Ms, { lines: t.lines, style: t.style }, null),
    },
  ],
  editor: xe({
    editor: {
      component: As,
      props: (t, { project: e }) => ({
        lines: t.lines,
        style: t.style,
        restrictions: {
          maxPoints: e.spec.digitCount,
          allowCycles: !1,
          allowBranching: !1,
        },
      }),
    },
  }),
});
const hM = { viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg" },
  mM = ["fill"],
  gM = S({
    __name: "SkyscrapersPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", hM, [
          n[0] ||
            (n[0] = h(
              "path",
              {
                d: "M1 19V7h6v12m0 0v-7h6v7m0 0V1h6v18",
                fill: "none",
                stroke: "#000",
              },
              null,
              -1
            )),
          h(
            "path",
            {
              d: "m5.54 9.73-.6.05a1.14 1.14 0 0 0-.23-.52.8.8 0 0 0-.6-.26.84.84 0 0 0-.51.16c-.2.14-.35.34-.46.61a3.2 3.2 0 0 0-.17 1.14 1.41 1.41 0 0 1 1.2-.66c.4 0 .75.15 1.03.45.29.3.43.68.43 1.16 0 .3-.07.6-.2.86a1.45 1.45 0 0 1-.55.61 1.5 1.5 0 0 1-.8.21c-.5 0-.91-.18-1.23-.55-.32-.38-.48-.99-.48-1.84 0-.96.18-1.65.53-2.08.3-.38.72-.57 1.24-.57.39 0 .7.1.96.33.24.21.4.52.44.9Zm-2.47 2.13c0 .2.04.4.13.6a1 1 0 0 0 .37.43c.16.1.33.15.5.15a.85.85 0 0 0 .66-.3c.19-.21.28-.5.28-.85 0-.34-.09-.6-.27-.8a.9.9 0 0 0-.69-.3.94.94 0 0 0-.7.3c-.19.2-.28.45-.28.77Zm5.33 5.3.6-.08c.08.34.2.59.36.74a.88.88 0 0 0 .61.23.98.98 0 0 0 .73-.3A1 1 0 0 0 11 17a.93.93 0 0 0-.28-.68.94.94 0 0 0-.7-.28c-.11 0-.25.03-.42.07l.06-.53a1.25 1.25 0 0 0 .8-.2c.2-.13.3-.34.3-.62a.73.73 0 0 0-.22-.55.8.8 0 0 0-.58-.22.83.83 0 0 0-.59.22c-.16.15-.26.37-.3.67l-.61-.11c.07-.4.24-.72.5-.94.27-.23.6-.34.99-.34.27 0 .51.06.74.17a1.25 1.25 0 0 1 .7 1.11c0 .22-.06.41-.17.59a1.17 1.17 0 0 1-.5.41c.28.07.51.21.67.42.16.22.24.48.24.8 0 .43-.15.8-.47 1.1-.31.3-.71.45-1.19.45-.43 0-.8-.13-1.08-.4a1.5 1.5 0 0 1-.49-1Zm6.09-10.84.58-.06c.05.28.14.48.28.6a.78.78 0 0 0 .54.19c.18 0 .35-.05.49-.13s.25-.2.34-.34c.1-.15.17-.34.23-.58a3.03 3.03 0 0 0 .09-.86 1.4 1.4 0 0 1-1.18.65c-.41 0-.76-.15-1.04-.45-.28-.3-.42-.69-.42-1.17 0-.5.14-.9.44-1.21a1.48 1.48 0 0 1 1.1-.46 1.58 1.58 0 0 1 1.5 1c.13.32.2.78.2 1.39a4.5 4.5 0 0 1-.2 1.5c-.14.38-.34.67-.61.86a1.58 1.58 0 0 1-.96.3c-.38 0-.7-.11-.94-.33a1.3 1.3 0 0 1-.44-.9Zm2.48-2.18c0-.35-.1-.63-.28-.83a.87.87 0 0 0-.67-.3.9.9 0 0 0-.7.32c-.2.22-.3.5-.3.86 0 .31.1.57.28.76.2.2.43.3.7.3a.9.9 0 0 0 .7-.3c.18-.2.27-.46.27-.81Z",
              fill: e.constraint.style.color,
            },
            null,
            8,
            mM
          ),
          n[1] ||
            (n[1] = h(
              "path",
              {
                fill: "none",
                stroke: "#000",
                d: "M14.5 11h.82v1h-.82zm2.25 0h.82v1h-.82zm-2.25 3h.82v1h-.82zm2.25 0h.82v1h-.82zm-2.25 3h.82v1h-.82zm2.25 0h.82v1h-.82zM3 19v-2h2v2",
              },
              null,
              -1
            )),
        ])
      );
    },
  });
function vM(t) {
  return (
    typeof t == "function" ||
    (Object.prototype.toString.call(t) === "[object Object]" && !Nt(t))
  );
}
function Df(t) {
  return (e) => ({
    default({ value: n, selected: s }) {
      return n === void 0 && !t
        ? []
        : [
            c(
              nr,
              {
                value: n ?? "",
                fill: e.style.color,
                showCaret: n === void 0 && t && s,
              },
              null
            ),
          ];
    },
  });
}
const yM = Df(!0),
  CM = Df(!1);
_e({
  type: _.Skyscrapers,
  label: "Skyscrapers",
  preview: gM,
  margins: Bn(1),
  renderers: (t) => {
    let e;
    return [
      {
        layer: oe.Default,
        component: c(
          Is,
          { clues: t.clues },
          vM((e = CM(t))) ? e : { default: () => [e] }
        ),
      },
    ];
  },
  editor: xe({
    editor: {
      component: tr,
      props: (t, { project: e }) => ({
        clues: t.clues.map((n) => ({
          outerCell: n.outerCell,
          value: (n.value ?? "").toString(),
        })),
        type: zt.Orthogonal,
        inputMode: { ...Yc(e.spec) },
        defaultValue: (n) => {
          let s = 0,
            o = 0;
          for (const r of n) {
            if (r === void 0) return "";
            if (r > s && ((s = r), o++, r === e.spec.maxDigit)) break;
          }
          return o.toString();
        },
      }),
      slots: yM,
    },
    appearanceForm: {
      props: (t) => ({
        properties: [
          {
            type: "color",
            name: "color",
            label: "Color",
            value: t.style.color,
          },
        ],
      }),
    },
    updateFunc: (t, e, n) => {
      const { clues: s } = e;
      t.clues = s.map((o) => {
        let r;
        return (
          o.value === ""
            ? (r = void 0)
            : Number(o.value)
            ? (r = Number(o.value))
            : (r = n.project.spec.minDigit === 0 ? 0 : void 0),
          { value: r, outerCell: o.outerCell }
        );
      });
    },
  }),
});
const wM = {
    class: "SudokuRulesPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "#000",
    fill: "none",
    "stroke-linecap": "round",
  },
  bM = ["x1", "x2"],
  kM = ["y1", "y2"],
  _M = S({
    __name: "SudokuRulesPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", wM, [
          n[0] ||
            (n[0] = h(
              "rect",
              { x: "1", y: "1", width: "18", height: "18" },
              null,
              -1
            )),
          (d(),
          C(
            Z,
            null,
            se([1, 2, 3, 4, 5, 6, 7, 8], (s) =>
              h(
                "line",
                {
                  key: s,
                  x1: s * 2 + 1,
                  x2: s * 2 + 1,
                  y1: 1,
                  y2: 19,
                  "stroke-width": 0.25,
                },
                null,
                8,
                bM
              )
            ),
            64
          )),
          (d(),
          C(
            Z,
            null,
            se([1, 2, 3, 4, 5, 6, 7, 8], (s) =>
              h(
                "line",
                {
                  key: s,
                  y1: s * 2 + 1,
                  y2: s * 2 + 1,
                  x1: 1,
                  x2: 19,
                  "stroke-width": 0.25,
                },
                null,
                8,
                kM
              )
            ),
            64
          )),
        ])
      );
    },
  });
_e({
  type: _.SudokuRules,
  selectable: !1,
  label: "Rows and columns",
  preview: _M,
  unique: !0,
});
const $M = ["opacity"],
  SM = ["d", "stroke", "stroke-width"],
  IM = ["cx", "cy", "fill", "r"],
  xM = S({
    __name: "Thermometer",
    props: {
      paths: {},
      bulbRadius: { default: 0.4 },
      lineWidth: { default: 0.32 },
      color: { default: "#cccccc" },
    },
    setup(t) {
      const e = t,
        n = b(() => Gt(e.color) || { red: 0, green: 0, blue: 0, alpha: 1 }),
        s = b(() => Us(n.value)),
        o = b(() => n.value.alpha),
        r = b(() => {
          let i = "";
          for (const a of e.paths)
            for (let u = 0; u < a.length; u++) {
              const p = a[u].x + 0.5,
                m = a[u].y + 0.5;
              i += u === 0 ? `M${p} ${m}` : `L${p} ${m}`;
            }
          return i;
        }),
        l = b(() => {
          const i = new Br();
          for (const a of e.paths) i.add(a[0]);
          for (const a of e.paths)
            for (let u = 1; u < a.length; u++) i.delete(a[u]);
          return [...i];
        });
      return (i, a) => (
        d(),
        C(
          "g",
          { opacity: o.value },
          [
            h(
              "path",
              {
                d: r.value,
                fill: "none",
                stroke: s.value,
                "stroke-width": e.lineWidth,
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
              },
              null,
              8,
              SM
            ),
            (d(!0),
            C(
              Z,
              null,
              se(
                l.value,
                (u, p) => (
                  d(),
                  C(
                    "circle",
                    {
                      key: p,
                      cx: u.x + 0.5,
                      cy: u.y + 0.5,
                      fill: s.value,
                      r: i.bulbRadius,
                    },
                    null,
                    8,
                    IM
                  )
                )
              ),
              128
            )),
          ],
          8,
          $M
        )
      );
    },
  }),
  Mf = S({
    __name: "ThermometerRenderer",
    props: { thermometers: {}, style: {} },
    setup(t) {
      const e = t,
        { helpers: n } = Qe(et).value,
        s = b(() =>
          e.thermometers.map((o) => o.map((r) => n.cellIds.getCoordsFromId(r)))
        );
      return (o, r) => (
        d(),
        w(
          xM,
          {
            paths: s.value,
            color: o.style.color,
            "line-width": o.style.thickness,
            "bulb-radius": o.style.bulbRadius,
          },
          null,
          8,
          ["paths", "color", "line-width", "bulb-radius"]
        )
      );
    },
  }),
  DM = S({
    components: { ThermometerRenderer: Mf, LineEditor: As },
    props: {
      context: { type: Object, required: !0 },
      lines: { type: Array, required: !0 },
      style: { type: Object, required: !0 },
      maxLength: { type: Number, default: 0 },
    },
    methods: {
      restrictions(t) {
        return new tp(t).isValid(this.maxLength);
      },
    },
  });
function MM(t, e, n, s, o, r) {
  const l = H("ThermometerRenderer"),
    i = H("LineEditor");
  return (
    d(),
    w(
      i,
      {
        context: t.context,
        style: We(t.style),
        lines: t.lines,
        restrictions: t.restrictions,
        directed: "",
      },
      os(
        {
          default: f(({ paths: a }) => [
            c(l, { style: We(t.style), thermometers: a }, null, 8, [
              "style",
              "thermometers",
            ]),
          ]),
          placeholder: f(({ paths: a, color: u, padding: p }) => [
            c(
              l,
              {
                style: We({
                  color: u,
                  thickness: t.style.thickness + 2 * p,
                  bulbRadius: t.style.bulbRadius + p,
                }),
                thermometers: a,
              },
              null,
              8,
              ["style", "thermometers"]
            ),
          ]),
          selection: f(({ paths: a, color: u, padding: p }) => [
            c(
              l,
              {
                style: We({
                  color: u,
                  thickness: t.style.thickness + 2 * p,
                  bulbRadius: t.style.bulbRadius + p,
                }),
                thermometers: a,
              },
              null,
              8,
              ["style", "thermometers"]
            ),
            c(
              l,
              {
                style: We({
                  color: "#ffffff",
                  thickness: t.style.thickness,
                  bulbRadius: t.style.bulbRadius,
                }),
                thermometers: a,
              },
              null,
              8,
              ["style", "thermometers"]
            ),
          ]),
          _: 2,
        },
        [
          t.$slots.properties
            ? {
                name: "properties",
                fn: f(() => [G(t.$slots, "properties")]),
                key: "0",
              }
            : void 0,
          t.$slots.appearance
            ? {
                name: "appearance",
                fn: f(() => [G(t.$slots, "appearance")]),
                key: "1",
              }
            : void 0,
        ]
      ),
      1032,
      ["context", "style", "lines", "restrictions"]
    )
  );
}
const AM = B(DM, [["render", MM]]),
  PM = {
    class: "ThermometerPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  LM = ["fill"],
  EM = S({
    __name: "ThermometerPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", PM, [
          h(
            "path",
            {
              d: "M14.5 1a1.5 1.5 0 0 1 1.49 1.68H16V15a1.5 1.5 0 1 1-3-.1V4H7v6.76a4.5 4.5 0 1 1-3 0V2.68h.01L4 2.5C4 1.68 4.67 1 5.5 1h9Z",
              fill: e.constraint.style.color,
            },
            null,
            8,
            LM
          ),
        ])
      );
    },
  }),
  FM = S({
    components: { FormControlLabel: ut, CheckBox: at, TooltipIndicator: dt },
    props: {
      slow: { type: Boolean, required: !0 },
      context: { type: Object, required: !0 },
    },
    methods: {
      toggleSlow(t) {
        this.context.updateConstraint({ slow: t }, "toggleSlow");
      },
    },
  });
function BM(t, e, n, s, o, r) {
  const l = H("CheckBox"),
    i = H("TooltipIndicator"),
    a = H("FormControlLabel");
  return (
    d(),
    w(a, null, {
      default: f(() => [
        c(
          l,
          {
            checked: t.slow,
            "onUpdate:checked": e[0] || (e[0] = (u) => t.toggleSlow(u)),
          },
          null,
          8,
          ["checked"]
        ),
        h("span", null, [
          e[2] || (e[2] = F(" Slow thermometers ")),
          c(i, null, {
            default: f(
              () =>
                e[1] ||
                (e[1] = [
                  F(
                    " Digits on a slow thermometer either increase or stay the same as they move away from the bulb, but never decrease. "
                  ),
                ])
            ),
            _: 1,
          }),
        ]),
      ]),
      _: 1,
    })
  );
}
const zM = B(FM, [["render", BM]]);
_e({
  type: _.Thermometer,
  label: (t) => (t.slow ? "Slow thermometers" : "Thermometers"),
  preview: EM,
  renderers: (t) => [
    {
      layer: oe.Default,
      component: c(Mf, { thermometers: t.thermometers, style: t.style }, null),
    },
  ],
  editor: xe({
    editor: {
      component: AM,
      props: (t, { project: e }) => ({
        lines: t.thermometers,
        style: t.style,
        maxLength: t.slow ? 0 : e.spec.digitCount - 1,
      }),
    },
    propertiesForm: { component: zM, props: (t) => ({ slow: t.slow }) },
    appearanceForm: {
      props: (t) => ({
        properties: [
          {
            type: "radius",
            name: "bulbRadius",
            label: "Bulb radius",
            value: t.style.bulbRadius,
          },
        ],
      }),
    },
    updateFunc: (t, e) => {
      const { lines: n, slow: s } = e;
      s !== void 0 && (t.slow = s), n && (t.thermometers = n);
    },
  }),
});
const RM = {
    class: "WhispersPreview",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
  },
  OM = ["stroke"],
  NM = S({
    __name: "WhispersPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", RM, [
          h(
            "path",
            {
              d: "M1 1L19 19M1 10H18M1 19L19 1",
              stroke: e.constraint.style.color,
              fill: "none",
            },
            null,
            8,
            OM
          ),
        ])
      );
    },
  }),
  TM = S({
    components: { FormRow: ve, NumberInput: Ht },
    props: {
      context: { type: Object, required: !0 },
      minDifference: { type: Number, required: !0 },
    },
    data() {
      return { inputControlId: fe() };
    },
    computed: {
      maxDifference() {
        return (
          this.context.project.spec.maxDigit -
          this.context.project.spec.minDigit
        );
      },
    },
  });
function VM(t, e, n, s, o, r) {
  const l = H("NumberInput"),
    i = H("FormRow");
  return (
    d(),
    w(
      i,
      { label: "Minimum difference:" },
      {
        default: f(() => [
          c(
            l,
            {
              value: t.minDifference,
              max: t.maxDifference,
              step: "1",
              min: 1,
              "onUpdate:value":
                e[0] ||
                (e[0] = (a) =>
                  t.context.updateConstraint(
                    { minDifference: a },
                    "update:minDifference"
                  )),
            },
            null,
            8,
            ["value", "max"]
          ),
        ]),
        _: 1,
      }
    )
  );
}
const jM = B(TM, [
  ["render", VM],
  ["__scopeId", "data-v-8af83376"],
]);
_e({
  type: _.Whisper,
  label: (t, e) => {
    const n = t.minDifference;
    switch (n) {
      case Math.floor((e.digitCount - 1) / 2):
        return "Dutch whisper lines";
      case Math.floor((e.digitCount + 1) / 2):
        return "German whisper lines";
      default:
        return `${n}-whisper lines`;
    }
  },
  preview: NM,
  renderers: (t) => [
    {
      layer: oe.Default,
      component: c(Ms, { lines: t.lines, style: t.style }, null),
    },
  ],
  editor: xe({
    editor: { component: As, props: (t) => sn(t, "lines", "style") },
    propertiesForm: { component: jM, props: (t) => sn(t, "minDifference") },
  }),
});
const UM = {
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    "stroke-linecap": "square",
  },
  HM = ["fill"],
  WM = S({
    __name: "XSumsPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C("svg", UM, [
          h(
            "path",
            {
              d: "m1.44 12.25 1.01-.1c.09.49.25.83.5 1.05.24.21.55.32.93.32.32 0 .6-.08.85-.22.24-.15.44-.35.6-.6.16-.25.29-.58.4-1a5.31 5.31 0 0 0 .14-1.5 2.42 2.42 0 0 1-2.05 1.13 2.4 2.4 0 0 1-1.8-.78c-.5-.51-.74-1.2-.74-2.03 0-.88.26-1.58.77-2.1.51-.54 1.16-.8 1.93-.8a2.76 2.76 0 0 1 2.59 1.73c.24.56.36 1.36.36 2.42a7.8 7.8 0 0 1-.36 2.62c-.24.65-.6 1.15-1.06 1.49-.47.34-1.02.5-1.66.5a2.4 2.4 0 0 1-1.64-.55 2.4 2.4 0 0 1-.77-1.58Zm4.32-3.79c0-.6-.16-1.08-.49-1.44a1.51 1.51 0 0 0-1.16-.53c-.47 0-.88.19-1.22.57-.35.38-.53.88-.53 1.49 0 .55.17 1 .5 1.33.33.35.74.52 1.22.52.49 0 .9-.17 1.2-.52.32-.34.48-.81.48-1.42ZM10.84 14.24l3.33-4.48-2.93-4.11h1.35l1.56 2.2c.32.46.55.81.69 1.06.2-.31.42-.64.68-.98l1.73-2.28h1.23L15.47 9.7l3.25 4.54h-1.4l-2.17-3.06c-.12-.18-.25-.37-.37-.58l-.41.65-2.16 2.99h-1.37Z",
              fill: y(Ws)(e.constraint.style.color),
            },
            null,
            8,
            HM
          ),
          n[0] ||
            (n[0] = h(
              "path",
              {
                d: "M9 1v18",
                fill: "none",
                stroke: "#000",
                "stroke-width": "1.5",
              },
              null,
              -1
            )),
          n[1] ||
            (n[1] = h(
              "path",
              { d: "M9 3h10M9 17h10", fill: "none", stroke: "#000" },
              null,
              -1
            )),
        ])
      );
    },
  });
function ZM(t) {
  return (
    typeof t == "function" ||
    (Object.prototype.toString.call(t) === "[object Object]" && !Nt(t))
  );
}
function Af(t) {
  return (e) => ({
    default({ value: n, selected: s }) {
      return n === void 0 && !t
        ? []
        : [
            c(
              nr,
              { value: n ?? "", fill: e.style.color, showCaret: t && s },
              null
            ),
          ];
    },
  });
}
const GM = Af(!0),
  qM = Af(!1);
_e({
  type: _.XSums,
  label: "X-sums",
  preview: WM,
  margins: Bn(1),
  renderers: (t) => {
    let e;
    return [
      {
        layer: oe.Default,
        component: c(
          Is,
          { clues: t.clues },
          ZM((e = qM(t))) ? e : { default: () => [e] }
        ),
      },
    ];
  },
  editor: xe({
    editor: {
      component: tr,
      props: (t, { project: e }) => ({
        clues: t.clues.map((n) => ({
          outerCell: n.outerCell,
          value: (n.value ?? "").toString(),
        })),
        type: zt.Orthogonal,
        inputMode: {
          ...Zs(),
          validation: (n) =>
            e.spec.type === Ie.Custom
              ? Number(n) <= 99
              : Number(n) <= Cs(e.spec.maxDigit),
        },
        defaultValue: (n) => {
          if (n[0] !== void 0) {
            let s = n[0];
            for (let o = 1; o < n[0]; o++) {
              if (n[o] === void 0) return "";
              s += n[o];
            }
            return s.toString();
          }
          return "";
        },
      }),
      slots: GM,
    },
    appearanceForm: {
      props: (t) => ({
        properties: [
          {
            type: "color",
            name: "color",
            label: "Color",
            value: t.style.color,
          },
        ],
      }),
    },
    updateFunc: (t, e, n) => {
      const { clues: s } = e;
      t.clues = s.map((o) => {
        let r;
        return (
          o.value === ""
            ? (r = void 0)
            : Number(o.value)
            ? (r = Number(o.value))
            : (r = n.project.spec.minDigit === 0 ? 0 : void 0),
          { value: r, outerCell: o.outerCell }
        );
      });
    },
  }),
});
const KM = { viewBox: "0 0 19 10", xmlns: "http://www.w3.org/2000/svg" },
  XM = S({
    __name: "XVPreview",
    props: { constraint: {}, context: {} },
    setup(t) {
      return (e, n) => (
        d(),
        C(
          "svg",
          KM,
          n[0] ||
            (n[0] = [
              h(
                "path",
                {
                  d: "M0 9.83 3.32 4.8.31.17H2.6l1.94 3.1 1.9-3.1H8.7l-3.01 4.7 3.3 4.96H6.64L4.5 6.5 2.35 9.83H0ZM12.46 9.83 9.01.17h2.11l2.45 7.15L15.94.17H18l-3.47 9.66h-2.08Z",
                },
                null,
                -1
              ),
            ])
        )
      );
    },
  }),
  YM = S({
    components: { FormControlLabel: ut, CheckBox: at, TooltipIndicator: dt },
    props: {
      negative: { type: Array, required: !0 },
      context: { type: Object, required: !0 },
    },
    data() {
      return { inputControlId: fe(), negativeInput: "2" };
    },
    watch: {
      negative: {
        immediate: !0,
        handler(t) {
          this.negativeInput = t.join(" ");
        },
      },
    },
    methods: {
      toggleNegative(t, e) {
        const s = this.negative.slice();
        e && !s.includes(t) ? s.push(t) : !e && s.includes(t) && _t(s, [t]),
          this.context.updateConstraint({ negative: s }, "toggleNegative");
      },
    },
  });
function JM(t, e, n, s, o, r) {
  const l = H("CheckBox"),
    i = H("TooltipIndicator"),
    a = H("FormControlLabel");
  return (
    d(),
    C(
      Z,
      null,
      [
        c(a, null, {
          default: f(() => [
            c(
              l,
              {
                checked: t.negative.includes(10),
                "onUpdate:checked":
                  e[0] || (e[0] = (u) => t.toggleNegative(10, u)),
              },
              null,
              8,
              ["checked"]
            ),
            h("span", null, [
              e[3] || (e[3] = F(" Negative X constraint ")),
              c(i, null, {
                default: f(
                  () =>
                    e[2] ||
                    (e[2] = [
                      F(
                        " All pairs of adjacent cells not joined with an X cannot sum to 10 "
                      ),
                    ])
                ),
                _: 1,
              }),
            ]),
          ]),
          _: 1,
        }),
        c(a, null, {
          default: f(() => [
            c(
              l,
              {
                checked: t.negative.includes(5),
                "onUpdate:checked":
                  e[1] || (e[1] = (u) => t.toggleNegative(5, u)),
              },
              null,
              8,
              ["checked"]
            ),
            h("span", null, [
              e[5] || (e[5] = F(" Negative V constraint ")),
              c(i, null, {
                default: f(
                  () =>
                    e[4] ||
                    (e[4] = [
                      F(
                        " All pairs of adjacent cells not joined with a V cannot sum to 5 "
                      ),
                    ])
                ),
                _: 1,
              }),
            ]),
          ]),
          _: 1,
        }),
      ],
      64
    )
  );
}
const QM = B(YM, [["render", JM]]);
function eA(t) {
  return (
    typeof t == "function" ||
    (Object.prototype.toString.call(t) === "[object Object]" && !Nt(t))
  );
}
const Pf = new Map([
    [5, "V"],
    [10, "X"],
  ]),
  tA = new Map([
    ["V", 5],
    ["X", 10],
  ]);
function ec(t) {
  return t.clues.map((e) => ({ value: Pf.get(e.value) || "", edge: e.edge }));
}
function Lf(t) {
  return {
    default: ({ value: e }) => {
      if (!e && !t) return [];
      const n = { fill: "#000", "font-weight": "bold" };
      return [
        c("circle", { r: 0.16, fill: "#fff", stroke: "none" }, null),
        c(kn, St({ value: e, "font-size": 0.29 }, n), null),
      ];
    },
  };
}
const nA = Lf(!0),
  Dl = Lf(!1);
_e({
  type: _.XV,
  label: "XV",
  preview: XM,
  renderers: (t) => [
    {
      layer: oe.Foreground,
      component: c(
        Bo,
        { edgeClues: ec(t) },
        eA(Dl) ? Dl : { default: () => [Dl] }
      ),
    },
  ],
  editor: xe({
    editor: {
      component: ma,
      props: (t) => ({
        edgeClues: ec(t),
        inputMode: {
          ...Sh(),
          type: Ke.Replace,
          validation: (e) => e.length <= 1,
        },
        defaultValue: (e, n) => {
          if (e !== void 0 && n !== void 0) {
            if (e + n === 10) return "X";
            if (e + n === 5) return "V";
          }
          return t.clues.length === 0
            ? ""
            : Pf.get(t.clues[t.clues.length - 1].value) || "";
        },
      }),
      slots: nA,
    },
    propertiesForm: { component: QM, props: (t) => sn(t, "negative") },
    updateFunc: (t, e) => {
      const { edgeClues: n, negative: s } = e;
      n &&
        (t.clues = n.map((o) => {
          const r = String(o.value).at(-1);
          return { value: tA.get(r) || 0, edge: o.edge };
        })),
        s !== void 0 && (t.negative = s);
    },
  }),
});
const Ef = _1(m7);
Ef.use(g4);
Ef.mount(document.querySelector("#app"));
v7("Api", Hh);
g7();
